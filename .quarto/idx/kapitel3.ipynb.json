{"title":"Verzweigungen mit bedingten Anweisungen und Schleifen in Python","markdown":{"yaml":{"title":"Verzweigungen mit bedingten Anweisungen und Schleifen in Python"},"headingText":"Verzweigungen mit `if`, `else` und `elif`","containsRefs":false,"markdown":"\n\n\n\n\nDieses Tutorial ist das dritte einer Reihe zur Einführung in die Programmierung und Datenanalyse mit der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\n\nDie folgenden Themen werden in diesem Tutorial behandelt:\n\n* [Verzweigungen mit if, else und elif](#if-else-elif)\n* [Iteration mit while Schleifen](#while)\n* [Iteration mit for Schleifen](#for)\n\n\n\n<a id='if-else-elif'></a>\n\n\nEine wirklich mächtige Funktion von Programmiersprachen ist *Verzweigung*: die Fähigkeit, Entscheidungen zu treffen und abhängig davon, ob eine oder mehrere Bedingungen wahr sind, einen anderen Satz von Anweisungen auszuführen.\n\n### Die `if` Anweisung\n\nIn Python wird die Verzweigung mit der `if` Anweisung durchgeführt, die folgendermaßen geschrieben wird:\n\n```\nif Bedingung:\n    Anweisung1\n    Anweisung2\n```\n\nDie `Bedingung` kann entweder eine Variable oder ein Ausdruck sein. Wenn die Bedingung zu `True` auswertet, dann werden die Anweisungen innerhalb des *`if`-Blocks* ausgeführt. Beachte die 4 Leerzeichen vor `Anweisung1`, `Anweisung2` usw. Die Leerzeichen informieren Python, dass diese Anweisungen mit der darüber liegenden `if` Anweisung in Verbindung stehen. Diese Technik, den Code durch Hinzufügen von Leerzeichen zu strukturieren, wird *Einrückung* genannt.\n\n> **Einrückung**: Python stützt sich stark auf *Einrückungen (indentation)* (Leerraum vor einer Anweisung) um die Struktur im Code zu definieren. Das macht den Python-Code leicht zu lesen und zu verstehen, aber du kannst auf Probleme stoßen, wenn du die Einrückung nicht richtig verwendest. Rücke deinen Code ein, indem du den Cursor am Anfang der Zeile platzierst und einmal die `Tab` Taste drückst, um 4 Leerzeichen hinzuzufügen. Wenn du `Tab` noch einmal drückst, wird der Code um weitere 4 Leerzeichen eingerückt, und durch Drücken von `Shift+Tab` wird die Einrückung um 4 Leerzeichen reduziert.\n\nAls Beispiel schreiben wir einen Code, um eine Nachricht auszugeben, wenn eine gegebene Zahl gerade ist.\n\nBeachte, dass wir den Modulus-Operator `%` verwenden, um den Rest der Division von `a_number` durch `2` zu finden, und dann den Vergleichsoperator `==` verwenden, um zu überprüfen, ob der Rest `0` ist, was darauf hinweist, dass die Zahl durch 2 teilbar ist, also gerade ist.\n\nDa die Zahl `34` tatsächlich durch `2` teilbar ist, ergibt der Ausdruck `a_number % 2 == 0` den Wert `True`, sodass die `print` Anweisung unter der `if` Anweisung ausgeführt wird. Beachte auch, dass wir die String `format` Methode verwenden, um die Zahl in die Nachricht einzufügen.\n\nVersuchen wir das oben Gesagte erneut mit einer ungeraden Zahl.\n\nDa die Bedingung `another_number % 2 == 0` erwartungsgemäß `False` ergibt, wird keine Meldung ausgegeben.\n\n### Die `else` Anweisung\n\nWenn die Zahl im obigen Beispiel nicht gerade ist, möchten wir ebenfalls eine Meldung ausgeben. Dies kann durch Hinzufügen der `else`-Anweisung erfolgen.\n\n```\nif condition:\n    statement1\n    statement2\nelse:\n    statement4\n    statement5\n```\n\nWenn die `Bedingung` `True` ergibt, werden die Anweisungen im `if`-Block ausgeführt, und wenn sie `False` ergibt, werden die Anweisungen im `else`-Block ausgeführt.\n\nHier ist ein weiteres Beispiel, das den `in`-Operator verwendet, um die Existenz innerhalb eines Tupels zu überprüfen.\n\n### Die `elif` Anweisung\n\nPython bietet auch eine `elif` Anweisung (kurz für \"else if\"), um eine Reihe von bedingten Blöcken zu verketten. Die Bedingungen werden nacheinander ausgewertet. Für die erste Bedingung, die `True` ergibt, werden die Anweisungen im jeweiligen Block ausgeführt und die restlichen Bedingungen werden nicht ausgewertet. So wird in einer Kette von `if`, `elif`, `elif`... Anweisungen genau ein bedingter Block ausgewertet.\n\nIm obigen Beispiel werden die ersten drei Bedingungen als `False` ausgewertet, sodass keine der ersten drei Nachrichten ausgegeben wird. Die vierte Bedingung wird mit `True` ausgewertet, sodass die entsprechende Meldung ausgegeben wird. Die übrigen Bedingungen werden übersprungen. Versuchen Sie, den Wert von `today` oben zu ändern und die Zellen erneut auszuführen, um alle verschiedenen Nachrichten zu auszugeben.\n\n\nUm zu überprüfen, ob die übrigen Bedingungen übersprungen werden, versuchen wir es mit einem anderen Beispiel.\n\nBeachten Sie, dass die Nachricht `15 is divisible by 5` nicht ausgegeben wird, weil die Bedingung `a_number % 5 == 0` nicht ausgewertet wird, da die vorherige Bedingung `a_number % 3 == 0` zu `True` auswertet. Dies ist der entscheidende Unterschied zwischen einer Kette von `if`, `elif`, `elif`... Anweisungen und einfach einer Kette von `if` Anweisungen, bei denen jede Bedingung unabhängig ausgewertet wird.\n\n### Gemeinsame Verwendung von `if`, `elif` und `else`.\n\nSie können auch eine `else`-Anweisung am Ende einer Kette von `if`, `elif`...-Anweisungen einfügen. Dieser Code im `else`-Block wird ausgewertet, wenn keine der Bedingungen zutrifft.\n\nBedingungen können auch mit den logischen Operatoren `and`, `or` und `not` kombiniert werden.\n\n### Nicht-Boolesche Bedingungen\n\nBeachten Sie, dass Bedingungen nicht unbedingt boolesche Werte sein müssen. Tatsächlich kann eine Bedingung einen beliebigen Wert haben. Der Wert wird mithilfe des `bool` Operators automatisch in einen booleschen Wert umgewandelt. Das bedeutet, dass falsche Werte wie `0`, `''`, `{}`, `[]` usw. als `False` und alle anderen Werte als `True` ausgewertet werden.\n\n### Verschachtelte bedingte Anweisungen\n\nDer Code in einem `if`-Block kann auch eine `if` Anweisung enthalten. Dieses Muster wird `Verschachtelung (nesting)` genannt und wird verwendet, wenn Sie nach einer anderen Bedingung suchen müssen, nachdem eine bestimmte Bedingung als wahr bewertet wurde.\n\nBeachten Sie, dass die `print` Anweisungen um 8 Leerzeichen eingerückt sind, um anzuzeigen, dass sie Teil der inneren `if`/`else` Blöcke sind.\n\n> Verschachtelte `if`- und `else`-Anweisungen sind oft verwirrend zu lesen und anfällig für menschliches Versagen. Es empfiehlt sich, die Verschachtelung nach Möglichkeit zu vermeiden oder die Verschachtelung auf 1 oder 2 Ebenen zu beschränken.\n\n### Abkürzung für den bedingten Ausdruck `if`\n\nEin häufiger Anwendungsfall der `if`-Anweisung besteht darin, eine Bedingung zu testen und den Wert einer Variablen basierend auf der Bedingung festzulegen.\n\nPython bietet eine kürzere Syntax, die das Schreiben solcher Bedingungen in einer einzigen Codezeile ermöglicht. Es ist als *bedingter Ausdruck* bekannt, manchmal auch als *ternärer Operator*. Es hat die folgende Syntax:\n\n```\nx = true_value if condition else false_value\n```\n\nEs hat das gleiche Verhalten wie der folgende `if`-`else`-Block:\n\n```\nif condition:\n    x = true_value\nelse:\n    x = false_value\n```\n\nProbieren wir es am Beispiel oben aus.\n\n### Anweisungen und Ausdrücke\n\nDer bedingte Ausdruck unterstreicht eine wichtige Unterscheidung zwischen *Anweisungen* und *Ausdrücken* in Python. \n\n> **Anweisungen**: Eine Anweisung (statement) ist eine ausführbare Anweisung. Jede Zeile Code, die wir bisher geschrieben haben, ist eine Anweisung, z. B. das Zuweisen einer Variable, das Aufrufen einer Funktion, bedingte Anweisungen mit `if`, `else` und `elif`, Schleifen mit `for` und `while` usw.\n\n> **Ausdrücke**: Ein Ausdruck (expression) ist ein Code, der zu einem Wert ausgewertet wird. Beispiele sind Werte verschiedener Datentypen, arithmetische Ausdrücke, Bedingungen, Variablen, Funktionsaufrufe, bedingte Ausdrücke usw.\n\n\nDie meisten Ausdrücke können als Anweisungen ausgeführt werden, aber nicht alle Anweisungen sind Ausdrücke. Zum Beispiel ist die `if`-Anweisung kein Ausdruck, da sie nicht zu einem Wert ausgewertet wird, sie führt einfach nur eine Verzweigung im Code aus. Ähnlich verhält es sich mit Schleifen und Funktionsdefinitionen, die keine Ausdrücke sind (wir werden in späteren Abschnitten mehr darüber lernen).\n\nAls Faustregel gilt: Ein Ausdruck ist alles, was auf der rechten Seite des Zuweisungsoperators `=` erscheinen kann. Sie können dies als Test verwenden, um zu überprüfen, ob etwas ein Ausdruck ist oder nicht. Sie erhalten einen Syntaxfehler, wenn Sie versuchen, etwas zuzuweisen, das kein Ausdruck ist.\n\n### Die `pass` Anweisung\n\n`if` Anweisungen können nicht leer sein, es muss mindestens eine Anweisung in jedem `if` und `elif` Block geben. Sie können die `pass` Anweisung verwenden, um nichts zu tun und einen Fehler zu vermeiden.\n\n<a id='while'></a>\n\n## Iteration mit `while` Schleifen\n\n### Grundlagen\n\nEine weitere leistungsstarke Funktion von Programmiersprachen, die eng mit Verzweigungen verbunden ist, ist die Fähigkeit, eine oder mehrere Anweisungen mehrmals auszuführen. Diese Funktion wird oft als *Iteration* oder *Schleifenbildung* bezeichnet, und es gibt zwei Möglichkeiten, dies in Python zu tun: Mit `while` Schleifen und `for` Schleifen. \n\n`while` Schleifen haben die folgende Syntax:\n\n```\nwhile Bedingung:\n    Anweisung(en)\n```\n\nDie Anweisungen im Block unter `while` werden wiederholt ausgeführt, solange die `Bedingung` zu `True` ausgewertet wird. In den meisten Fällen bewirkt der Block von Anweisungen eine Änderung einer Variablen, die dazu führt, dass die Bedingung nach einer bestimmten Anzahl von Iterationen zu `False` ausgewertet wird.\n\nVersuchen wir als Beispiel, die Fakultät von `100` mit einer `while` Schleife zu berechnen. Die Fakultät einer Zahl `n` ist definiert als das Produkt oder die Multiplikation aller Zahlen von `1` bis `n`, also `1*2*3*...*(n-2)*(n-1)*n`.\n\nSo funktioniert der obige Code:\n\n* Wir initialisieren zwei Variablen `result` und `i`. `result` enthält das endgültige Ergebnis der Berechnung. Und `i` wird verwendet, um die nächste zu `result` zu multiplizierende Zahl zu verfolgen. Beide werden auf 1 initialisiert (können Sie erklären warum?)\n\n* Die Bedingung `i<=100` gilt als wahr (da `i` zunächst `1` ist), daher werden die Anweisungen im Block unter `while` ausgeführt.\n\n* Das `result` wird auf `result * i` aktualisiert, und `i` wird um `1` erhöht und hat nun den Wert `2`.\n\n* An diesem Punkt wird die Bedingung `i<=100` erneut ausgeführt, und da sie weiterhin als wahr gilt, wird das `result` erneut auf `result * i` aktualisiert und `i` wird auf `3` erhöht.\n\n* Dieser Prozess wird wiederholt, bis die Bedingung falsch wird, was passiert, wenn `i` den Wert `101` hat. Sobald die Bedingung zu `False` ausgewertet wird, endet die Ausführung der Schleife und die darunter liegende `print` Anweisung wird ausgeführt.\n\nKönnen Sie sehen, warum `result` am Ende der Schleife den Wert der Fakultät von 100 hat? Wenn nicht, versuchen Sie, `print` Anweisungen innerhalb der Schleife hinzuzufügen, um die Werte von `result` und `i` am Ende jeder Schleife auszugeben.\n\n\n> `Iteration` ist eine wirklich mächtige Technik, denn sie gibt Computern einen großen Vorteil gegenüber Menschen, wenn es darum geht, Hunderte oder Millionen von wiederholten Operationen sehr schnell auszuführen. Mit nur 4-5 Zeilen Code konnten wir fast sofort 100 Zahlen multiplizieren. Was noch interessanter ist, ist, dass der gleiche Code verwendet werden kann, um tausend Zahlen zu multiplizieren (ändern Sie einfach die Bedingung auf `i <= 1000`) in nur wenigen Sekunden.\n\nSie können überprüfen, wie lange eine Zelle zur Ausführung braucht, indem Sie den speziellen *magic* Befehl `%%time` an den Anfang einer Zelle setzen. Versuchen Sie zu überprüfen, wie lange es dauert, die Fakultät von `100`, `1000`, `10000`, `100000` usw. zu berechnen.\n\nHier ist ein weiteres Beispiel, das zwei `while`-Schleifen verwendet, um ein interessantes Muster zu erstellen.\n\n### Endlosschleifen\n\nWenn die Bedingung in einer `while`-Schleife immer wahr ist, führt Python den Code innerhalb der Schleife immer wieder aus und die Ausführung des Codes wird nie abgeschlossen. Diese Situation wird als Endlosschleife bezeichnet und weist im Allgemeinen darauf hin, dass Sie einen Fehler in Ihrem Code gemacht haben, z. B. Verwenden der falschen Bedingung oder Vergessen, eine Variable mit einer Schleife zu aktualisieren, wodurch die Bedingung letztendlich falsch wird.\n\nWenn Ihr Code während der Ausführung in einer Endlosschleife *stecken bleibt*, klicken Sie einfach auf die Schaltfläche `Stop` in der Symbolleiste (neben `Run`) oder wählen Sie `Kernel > Interrupt` aus der Jupyter-Menüleiste, um die Ausführung zu stoppen bzw *unterbricht* die Ausführung des Codes. Die nächsten beiden Zellen führen beide zu Endlosschleifen und müssen unterbrochen werden.\n\n### `break`- und `continue`-Anweisungen\n\nSie können die `break`-Anweisung im Hauptteil der Schleife verwenden, um die Ausführung sofort zu stoppen und die Schleife zu *break* zu verlassen (auch wenn die für `while` angegebene Bedingung immer noch wahr ist).\n\nWie Sie oben sehen können, beträgt der Wert von `i` am Ende der Ausführung 42. Dieses Beispiel zeigt auch, wie Sie eine `if`-Anweisung innerhalb einer `while`-Schleife verwenden können.\n\nManchmal möchten Sie vielleicht nicht die gesamte Schleife beenden, sondern einfach die verbleibenden Anweisungen in der Schleife überspringen und *weiter* zur nächsten Schleife gehen. Dies können Sie mit der `continue`-Anweisung erreichen.\n\nIm obigen Beispiel wird die letzte Anweisung der Schleife `result = result * i` übersprungen, wenn `i` gerade ist, wie durch die während der Ausführung ausgegebenen Meldungen angezeigt.\n\n> **Logging**: Der Vorgang des Hinzufügens von `print`-Anweisungen an verschiedenen Punkten im Code (oft innerhalb von Schleifen und bedingten Anweisungen) zur Überprüfung der Werte von Variablen in verschiedenen Ausführungsstadien wird als Logging bezeichnet. Da unsere Programme mit zunehmender Komplexität naturgemäß anfällig für menschliche Fehler werden, kann Logging dabei helfen, zu überprüfen, ob das Programm wie erwartet funktioniert. In vielen Fällen werden `print`-Anweisungen hinzugefügt, während Code geschrieben und getestet wird, und am Ende wieder entfernt.\n\n<a id='for'></a>\n\n## Iteration mit `for` Schleifen\n\n### Grundlagen\n\nEin `for`-Loop wird zum Iterieren oder Schleifen über Sequenzen verwendet, d.h. Listen, Tupel, Wörterbücher, Strings und *Ranges*. For-Schleifen haben die folgende Syntax:\n\n```\nfor value in sequence:\n    statement(s)\n```\n\nDie Anweisungen innerhalb der Schleife werden einmal für jedes Element in `Sequenz` ausgeführt. Hier ist ein Beispiel, das alle Elemente einer Liste ausgibt.\n\nVersuchen wir, `for` Schleifen mit einigen anderen Datentypen zu verwenden.\n\nBeachten Sie, dass bei der Verwendung eines Dictionaries mit einer `for`-Schleife die Iteration über Schlüssel(keys) im Dictionary erfolgt. Der Schlüssel kann innerhalb der Schleife verwendet werden, um auf den Wert zuzugreifen. Sie können auch direkt über die Werte mit der `.values` Methode des Dictionaries iterieren, oder über Schlüssel-Wert-Paare mit der `.items` Methode.\n\nDa es sich bei einem Schlüssel-Wert-Paar um ein Tupel handelt, können wir Schlüssel und Wert auch in separate Variablen extrahieren.\n\n### Iterieren mit `range` und `enumerate`.\n\nDie `range` Funktion wird verwendet, um eine Sequenz von Zahlen zu erzeugen, über die mit einer `for`-Schleife iteriert werden kann. Sie kann auf 3 Arten verwendet werden:\n\n* `range(n)` - Erstellt eine Sequenz von Zahlen von `0` bis `n-1`\n* `range(a, b)` - Erstellt eine Sequenz von Zahlen von `a` bis `b-1`\n* `range(a, b, step)` - Erstellt eine Sequenz von Zahlen von `a` bis `b-1` mit Schritten von `step`\n\nLassen Sie es uns ausprobieren.\n\nUm Inkremente einer bestimmten Länge durchzuführen, verwenden Sie das dritte Argument in `range()`, z. B. `range(3, 14, 4)`. Dies führt zu einer Schleife von 3 bis 13 in Schritten von 4\n\nBereiche werden für die Iteration über Listen verwendet, wenn Sie während der Iteration den Index von Elementen verfolgen müssen.\n\nEine andere Möglichkeit, das gleiche Ergebnis wie oben zu erzielen, ist die Verwendung der Funktion `enumerate` mit `a_list` als Eingabe, die ein Tupel zurückgibt, das den Index und das entsprechende Element enthält.\n\n### `break`-, `continue`- und `pass`-Anweisungen\n\nÄhnlich wie `while`-Schleifen unterstützen `for`-Schleifen auch die Anweisung `break`, um aus der Schleife auszubrechen, und `continue`, um zur nächsten Iteration zu springen.\n\nÄhnlich wie `if`-Anweisungen dürfen `for`-Schleifen nicht leer sein. Sie können also eine `pass`-Anweisung verwenden, falls Sie keine Anweisungen innerhalb der Schleife ausführen möchten.\n\n### Verschachtelte `for`- und `while`-Schleifen\n\nÄhnlich wie bedingte Anweisungen können Schleifen in anderen Schleifen verschachtelt werden. Dies ist nützlich, um jedes Element in einer Liste von Listen, einer Liste von Wörterbüchern usw. zu durchlaufen.\n\n## Weiterführende Literatur und Referenzen\n\nIm Folgenden finden Sie einige Ressourcen, um mehr über bedingte Anweisungen und Schleifen in Python zu erfahren:\n\n* [Python-Tutorial bei W3Schools](https://www.w3schools.com/python/)\n* [Praktische Python-Programmierung](https://dabeaz-course.github.io/practical-python/Notes/Contents.html)\n* [Offizielle Python-Dokumentation](https://docs.python.org/3/tutorial/index.html)\n","srcMarkdownNoYaml":"\n\n\n\n\nDieses Tutorial ist das dritte einer Reihe zur Einführung in die Programmierung und Datenanalyse mit der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\n\nDie folgenden Themen werden in diesem Tutorial behandelt:\n\n* [Verzweigungen mit if, else und elif](#if-else-elif)\n* [Iteration mit while Schleifen](#while)\n* [Iteration mit for Schleifen](#for)\n\n\n\n<a id='if-else-elif'></a>\n\n## Verzweigungen mit `if`, `else` und `elif`\n\nEine wirklich mächtige Funktion von Programmiersprachen ist *Verzweigung*: die Fähigkeit, Entscheidungen zu treffen und abhängig davon, ob eine oder mehrere Bedingungen wahr sind, einen anderen Satz von Anweisungen auszuführen.\n\n### Die `if` Anweisung\n\nIn Python wird die Verzweigung mit der `if` Anweisung durchgeführt, die folgendermaßen geschrieben wird:\n\n```\nif Bedingung:\n    Anweisung1\n    Anweisung2\n```\n\nDie `Bedingung` kann entweder eine Variable oder ein Ausdruck sein. Wenn die Bedingung zu `True` auswertet, dann werden die Anweisungen innerhalb des *`if`-Blocks* ausgeführt. Beachte die 4 Leerzeichen vor `Anweisung1`, `Anweisung2` usw. Die Leerzeichen informieren Python, dass diese Anweisungen mit der darüber liegenden `if` Anweisung in Verbindung stehen. Diese Technik, den Code durch Hinzufügen von Leerzeichen zu strukturieren, wird *Einrückung* genannt.\n\n> **Einrückung**: Python stützt sich stark auf *Einrückungen (indentation)* (Leerraum vor einer Anweisung) um die Struktur im Code zu definieren. Das macht den Python-Code leicht zu lesen und zu verstehen, aber du kannst auf Probleme stoßen, wenn du die Einrückung nicht richtig verwendest. Rücke deinen Code ein, indem du den Cursor am Anfang der Zeile platzierst und einmal die `Tab` Taste drückst, um 4 Leerzeichen hinzuzufügen. Wenn du `Tab` noch einmal drückst, wird der Code um weitere 4 Leerzeichen eingerückt, und durch Drücken von `Shift+Tab` wird die Einrückung um 4 Leerzeichen reduziert.\n\nAls Beispiel schreiben wir einen Code, um eine Nachricht auszugeben, wenn eine gegebene Zahl gerade ist.\n\nBeachte, dass wir den Modulus-Operator `%` verwenden, um den Rest der Division von `a_number` durch `2` zu finden, und dann den Vergleichsoperator `==` verwenden, um zu überprüfen, ob der Rest `0` ist, was darauf hinweist, dass die Zahl durch 2 teilbar ist, also gerade ist.\n\nDa die Zahl `34` tatsächlich durch `2` teilbar ist, ergibt der Ausdruck `a_number % 2 == 0` den Wert `True`, sodass die `print` Anweisung unter der `if` Anweisung ausgeführt wird. Beachte auch, dass wir die String `format` Methode verwenden, um die Zahl in die Nachricht einzufügen.\n\nVersuchen wir das oben Gesagte erneut mit einer ungeraden Zahl.\n\nDa die Bedingung `another_number % 2 == 0` erwartungsgemäß `False` ergibt, wird keine Meldung ausgegeben.\n\n### Die `else` Anweisung\n\nWenn die Zahl im obigen Beispiel nicht gerade ist, möchten wir ebenfalls eine Meldung ausgeben. Dies kann durch Hinzufügen der `else`-Anweisung erfolgen.\n\n```\nif condition:\n    statement1\n    statement2\nelse:\n    statement4\n    statement5\n```\n\nWenn die `Bedingung` `True` ergibt, werden die Anweisungen im `if`-Block ausgeführt, und wenn sie `False` ergibt, werden die Anweisungen im `else`-Block ausgeführt.\n\nHier ist ein weiteres Beispiel, das den `in`-Operator verwendet, um die Existenz innerhalb eines Tupels zu überprüfen.\n\n### Die `elif` Anweisung\n\nPython bietet auch eine `elif` Anweisung (kurz für \"else if\"), um eine Reihe von bedingten Blöcken zu verketten. Die Bedingungen werden nacheinander ausgewertet. Für die erste Bedingung, die `True` ergibt, werden die Anweisungen im jeweiligen Block ausgeführt und die restlichen Bedingungen werden nicht ausgewertet. So wird in einer Kette von `if`, `elif`, `elif`... Anweisungen genau ein bedingter Block ausgewertet.\n\nIm obigen Beispiel werden die ersten drei Bedingungen als `False` ausgewertet, sodass keine der ersten drei Nachrichten ausgegeben wird. Die vierte Bedingung wird mit `True` ausgewertet, sodass die entsprechende Meldung ausgegeben wird. Die übrigen Bedingungen werden übersprungen. Versuchen Sie, den Wert von `today` oben zu ändern und die Zellen erneut auszuführen, um alle verschiedenen Nachrichten zu auszugeben.\n\n\nUm zu überprüfen, ob die übrigen Bedingungen übersprungen werden, versuchen wir es mit einem anderen Beispiel.\n\nBeachten Sie, dass die Nachricht `15 is divisible by 5` nicht ausgegeben wird, weil die Bedingung `a_number % 5 == 0` nicht ausgewertet wird, da die vorherige Bedingung `a_number % 3 == 0` zu `True` auswertet. Dies ist der entscheidende Unterschied zwischen einer Kette von `if`, `elif`, `elif`... Anweisungen und einfach einer Kette von `if` Anweisungen, bei denen jede Bedingung unabhängig ausgewertet wird.\n\n### Gemeinsame Verwendung von `if`, `elif` und `else`.\n\nSie können auch eine `else`-Anweisung am Ende einer Kette von `if`, `elif`...-Anweisungen einfügen. Dieser Code im `else`-Block wird ausgewertet, wenn keine der Bedingungen zutrifft.\n\nBedingungen können auch mit den logischen Operatoren `and`, `or` und `not` kombiniert werden.\n\n### Nicht-Boolesche Bedingungen\n\nBeachten Sie, dass Bedingungen nicht unbedingt boolesche Werte sein müssen. Tatsächlich kann eine Bedingung einen beliebigen Wert haben. Der Wert wird mithilfe des `bool` Operators automatisch in einen booleschen Wert umgewandelt. Das bedeutet, dass falsche Werte wie `0`, `''`, `{}`, `[]` usw. als `False` und alle anderen Werte als `True` ausgewertet werden.\n\n### Verschachtelte bedingte Anweisungen\n\nDer Code in einem `if`-Block kann auch eine `if` Anweisung enthalten. Dieses Muster wird `Verschachtelung (nesting)` genannt und wird verwendet, wenn Sie nach einer anderen Bedingung suchen müssen, nachdem eine bestimmte Bedingung als wahr bewertet wurde.\n\nBeachten Sie, dass die `print` Anweisungen um 8 Leerzeichen eingerückt sind, um anzuzeigen, dass sie Teil der inneren `if`/`else` Blöcke sind.\n\n> Verschachtelte `if`- und `else`-Anweisungen sind oft verwirrend zu lesen und anfällig für menschliches Versagen. Es empfiehlt sich, die Verschachtelung nach Möglichkeit zu vermeiden oder die Verschachtelung auf 1 oder 2 Ebenen zu beschränken.\n\n### Abkürzung für den bedingten Ausdruck `if`\n\nEin häufiger Anwendungsfall der `if`-Anweisung besteht darin, eine Bedingung zu testen und den Wert einer Variablen basierend auf der Bedingung festzulegen.\n\nPython bietet eine kürzere Syntax, die das Schreiben solcher Bedingungen in einer einzigen Codezeile ermöglicht. Es ist als *bedingter Ausdruck* bekannt, manchmal auch als *ternärer Operator*. Es hat die folgende Syntax:\n\n```\nx = true_value if condition else false_value\n```\n\nEs hat das gleiche Verhalten wie der folgende `if`-`else`-Block:\n\n```\nif condition:\n    x = true_value\nelse:\n    x = false_value\n```\n\nProbieren wir es am Beispiel oben aus.\n\n### Anweisungen und Ausdrücke\n\nDer bedingte Ausdruck unterstreicht eine wichtige Unterscheidung zwischen *Anweisungen* und *Ausdrücken* in Python. \n\n> **Anweisungen**: Eine Anweisung (statement) ist eine ausführbare Anweisung. Jede Zeile Code, die wir bisher geschrieben haben, ist eine Anweisung, z. B. das Zuweisen einer Variable, das Aufrufen einer Funktion, bedingte Anweisungen mit `if`, `else` und `elif`, Schleifen mit `for` und `while` usw.\n\n> **Ausdrücke**: Ein Ausdruck (expression) ist ein Code, der zu einem Wert ausgewertet wird. Beispiele sind Werte verschiedener Datentypen, arithmetische Ausdrücke, Bedingungen, Variablen, Funktionsaufrufe, bedingte Ausdrücke usw.\n\n\nDie meisten Ausdrücke können als Anweisungen ausgeführt werden, aber nicht alle Anweisungen sind Ausdrücke. Zum Beispiel ist die `if`-Anweisung kein Ausdruck, da sie nicht zu einem Wert ausgewertet wird, sie führt einfach nur eine Verzweigung im Code aus. Ähnlich verhält es sich mit Schleifen und Funktionsdefinitionen, die keine Ausdrücke sind (wir werden in späteren Abschnitten mehr darüber lernen).\n\nAls Faustregel gilt: Ein Ausdruck ist alles, was auf der rechten Seite des Zuweisungsoperators `=` erscheinen kann. Sie können dies als Test verwenden, um zu überprüfen, ob etwas ein Ausdruck ist oder nicht. Sie erhalten einen Syntaxfehler, wenn Sie versuchen, etwas zuzuweisen, das kein Ausdruck ist.\n\n### Die `pass` Anweisung\n\n`if` Anweisungen können nicht leer sein, es muss mindestens eine Anweisung in jedem `if` und `elif` Block geben. Sie können die `pass` Anweisung verwenden, um nichts zu tun und einen Fehler zu vermeiden.\n\n<a id='while'></a>\n\n## Iteration mit `while` Schleifen\n\n### Grundlagen\n\nEine weitere leistungsstarke Funktion von Programmiersprachen, die eng mit Verzweigungen verbunden ist, ist die Fähigkeit, eine oder mehrere Anweisungen mehrmals auszuführen. Diese Funktion wird oft als *Iteration* oder *Schleifenbildung* bezeichnet, und es gibt zwei Möglichkeiten, dies in Python zu tun: Mit `while` Schleifen und `for` Schleifen. \n\n`while` Schleifen haben die folgende Syntax:\n\n```\nwhile Bedingung:\n    Anweisung(en)\n```\n\nDie Anweisungen im Block unter `while` werden wiederholt ausgeführt, solange die `Bedingung` zu `True` ausgewertet wird. In den meisten Fällen bewirkt der Block von Anweisungen eine Änderung einer Variablen, die dazu führt, dass die Bedingung nach einer bestimmten Anzahl von Iterationen zu `False` ausgewertet wird.\n\nVersuchen wir als Beispiel, die Fakultät von `100` mit einer `while` Schleife zu berechnen. Die Fakultät einer Zahl `n` ist definiert als das Produkt oder die Multiplikation aller Zahlen von `1` bis `n`, also `1*2*3*...*(n-2)*(n-1)*n`.\n\nSo funktioniert der obige Code:\n\n* Wir initialisieren zwei Variablen `result` und `i`. `result` enthält das endgültige Ergebnis der Berechnung. Und `i` wird verwendet, um die nächste zu `result` zu multiplizierende Zahl zu verfolgen. Beide werden auf 1 initialisiert (können Sie erklären warum?)\n\n* Die Bedingung `i<=100` gilt als wahr (da `i` zunächst `1` ist), daher werden die Anweisungen im Block unter `while` ausgeführt.\n\n* Das `result` wird auf `result * i` aktualisiert, und `i` wird um `1` erhöht und hat nun den Wert `2`.\n\n* An diesem Punkt wird die Bedingung `i<=100` erneut ausgeführt, und da sie weiterhin als wahr gilt, wird das `result` erneut auf `result * i` aktualisiert und `i` wird auf `3` erhöht.\n\n* Dieser Prozess wird wiederholt, bis die Bedingung falsch wird, was passiert, wenn `i` den Wert `101` hat. Sobald die Bedingung zu `False` ausgewertet wird, endet die Ausführung der Schleife und die darunter liegende `print` Anweisung wird ausgeführt.\n\nKönnen Sie sehen, warum `result` am Ende der Schleife den Wert der Fakultät von 100 hat? Wenn nicht, versuchen Sie, `print` Anweisungen innerhalb der Schleife hinzuzufügen, um die Werte von `result` und `i` am Ende jeder Schleife auszugeben.\n\n\n> `Iteration` ist eine wirklich mächtige Technik, denn sie gibt Computern einen großen Vorteil gegenüber Menschen, wenn es darum geht, Hunderte oder Millionen von wiederholten Operationen sehr schnell auszuführen. Mit nur 4-5 Zeilen Code konnten wir fast sofort 100 Zahlen multiplizieren. Was noch interessanter ist, ist, dass der gleiche Code verwendet werden kann, um tausend Zahlen zu multiplizieren (ändern Sie einfach die Bedingung auf `i <= 1000`) in nur wenigen Sekunden.\n\nSie können überprüfen, wie lange eine Zelle zur Ausführung braucht, indem Sie den speziellen *magic* Befehl `%%time` an den Anfang einer Zelle setzen. Versuchen Sie zu überprüfen, wie lange es dauert, die Fakultät von `100`, `1000`, `10000`, `100000` usw. zu berechnen.\n\nHier ist ein weiteres Beispiel, das zwei `while`-Schleifen verwendet, um ein interessantes Muster zu erstellen.\n\n### Endlosschleifen\n\nWenn die Bedingung in einer `while`-Schleife immer wahr ist, führt Python den Code innerhalb der Schleife immer wieder aus und die Ausführung des Codes wird nie abgeschlossen. Diese Situation wird als Endlosschleife bezeichnet und weist im Allgemeinen darauf hin, dass Sie einen Fehler in Ihrem Code gemacht haben, z. B. Verwenden der falschen Bedingung oder Vergessen, eine Variable mit einer Schleife zu aktualisieren, wodurch die Bedingung letztendlich falsch wird.\n\nWenn Ihr Code während der Ausführung in einer Endlosschleife *stecken bleibt*, klicken Sie einfach auf die Schaltfläche `Stop` in der Symbolleiste (neben `Run`) oder wählen Sie `Kernel > Interrupt` aus der Jupyter-Menüleiste, um die Ausführung zu stoppen bzw *unterbricht* die Ausführung des Codes. Die nächsten beiden Zellen führen beide zu Endlosschleifen und müssen unterbrochen werden.\n\n### `break`- und `continue`-Anweisungen\n\nSie können die `break`-Anweisung im Hauptteil der Schleife verwenden, um die Ausführung sofort zu stoppen und die Schleife zu *break* zu verlassen (auch wenn die für `while` angegebene Bedingung immer noch wahr ist).\n\nWie Sie oben sehen können, beträgt der Wert von `i` am Ende der Ausführung 42. Dieses Beispiel zeigt auch, wie Sie eine `if`-Anweisung innerhalb einer `while`-Schleife verwenden können.\n\nManchmal möchten Sie vielleicht nicht die gesamte Schleife beenden, sondern einfach die verbleibenden Anweisungen in der Schleife überspringen und *weiter* zur nächsten Schleife gehen. Dies können Sie mit der `continue`-Anweisung erreichen.\n\nIm obigen Beispiel wird die letzte Anweisung der Schleife `result = result * i` übersprungen, wenn `i` gerade ist, wie durch die während der Ausführung ausgegebenen Meldungen angezeigt.\n\n> **Logging**: Der Vorgang des Hinzufügens von `print`-Anweisungen an verschiedenen Punkten im Code (oft innerhalb von Schleifen und bedingten Anweisungen) zur Überprüfung der Werte von Variablen in verschiedenen Ausführungsstadien wird als Logging bezeichnet. Da unsere Programme mit zunehmender Komplexität naturgemäß anfällig für menschliche Fehler werden, kann Logging dabei helfen, zu überprüfen, ob das Programm wie erwartet funktioniert. In vielen Fällen werden `print`-Anweisungen hinzugefügt, während Code geschrieben und getestet wird, und am Ende wieder entfernt.\n\n<a id='for'></a>\n\n## Iteration mit `for` Schleifen\n\n### Grundlagen\n\nEin `for`-Loop wird zum Iterieren oder Schleifen über Sequenzen verwendet, d.h. Listen, Tupel, Wörterbücher, Strings und *Ranges*. For-Schleifen haben die folgende Syntax:\n\n```\nfor value in sequence:\n    statement(s)\n```\n\nDie Anweisungen innerhalb der Schleife werden einmal für jedes Element in `Sequenz` ausgeführt. Hier ist ein Beispiel, das alle Elemente einer Liste ausgibt.\n\nVersuchen wir, `for` Schleifen mit einigen anderen Datentypen zu verwenden.\n\nBeachten Sie, dass bei der Verwendung eines Dictionaries mit einer `for`-Schleife die Iteration über Schlüssel(keys) im Dictionary erfolgt. Der Schlüssel kann innerhalb der Schleife verwendet werden, um auf den Wert zuzugreifen. Sie können auch direkt über die Werte mit der `.values` Methode des Dictionaries iterieren, oder über Schlüssel-Wert-Paare mit der `.items` Methode.\n\nDa es sich bei einem Schlüssel-Wert-Paar um ein Tupel handelt, können wir Schlüssel und Wert auch in separate Variablen extrahieren.\n\n### Iterieren mit `range` und `enumerate`.\n\nDie `range` Funktion wird verwendet, um eine Sequenz von Zahlen zu erzeugen, über die mit einer `for`-Schleife iteriert werden kann. Sie kann auf 3 Arten verwendet werden:\n\n* `range(n)` - Erstellt eine Sequenz von Zahlen von `0` bis `n-1`\n* `range(a, b)` - Erstellt eine Sequenz von Zahlen von `a` bis `b-1`\n* `range(a, b, step)` - Erstellt eine Sequenz von Zahlen von `a` bis `b-1` mit Schritten von `step`\n\nLassen Sie es uns ausprobieren.\n\nUm Inkremente einer bestimmten Länge durchzuführen, verwenden Sie das dritte Argument in `range()`, z. B. `range(3, 14, 4)`. Dies führt zu einer Schleife von 3 bis 13 in Schritten von 4\n\nBereiche werden für die Iteration über Listen verwendet, wenn Sie während der Iteration den Index von Elementen verfolgen müssen.\n\nEine andere Möglichkeit, das gleiche Ergebnis wie oben zu erzielen, ist die Verwendung der Funktion `enumerate` mit `a_list` als Eingabe, die ein Tupel zurückgibt, das den Index und das entsprechende Element enthält.\n\n### `break`-, `continue`- und `pass`-Anweisungen\n\nÄhnlich wie `while`-Schleifen unterstützen `for`-Schleifen auch die Anweisung `break`, um aus der Schleife auszubrechen, und `continue`, um zur nächsten Iteration zu springen.\n\nÄhnlich wie `if`-Anweisungen dürfen `for`-Schleifen nicht leer sein. Sie können also eine `pass`-Anweisung verwenden, falls Sie keine Anweisungen innerhalb der Schleife ausführen möchten.\n\n### Verschachtelte `for`- und `while`-Schleifen\n\nÄhnlich wie bedingte Anweisungen können Schleifen in anderen Schleifen verschachtelt werden. Dies ist nützlich, um jedes Element in einer Liste von Listen, einer Liste von Wörterbüchern usw. zu durchlaufen.\n\n## Weiterführende Literatur und Referenzen\n\nIm Folgenden finden Sie einige Ressourcen, um mehr über bedingte Anweisungen und Schleifen in Python zu erfahren:\n\n* [Python-Tutorial bei W3Schools](https://www.w3schools.com/python/)\n* [Praktische Python-Programmierung](https://dabeaz-course.github.io/practical-python/Notes/Contents.html)\n* [Offizielle Python-Dokumentation](https://docs.python.org/3/tutorial/index.html)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"css":["styles.css"],"output-file":"kapitel3.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":{"light":"flatly","dark":"darkly"},"code-copy":true,"smooth-scroll":true,"title":"Verzweigungen mit bedingten Anweisungen und Schleifen in Python"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
{"title":"Analyse tabellarischer Daten mit Python und Pandas","markdown":{"yaml":{"title":"Analyse tabellarischer Daten mit Python und Pandas"},"headingText":"Eine CSV-Datei mit Pandas einlesen","containsRefs":false,"markdown":"\n\n\n\n\nDieses Tutorial ist das sechste in einer Reihe zur Einführung in die Programmierung und Datenanalyse mithilfe der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\n\n\nDie folgenden Themen werden in diesem Tutorial behandelt:\n\n* [Eine CSV-Datei mit Pandas einlesen](#csv-pandas-einlesen)\n* [Abrufen von Daten aus einem Data Frame](#daten-data-frame)\n* [Analysieren von Daten aus Data Frame](#analysieren-data-frame)\n* [Zeilen abfragen und sortieren](#zeilen-abfragen)\n* [Mit Datumsangaben arbeiten](#datumsangaben-arbeiten)\n* [Gruppierung und Aggregation](#gruppierung-aggregation)\n* [Daten aus mehreren Quellen zusammenführen](#mehrere-quellen)\n* [Daten zurück in Dateien schreiben](#dateien-schreiben)\n* [Bonus: Grundlegendes Plotten mit Pandas](#bonus-plotten)\n\n\n\n<a id='csv-pandas-einlesen'></a>\n\n\nPandas wird in der Regel verwendet, um mit tabellarischen Daten zu arbeiten (ähnlich wie die Daten, die in einer Tabelle gespeichert sind). Pandas bietet Hilfsfunktionen zum Einlesen von Daten aus verschiedenen Dateiformaten wie CSV, Excel-Tabellen, HTML-Tabellen, JSON, SQL und mehr. Lassen Sie uns die Datei `italy-covid-daywise.txt` herunterladen, die tageweise Covid-19-Daten für Italien im folgenden Format enthält:\n\n```\ndate,new_cases,new_deaths,new_tests\n2020-04-21,2256.0,454.0,28095.0\n2020-04-22,2729.0,534.0,44248.0\n2020-04-23,3370.0,437.0,37083.0\n2020-04-24,2646.0,464.0,95273.0\n2020-04-25,3021.0,420.0,38676.0\n2020-04-26,2357.0,415.0,24113.0\n2020-04-27,2324.0,260.0,26678.0\n2020-04-28,1739.0,333.0,37554.0\n...\n```\n\nDiese Art der Datenspeicherung wird als *comma separated values* oder CSV bezeichnet.\n\n> **CSVs**: Eine durch Kommas getrennte Werte (CSV) Datei ist eine Textdatei, die ein Komma zur Trennung von Werten verwendet. Jede Zeile der Datei ist ein Datensatz. Jeder Datensatz besteht aus einem oder mehreren Feldern, die durch Kommas getrennt sind. Eine CSV-Datei speichert in der Regel tabellarische Daten (Zahlen und Text) im Klartext, in welchem Fall jede Zeile die gleiche Anzahl an Feldern haben wird.\n\nUm die Datei zu lesen, können wir die Methode `read_csv` von Pandas verwenden. Lassen Sie uns die Pandas-Bibliothek importieren. Es wird normalerweise mit dem Alias `pd` importiert.\n\nDaten aus der Datei werden gelesen und in einem `DataFrame`-Objekt gespeichert – einer der Kerndatenstrukturen in Pandas zum Speichern und Arbeiten mit Tabellendaten. Normalerweise verwenden wir das Suffix `_df` in den Variablennamen für Data Frame.\n\nFolgendes können wir anhand des Data Frames erkennen:\n\n- Die Datei enthält vier Tageszählungen für Covid-19 in Italien\n- Bei den gemeldeten Kennzahlen handelt es sich um neue Fälle, neue Todesfälle und neue Tests\n- Die Daten werden für 248 Tage bereitgestellt: vom 12. Dezember 2019 bis zum 3. September 2020\n\nBeachten Sie, dass es sich hierbei um offiziell gemeldete Zahlen handelt und die tatsächliche Zahl der Fälle und Todesfälle höher sein kann, da nicht alle Fälle diagnostiziert werden.\n\nMit der Methode `.info` können wir einige grundlegende Informationen zum Data Frame anzeigen.\n\nEs scheint, dass jede Spalte Werte eines bestimmten Datentyps enthält. Für die numerischen Spalten können Sie mit der Methode `.describe` einige statistische Informationen wie Mittelwert, Standardabweichung, Minimal-/Maximalwerte und Anzahl nicht leerer Werte anzeigen.\n\nDie Eigenschaft `columns` enthält die Liste der Spalten innerhalb des Data Frames.\n\nSie können die Anzahl der Zeilen und Spalten im Data Frame auch mit der Methode `.shape` abrufen\n\nHier ist eine Zusammenfassung der Funktionen und Methoden, die wir uns bisher angesehen haben:\n\n* `pd.read_csv` – Liest Daten aus einer CSV-Datei in ein Pandas-`DataFrame`-Objekt\n* `.info()` – Grundlegende Informationen zu Zeilen, Spalten und Datentypen anzeigen\n* `.describe()` – Statistische Informationen zu numerischen Spalten anzeigen\n* `.columns` – Ruft die Liste der Spaltennamen ab\n* `.shape` – Ermitteln Sie die Anzahl der Zeilen und Spalten als Tupel\n\n<a id='daten-data-frame'></a>\n\n## Abrufen von Daten aus einem Data Frame\n\nDas erste, was Sie möglicherweise tun möchten, ist, Daten aus diesem Data Frame abzurufen, z. B. die Zählungen eines bestimmten Tages oder der\nListe der Werte in einer bestimmten Spalte. Hierzu kann es hilfreich sein, die interne Darstellung von Daten in einem Data Frame zu verstehen. Konzeptionell können Sie sich einen Data Frame als ein Dictionary mit Listen vorstellen: Die Schlüssel sind Spaltennamen und die Werte sind Listen/Arrays, die Daten für die jeweiligen Spalten enthalten.\n\nDie Darstellung von Daten im oben genannten Format hat einige Vorteile:\n\n* Alle Werte in einer Spalte haben normalerweise denselben Werttyp, daher ist es effizienter, sie in einem einzelnen Array zu speichern.\n* Um die Werte für eine bestimmte Zeile abzurufen, müssen lediglich die Elemente an einem bestimmten Index aus jedem der Spaltenarrays extrahiert werden.\n* Die Darstellung ist kompakter (Spaltennamen werden nur einmal aufgezeichnet) im Vergleich zu anderen Formaten, bei denen Sie möglicherweise ein Dictionary für jede Datenzeile verwenden (siehe Beispiel unten).\n\nUnter Berücksichtigung der Dictionary-Listen-Analogie können wir nun erraten, wie wir möglicherweise Daten aus einem Data Frame abrufen können. Beispielsweise können wir mithilfe der Indexierungsnotation `[]` eine Liste von Werten aus einer bestimmten Spalte abrufen.\n\nJede Spalte wird durch eine Datenstruktur namens `Series` dargestellt, die im Wesentlichen ein Numpy-Array mit einigen zusätzlichen Methoden und Eigenschaften ist.\n\nGenau wie bei Arrays können Sie einen bestimmten Wert mit einer Reihe abrufen, indem Sie die Indexierungsnotation `[]` verwenden.\n\nPandas bietet auch die Methode `.at`, um direkt eine bestimmte Zeile und Spalte abzurufen.\n\nAnstatt die Indexierungsnotation `[]` zu verwenden, ermöglicht Pandas auch den Zugriff auf Spalten als Eigenschaften des Data Frames mithilfe der `.`-Notation. Diese Methode funktioniert jedoch nur für Spalten, deren Namen keine Leerzeichen oder Sonderzeichen enthalten.\n\nDarüber hinaus können Sie auch eine Liste von Spalten innerhalb der Indexierungsnotation `[]` übergeben, um nur mit den angegebenen Spalten auf eine Teilmenge des Data Frames zuzugreifen.\n\nBeachten Sie jedoch, dass das neue Dataframe `cases_df` einfach eine \"Ansicht\" des ursprünglichen Dataframes `covid_df` ist, d.h. sie verweisen beide auf die gleichen Daten im Arbeitsspeicher des Computers, und das Ändern von Werten in einem von ihnen ändert auch die entsprechenden Werte im anderen. Das Teilen von Daten zwischen Dataframes macht die Datenmanipulation in Pandas blitzschnell, und Sie müssen sich keine Sorgen über den Overhead des Kopierens von Tausenden oder Millionen von Zeilen machen, jedes Mal wenn Sie ein neues Dataframe erstellen möchten, indem Sie auf einem bestehenden operieren.\n\nManchmal benötigen Sie eine vollständige Kopie des Dataframes, in diesem Fall können Sie die `copy` Methode verwenden.\n\nDie Daten in `covid_df_copy` sind vollständig von `covid_df` getrennt und eine Änderung der Werte in einem von ihnen hat keine Auswirkungen auf das andere.\n\nUm auf eine bestimmte Datenzeile zuzugreifen, stellt Pandas die Methode `.loc` zur Verfügung.\n\nJede abgerufene Zeile ist auch ein `Series`-Objekt.\n\nUm die ersten oder letzten Datenzeilen anzuzeigen, können wir die Methoden `.head` und `.tail` verwenden.\n\nBeachten Sie oben, dass die ersten Werte in den Spalten `new_cases` und `new_deaths` zwar `0` sind, die entsprechenden Werte in der Spalte `new_tests` jedoch `NaN` sind. Das liegt daran, dass die CSV-Datei für bestimmte Daten keine Daten für die Spalte `new_tests` enthält (Sie können dies überprüfen, indem Sie in die Datei schauen). Es ist möglich, dass diese Werte fehlen oder unbekannt sind.\n\nDer Unterschied zwischen `0` und `NaN` ist subtil, aber wichtig. In diesem Datensatz wird dargestellt, dass an bestimmten Daten keine täglichen Testzahlen gemeldet wurden. Tatsächlich begann Italien am 19. April 2020 mit der Meldung täglicher Tests. Zu diesem Zeitpunkt waren bereits 935.310 Tests durchgeführt worden.\n\nMit der Methode `first_valid_index` einer Reihe können wir den ersten Index finden, der keinen `NaN`-Wert enthält.\n\nSchauen wir uns einige Zeilen vor und nach diesem Index an, um zu überprüfen, ob sich die Werte tatsächlich von `NaN` in tatsächliche Zahlen ändern. Wir können dies tun, indem wir einen Bereich an `loc` übergeben.\n\nDie Methode `.sample` kann verwendet werden, um eine zufällige Stichprobe von Zeilen aus dem Data Frame abzurufen.\n\nBeachten Sie, dass der ursprüngliche Index jeder Zeile erhalten geblieben ist, obwohl wir eine Zufallsstichprobe genommen haben. Dies ist eine wichtige und nützliche Eigenschaft von einem Data Frame – jeder Datenzeile ist ein Index zugeordnet.\n\nHier ist eine Zusammenfassung der Funktionen und Methoden, die wir in diesem Abschnitt betrachtet haben:\n\n- `covid_df['new_cases']` - Abrufen von Spalten als Serie mit einem Spaltennamen\n- `new_cases[243]` - Abrufen von Werten aus einer Serie mit einem Index\n- `covid_df.at[243, 'new_cases']` - Einzelnen Wert aus einem DataFrame abrufen\n- `covid_df.copy()` - Erstellen einer tiefen Kopie eines DataFrames\n- `covid_df.loc[243]` - Abrufen einer Reihe oder eines Bereichs von Reihen von Daten aus dem DataFrame\n- `head`, `tail` und `sample` - Abrufen mehrerer Zeilen von Daten aus dem Data Frame\n- `covid_df.new_tests.first_valid_index` - Finden des ersten nicht-leeren Index in einer Serie\n\n\n<a id='analysieren-data-frame'></a>\n\n## Analysieren von Daten aus dem Data Frame\n\nVersuchen wir, einige Fragen zu unseren Daten zu beantworten.\n\n**F: Wie hoch ist die Gesamtzahl der gemeldeten Fälle und Todesfälle im Zusammenhang mit Covid-19 in Italien?**\n\nÄhnlich wie Numpy-Arrays unterstützt eine Pandas-Serie die `sum`-Methode zur Beantwortung dieser Fragen.\n\n**F: Wie hoch ist die Gesamtsterblichkeitsrate (Verhältnis der gemeldeten Todesfälle zu den gemeldeten Fällen)?**\n\n**F: Wie viele Tests wurden insgesamt durchgeführt? Insgesamt wurden 935.310 Tests durchgeführt, bevor die täglichen Testzahlen gemeldet wurden.**\n\nWir können den ersten Nicht-NaN-Index mit `first_valid_index` überprüfen\n\n**F: Welcher Teil des Tests ergab ein positives Ergebnis?**\n\n<a id='zeilen-abfragen'></a>\n\n## Zeilen abfragen und sortieren\n\n### Grundlagen\n\nNehmen wir an, wir wollen uns nur die Tage ansehen, an denen mehr als 1000 Fälle gemeldet wurden. Wir können einen booleschen Ausdruck verwenden, um zu überprüfen, welche Zeilen dieses Kriterium erfüllen.\n\nDer boolesche Ausdruck gibt eine Reihe mit booleschen Werten `True` und `False` zurück. Diese Reihe kann verwendet werden, um nur die Zeilen herauszufiltern, in denen der Wert in der Reihe `True` ist. Das Ergebnis ist ein Data Frame mit einer Teilmenge der Zeilen des Originals.\n\nWir können dies prägnant in eine einzelne Zeile schreiben, indem wir den booleschen Ausdruck als Index an das Data Frame übergeben.\n\nDas Data Frame enthält 72 Zeilen, aber der Kürze halber werden bei Jupyter standardmäßig nur die ersten 5 und die letzten 5 Zeilen angezeigt. Um alle Zeilen anzuzeigen, können wir einige Anzeigeoptionen ändern.\n\nWir können auch komplexere Abfragen formulieren, die mehrere Spalten umfassen. Versuchen wir beispielsweise, die Tage zu ermitteln, an denen das Verhältnis der gemeldeten Fälle zu den durchgeführten Tests höher ist als die Gesamt-`positive_rate`.\n\nDas Ausführen von Operationen an mehreren Spalten führt zu einer neuen Serie.\n\nDarüber hinaus können wir diese Series verwenden, um dem Data Frame eine neue Spalte hinzuzufügen.\n\nBeachten Sie jedoch, dass es manchmal einige Tage dauert, bis die Ergebnisse eines Tests vorliegen, sodass wir die Anzahl neuer Fälle nicht wirklich mit der Anzahl der am selben Tag durchgeführten Tests vergleichen können. Jede Schlussfolgerung, die auf dieser Spalte `positive_rate` basiert, ist wahrscheinlich falsch. Es ist wichtig, auf subtile Beziehungen wie diese zu achten, die oft nicht in der CSV-Datei vermittelt werden und einen externen Kontext erfordern. Es ist immer eine gute Idee, die mit dem Datensatz gelieferte Dokumentation durchzulesen oder weitere Informationen anzufordern.\n\nEntfernen wir zunächst die Spalte `positive_rate` mit der `drop`-Methode.\n\nKönnen Sie herausfinden, wofür das `inplace`-Argument verwendet wird?\n\n### Zeilen anhand von Spaltenwerten sortieren\n\nDie Zeilen können mit `.sort_values` auch nach einer bestimmten Spalte sortiert werden. Sortieren wir, um die Tage mit der höchsten Anzahl an Fällen zu identifizieren, und verketten wir sie dann mit der `head`-Methode, um die 10 Tage mit den meisten Fällen zu erhalten.\n\nEs sieht so aus, als ob die letzten beiden Märzwochen die höchste Anzahl täglicher Fälle verzeichneten. Vergleichen wir dies mit den Tagen, an denen die meisten Todesfälle verzeichnet wurden.\n\nEs scheint, dass die täglichen Todesfälle etwa eine Woche nach dem Höhepunkt der täglichen Neuerkrankungen ihren Höhepunkt erreichen.\n\nSchauen wir uns auch die Tage mit den wenigsten Fällen an. Wir können davon ausgehen, dass wir in dieser Liste die ersten Tage des Jahres sehen werden.\n\nScheint, als ob die Zahl der neuen Fälle am 20. Juni bei `-148` lag, eine negative Zahl! Das hätten wir vielleicht nicht erwartet, aber das liegt in der Natur von Daten aus der realen Welt. Es könnte sich einfach um einen Dateneingabefehler handeln, oder es ist möglich, dass die Regierung eine Korrektur vorgenommen hat, um Fehlzählungen in der Vergangenheit zu berücksichtigen. Können Sie Nachrichtenartikel online durchforsten und herausfinden, warum die Zahl negativ war?\n\nSchauen wir uns einige Tage vor und nach dem 20. Juni an.\n\nWenn es sich tatsächlich um einen Dateneingabefehler handelte, können wir einen der folgenden Ansätze verwenden, um mit dem fehlenden oder fehlerhaften Wert umzugehen:\n1. Ersetzen Sie es durch `0`.\n2. Ersetzen Sie ihn durch den Durchschnitt der gesamten Spalte\n3. Ersetzen Sie es durch den Durchschnitt der Werte am vorherigen und nächsten Datum\n4. Verwerfen Sie die Zeile vollständig\n\nFür welchen Ansatz Sie sich entscheiden, erfordert einen gewissen Kontext zu den Daten und dem Problem. Da es sich in diesem Fall um nach Datum geordnete Daten handelt, können wir Ansatz 3 wählen.\n\nDie Methode `.at` kann verwendet werden, um einen bestimmten Wert innerhalb des Data Frames zu ändern.\n\nHier ist eine Zusammenfassung der Funktionen und Methoden, die wir in diesem Abschnitt betrachtet haben:\n\n- `covid_df.new_cases.sum()` - die Summe der Werte in einer Spalte oder Serie finden\n- `covid_df[covid_df.new_cases > 1000]` - Abfrage einer Teilmenge von Zeilen, die die gewählten Kriterien erfüllen, mit Hilfe von booleschen Ausdrücken\n- `df['pos_rate'] = df.new_cases/df.new_tests` - Hinzufügen neuer Spalten durch Kombination von Daten aus bestehenden Spalten\n- `covid_df.drop('positive_rate')` - Entfernen einer oder mehrerer Spalten aus dem DataFrame\n- `sort_values` - Sortieren der Zeilen eines DataFrame nach Spaltenwerten\n- `covid_df.at[172, 'new_cases'] = ...` - Ersetzen eines Wertes innerhalb des DataFrame\n\n<a id='datumsangaben-arbeiten'></a>\n\n## Mit Datumsangaben arbeiten\n\nWährend wir uns die Gesamtzahlen für Fälle, Tests, Positivraten usw. angesehen haben, wäre es auch nützlich, diese Zahlen auf monatlicher Basis zu untersuchen. Die Spalte `date` könnte hier nützlich sein, da Pandas viele Dienstprogramme zum Arbeiten mit Datumsangaben bereitstellt.\n\nDer Datentyp des Datums ist derzeit `object`, sodass Pandas nicht weiß, dass es sich bei dieser Spalte um ein Datum handelt. Wir können es mit der Methode `pd.to_datetime` in eine `datetime`-Spalte konvertieren.\n\nSie können sehen, dass es jetzt den Datentyp `datetime64` hat. Mit der Klasse `DatetimeIndex` ([Link](https://pandas.pydata.org/pandas-docs/version/0.23.4/generated/pandas.DatetimeIndex.html)) können wir jetzt verschiedene Teile der Daten in separate Spalten extrahieren.\n\nSehen wir uns die Gesamtkennzahlen für den Monat Mai an. Wir können die Zeilen für Mai abfragen, eine Teilmenge der Spalten auswählen, die wir aggregieren möchten, und die `sum`-Methode des Data Frames verwenden, um die Summe der Werte in jeder ausgewählten Spalte zu erhalten.\n\nDie oben genannten Operationen können auch in einer einzigen Anweisung kombiniert werden.\n\nHier ist ein weiteres Beispiel: Lassen Sie uns prüfen, ob die Anzahl der sonntags gemeldeten Fälle höher ist als die durchschnittliche Anzahl der täglich gemeldeten Fälle. Dieses Mal möchten wir mit der Methode `.mean` aggregieren.\n\nEs scheint, dass an Sonntagen mehr Fälle gemeldet wurden als an anderen Tagen.\n\nVersuchen Sie, mithilfe der folgenden Zellen weitere datumsbezogene Fragen zu den Daten zu stellen und zu beantworten.\n\n<a id='gruppierung-aggregation'></a>\n\n## Gruppierung und Aggregation\n\nAls nächsten Schritt möchten wir die Tagesdaten zusammenfassen und ein neues Data Frame mit Monatsdaten erstellen. Hier ist die `groupby`-Funktion nützlich. Zusammen mit einer Gruppierung müssen wir eine Option angeben, die Daten für jede Gruppe zu aggregieren.\n\nDas Ergebnis ist ein neues Data Frame, das eindeutige Werte aus der an `groupby` übergebenen Spalte als Index verwendet. Gruppierung und Aggregation sind eine wirklich leistungsstarke Methode, um Daten schrittweise in kleineren Data Frames zusammenzufassen.\n\nAnstatt nach der Summe zu aggregieren, können Sie auch nach anderen Kennzahlen wie dem Mittelwert aggregieren\n\nNeben der Gruppierung besteht eine weitere Form der Aggregation darin, für jede Zeile die laufende oder kumulative Summe der Fälle, Tests oder Todesfälle bis zum aktuellen Datum zu berechnen. Dies kann mit der `cumsum`-Methode erfolgen. Fügen wir drei neue Spalten hinzu: `total_cases`, `total_deaths` und `total_tests`.\n\nWir haben auch die anfängliche Testanzahl in `total_test` aufgenommen, um Tests zu berücksichtigen, die vor Beginn der täglichen Berichterstattung durchgeführt wurden.\n\nBeachten Sie, dass die `NaN`-Werte in der Spalte `total_tests` davon unberührt bleiben.\n\n<a id='mehrere-quellen'></a>\n\n## Daten aus mehreren Quellen zusammenführen\n\nUm andere Kennzahlen wie Tests pro Million, Fälle pro Million usw. zu ermitteln, benötigen wir weitere Informationen über das Land, nämlich. seine Bevölkerung. Laden wir eine weitere Datei `locations.csv` herunter, die gesundheitsbezogene Informationen für verschiedene Länder auf der ganzen Welt, einschließlich Italien, enthält.\n\nWir können diese Daten in unser bestehendes Data Frame einbinden, indem wir weitere Spalten hinzufügen. Um jedoch zwei Data Frames zusammenzuführen, benötigen wir mindestens eine gemeinsame Spalte. Fügen wir also eine Spalte `location` in das Data Frame `covid_df` ein, wobei alle Werte auf `\"Italy\"` eingestellt sind.\n\nWir können jetzt die Spalten von `locations_df` in `covid_df` hinzufügen, indem wir die Methode `.merge` verwenden.\n\nDie Standortdaten für Italien werden an jede Zeile in `covid_df` angehängt. Wenn das Data Frame `covid_df` Daten für mehrere Standorte enthalten würde, würden die standortersetzten Daten für das jeweilige Land für jede Zeile angehängt.\n\nWir können jetzt Kennzahlen wie Fälle pro Million, Todesfälle pro Million und Tests pro Million berechnen.\n\n<a id='dateien-schreiben'></a>\n\n## Daten zurück in Dateien schreiben\n\nNachdem Sie einige Analysen durchgeführt und neue Spalten zum Data Frame hinzugefügt haben, wäre es eine gute Idee, die Ergebnisse zurück in eine Datei zu schreiben, da die Daten sonst beim Herunterfahren des Jupyter-Notebooks verloren gehen. Bevor wir in eine Datei schreiben, erstellen wir zunächst ein Data Frame, das den spezifischen Spaltensatz enthält, den wir in die Datei schreiben möchten.\n\nUm die Daten aus dem Data Frame in eine Datei zu schreiben, können wir die Funktion `to_csv` verwenden.\n\nDie `to_csv` Funktion beinhaltet standardmäßig auch eine zusätzliche Spalte zum Speichern des Index des DataFrames. Wir geben `index=None` an, um dieses Verhalten abzuschalten. Du kannst nun überprüfen, dass die `results.csv` in dem data Ordner erstellt wurde und Daten aus dem DataFrame im CSV-Format enthält:\n\n```\ndate,new_cases,total_cases,new_deaths,total_deaths,new_tests,total_tests,cases_per_million,deaths_per_million,tests_per_million\n2020-02-27,78.0,400.0,1.0,12.0,,,6.61574439992122,0.1984723319976366,\n2020-02-28,250.0,650.0,5.0,17.0,,,10.750584649871982,0.28116913699665186,\n2020-02-29,238.0,888.0,4.0,21.0,,,14.686952567825108,0.34732658099586405,\n2020-03-01,240.0,1128.0,8.0,29.0,,,18.656399207777838,0.47964146899428844,\n2020-03-02,561.0,1689.0,6.0,35.0,,,27.93498072866735,0.5788776349931067,\n2020-03-03,347.0,2036.0,17.0,52.0,,,33.67413899559901,0.8600467719897585,\n...\n```\n\n<a id='bonus-plotten'></a>\n\n## Bonus: Grundlegendes Plotten mit Pandas\n\nWährend wir normalerweise eine Bibliothek wie `matplotlib` oder `seaborn`-Plotdiagramme mit einem Juptyer-Notizbuch verwenden, bieten Pandas-Data Frame und -Serien auch eine praktische `.plot`-Methode für schnelles und einfaches Plotten.\n\nLassen Sie uns ein Liniendiagramm zeichnen, das zeigt, wie die Nr. der täglichen Fälle variiert im Laufe der Zeit unter Verwendung der `plot`-Methode einer Pandas-Serie.\n\nWährend dieses Diagramm den Gesamttrend zeigt, ist es schwer zu sagen, wo der Höhepunkt auftrat, da es auf der X-Achse keine Daten gibt. Wir können die Spalte `date` als Index für das Data Frame verwenden, um dieses Problem zu beheben.\n\nDas ist richtig, der Index eines Data Frames muss nicht numerisch sein. Durch die Umwandlung des Datums in einen Index können wir auch die Daten für bestimmte Daten mithilfe von `.loc` abrufen\n\nLassen Sie uns die neuen Fälle und neuen Todesfälle pro Tag als Liniendiagramme darstellen.\n\nWir können auch die Gesamtzahl der Fälle mit der Gesamtzahl der Todesfälle vergleichen.\n\nSehen wir uns an, wie sich die Sterblichkeitsrate und die positiven Testraten im Laufe der Zeit ändern.\n\nLassen Sie uns abschließend einige monatliche Daten mithilfe eines Balkendiagramms darstellen, um den Trend auf einer höheren Ebene zu visualisieren.\n\n## Weiterführende Literatur\n\nSchauen Sie sich die folgenden Ressourcen an, um mehr über Pandas zu erfahren:\n\n* [Pandas-Übungen](https://github.com/guipsamora/pandas_exercises)\n* [Benutzerhandbuch für Pandas](https://pandas.pydata.org/docs/user_guide/index.html)\n* [Python for Data Analysis (Buch von Wes McKinney – Entwickler von Pandas)](https://wesmckinney.com/book/)\n","srcMarkdownNoYaml":"\n\n\n\n\nDieses Tutorial ist das sechste in einer Reihe zur Einführung in die Programmierung und Datenanalyse mithilfe der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\n\n\nDie folgenden Themen werden in diesem Tutorial behandelt:\n\n* [Eine CSV-Datei mit Pandas einlesen](#csv-pandas-einlesen)\n* [Abrufen von Daten aus einem Data Frame](#daten-data-frame)\n* [Analysieren von Daten aus Data Frame](#analysieren-data-frame)\n* [Zeilen abfragen und sortieren](#zeilen-abfragen)\n* [Mit Datumsangaben arbeiten](#datumsangaben-arbeiten)\n* [Gruppierung und Aggregation](#gruppierung-aggregation)\n* [Daten aus mehreren Quellen zusammenführen](#mehrere-quellen)\n* [Daten zurück in Dateien schreiben](#dateien-schreiben)\n* [Bonus: Grundlegendes Plotten mit Pandas](#bonus-plotten)\n\n\n\n<a id='csv-pandas-einlesen'></a>\n\n## Eine CSV-Datei mit Pandas einlesen\n\nPandas wird in der Regel verwendet, um mit tabellarischen Daten zu arbeiten (ähnlich wie die Daten, die in einer Tabelle gespeichert sind). Pandas bietet Hilfsfunktionen zum Einlesen von Daten aus verschiedenen Dateiformaten wie CSV, Excel-Tabellen, HTML-Tabellen, JSON, SQL und mehr. Lassen Sie uns die Datei `italy-covid-daywise.txt` herunterladen, die tageweise Covid-19-Daten für Italien im folgenden Format enthält:\n\n```\ndate,new_cases,new_deaths,new_tests\n2020-04-21,2256.0,454.0,28095.0\n2020-04-22,2729.0,534.0,44248.0\n2020-04-23,3370.0,437.0,37083.0\n2020-04-24,2646.0,464.0,95273.0\n2020-04-25,3021.0,420.0,38676.0\n2020-04-26,2357.0,415.0,24113.0\n2020-04-27,2324.0,260.0,26678.0\n2020-04-28,1739.0,333.0,37554.0\n...\n```\n\nDiese Art der Datenspeicherung wird als *comma separated values* oder CSV bezeichnet.\n\n> **CSVs**: Eine durch Kommas getrennte Werte (CSV) Datei ist eine Textdatei, die ein Komma zur Trennung von Werten verwendet. Jede Zeile der Datei ist ein Datensatz. Jeder Datensatz besteht aus einem oder mehreren Feldern, die durch Kommas getrennt sind. Eine CSV-Datei speichert in der Regel tabellarische Daten (Zahlen und Text) im Klartext, in welchem Fall jede Zeile die gleiche Anzahl an Feldern haben wird.\n\nUm die Datei zu lesen, können wir die Methode `read_csv` von Pandas verwenden. Lassen Sie uns die Pandas-Bibliothek importieren. Es wird normalerweise mit dem Alias `pd` importiert.\n\nDaten aus der Datei werden gelesen und in einem `DataFrame`-Objekt gespeichert – einer der Kerndatenstrukturen in Pandas zum Speichern und Arbeiten mit Tabellendaten. Normalerweise verwenden wir das Suffix `_df` in den Variablennamen für Data Frame.\n\nFolgendes können wir anhand des Data Frames erkennen:\n\n- Die Datei enthält vier Tageszählungen für Covid-19 in Italien\n- Bei den gemeldeten Kennzahlen handelt es sich um neue Fälle, neue Todesfälle und neue Tests\n- Die Daten werden für 248 Tage bereitgestellt: vom 12. Dezember 2019 bis zum 3. September 2020\n\nBeachten Sie, dass es sich hierbei um offiziell gemeldete Zahlen handelt und die tatsächliche Zahl der Fälle und Todesfälle höher sein kann, da nicht alle Fälle diagnostiziert werden.\n\nMit der Methode `.info` können wir einige grundlegende Informationen zum Data Frame anzeigen.\n\nEs scheint, dass jede Spalte Werte eines bestimmten Datentyps enthält. Für die numerischen Spalten können Sie mit der Methode `.describe` einige statistische Informationen wie Mittelwert, Standardabweichung, Minimal-/Maximalwerte und Anzahl nicht leerer Werte anzeigen.\n\nDie Eigenschaft `columns` enthält die Liste der Spalten innerhalb des Data Frames.\n\nSie können die Anzahl der Zeilen und Spalten im Data Frame auch mit der Methode `.shape` abrufen\n\nHier ist eine Zusammenfassung der Funktionen und Methoden, die wir uns bisher angesehen haben:\n\n* `pd.read_csv` – Liest Daten aus einer CSV-Datei in ein Pandas-`DataFrame`-Objekt\n* `.info()` – Grundlegende Informationen zu Zeilen, Spalten und Datentypen anzeigen\n* `.describe()` – Statistische Informationen zu numerischen Spalten anzeigen\n* `.columns` – Ruft die Liste der Spaltennamen ab\n* `.shape` – Ermitteln Sie die Anzahl der Zeilen und Spalten als Tupel\n\n<a id='daten-data-frame'></a>\n\n## Abrufen von Daten aus einem Data Frame\n\nDas erste, was Sie möglicherweise tun möchten, ist, Daten aus diesem Data Frame abzurufen, z. B. die Zählungen eines bestimmten Tages oder der\nListe der Werte in einer bestimmten Spalte. Hierzu kann es hilfreich sein, die interne Darstellung von Daten in einem Data Frame zu verstehen. Konzeptionell können Sie sich einen Data Frame als ein Dictionary mit Listen vorstellen: Die Schlüssel sind Spaltennamen und die Werte sind Listen/Arrays, die Daten für die jeweiligen Spalten enthalten.\n\nDie Darstellung von Daten im oben genannten Format hat einige Vorteile:\n\n* Alle Werte in einer Spalte haben normalerweise denselben Werttyp, daher ist es effizienter, sie in einem einzelnen Array zu speichern.\n* Um die Werte für eine bestimmte Zeile abzurufen, müssen lediglich die Elemente an einem bestimmten Index aus jedem der Spaltenarrays extrahiert werden.\n* Die Darstellung ist kompakter (Spaltennamen werden nur einmal aufgezeichnet) im Vergleich zu anderen Formaten, bei denen Sie möglicherweise ein Dictionary für jede Datenzeile verwenden (siehe Beispiel unten).\n\nUnter Berücksichtigung der Dictionary-Listen-Analogie können wir nun erraten, wie wir möglicherweise Daten aus einem Data Frame abrufen können. Beispielsweise können wir mithilfe der Indexierungsnotation `[]` eine Liste von Werten aus einer bestimmten Spalte abrufen.\n\nJede Spalte wird durch eine Datenstruktur namens `Series` dargestellt, die im Wesentlichen ein Numpy-Array mit einigen zusätzlichen Methoden und Eigenschaften ist.\n\nGenau wie bei Arrays können Sie einen bestimmten Wert mit einer Reihe abrufen, indem Sie die Indexierungsnotation `[]` verwenden.\n\nPandas bietet auch die Methode `.at`, um direkt eine bestimmte Zeile und Spalte abzurufen.\n\nAnstatt die Indexierungsnotation `[]` zu verwenden, ermöglicht Pandas auch den Zugriff auf Spalten als Eigenschaften des Data Frames mithilfe der `.`-Notation. Diese Methode funktioniert jedoch nur für Spalten, deren Namen keine Leerzeichen oder Sonderzeichen enthalten.\n\nDarüber hinaus können Sie auch eine Liste von Spalten innerhalb der Indexierungsnotation `[]` übergeben, um nur mit den angegebenen Spalten auf eine Teilmenge des Data Frames zuzugreifen.\n\nBeachten Sie jedoch, dass das neue Dataframe `cases_df` einfach eine \"Ansicht\" des ursprünglichen Dataframes `covid_df` ist, d.h. sie verweisen beide auf die gleichen Daten im Arbeitsspeicher des Computers, und das Ändern von Werten in einem von ihnen ändert auch die entsprechenden Werte im anderen. Das Teilen von Daten zwischen Dataframes macht die Datenmanipulation in Pandas blitzschnell, und Sie müssen sich keine Sorgen über den Overhead des Kopierens von Tausenden oder Millionen von Zeilen machen, jedes Mal wenn Sie ein neues Dataframe erstellen möchten, indem Sie auf einem bestehenden operieren.\n\nManchmal benötigen Sie eine vollständige Kopie des Dataframes, in diesem Fall können Sie die `copy` Methode verwenden.\n\nDie Daten in `covid_df_copy` sind vollständig von `covid_df` getrennt und eine Änderung der Werte in einem von ihnen hat keine Auswirkungen auf das andere.\n\nUm auf eine bestimmte Datenzeile zuzugreifen, stellt Pandas die Methode `.loc` zur Verfügung.\n\nJede abgerufene Zeile ist auch ein `Series`-Objekt.\n\nUm die ersten oder letzten Datenzeilen anzuzeigen, können wir die Methoden `.head` und `.tail` verwenden.\n\nBeachten Sie oben, dass die ersten Werte in den Spalten `new_cases` und `new_deaths` zwar `0` sind, die entsprechenden Werte in der Spalte `new_tests` jedoch `NaN` sind. Das liegt daran, dass die CSV-Datei für bestimmte Daten keine Daten für die Spalte `new_tests` enthält (Sie können dies überprüfen, indem Sie in die Datei schauen). Es ist möglich, dass diese Werte fehlen oder unbekannt sind.\n\nDer Unterschied zwischen `0` und `NaN` ist subtil, aber wichtig. In diesem Datensatz wird dargestellt, dass an bestimmten Daten keine täglichen Testzahlen gemeldet wurden. Tatsächlich begann Italien am 19. April 2020 mit der Meldung täglicher Tests. Zu diesem Zeitpunkt waren bereits 935.310 Tests durchgeführt worden.\n\nMit der Methode `first_valid_index` einer Reihe können wir den ersten Index finden, der keinen `NaN`-Wert enthält.\n\nSchauen wir uns einige Zeilen vor und nach diesem Index an, um zu überprüfen, ob sich die Werte tatsächlich von `NaN` in tatsächliche Zahlen ändern. Wir können dies tun, indem wir einen Bereich an `loc` übergeben.\n\nDie Methode `.sample` kann verwendet werden, um eine zufällige Stichprobe von Zeilen aus dem Data Frame abzurufen.\n\nBeachten Sie, dass der ursprüngliche Index jeder Zeile erhalten geblieben ist, obwohl wir eine Zufallsstichprobe genommen haben. Dies ist eine wichtige und nützliche Eigenschaft von einem Data Frame – jeder Datenzeile ist ein Index zugeordnet.\n\nHier ist eine Zusammenfassung der Funktionen und Methoden, die wir in diesem Abschnitt betrachtet haben:\n\n- `covid_df['new_cases']` - Abrufen von Spalten als Serie mit einem Spaltennamen\n- `new_cases[243]` - Abrufen von Werten aus einer Serie mit einem Index\n- `covid_df.at[243, 'new_cases']` - Einzelnen Wert aus einem DataFrame abrufen\n- `covid_df.copy()` - Erstellen einer tiefen Kopie eines DataFrames\n- `covid_df.loc[243]` - Abrufen einer Reihe oder eines Bereichs von Reihen von Daten aus dem DataFrame\n- `head`, `tail` und `sample` - Abrufen mehrerer Zeilen von Daten aus dem Data Frame\n- `covid_df.new_tests.first_valid_index` - Finden des ersten nicht-leeren Index in einer Serie\n\n\n<a id='analysieren-data-frame'></a>\n\n## Analysieren von Daten aus dem Data Frame\n\nVersuchen wir, einige Fragen zu unseren Daten zu beantworten.\n\n**F: Wie hoch ist die Gesamtzahl der gemeldeten Fälle und Todesfälle im Zusammenhang mit Covid-19 in Italien?**\n\nÄhnlich wie Numpy-Arrays unterstützt eine Pandas-Serie die `sum`-Methode zur Beantwortung dieser Fragen.\n\n**F: Wie hoch ist die Gesamtsterblichkeitsrate (Verhältnis der gemeldeten Todesfälle zu den gemeldeten Fällen)?**\n\n**F: Wie viele Tests wurden insgesamt durchgeführt? Insgesamt wurden 935.310 Tests durchgeführt, bevor die täglichen Testzahlen gemeldet wurden.**\n\nWir können den ersten Nicht-NaN-Index mit `first_valid_index` überprüfen\n\n**F: Welcher Teil des Tests ergab ein positives Ergebnis?**\n\n<a id='zeilen-abfragen'></a>\n\n## Zeilen abfragen und sortieren\n\n### Grundlagen\n\nNehmen wir an, wir wollen uns nur die Tage ansehen, an denen mehr als 1000 Fälle gemeldet wurden. Wir können einen booleschen Ausdruck verwenden, um zu überprüfen, welche Zeilen dieses Kriterium erfüllen.\n\nDer boolesche Ausdruck gibt eine Reihe mit booleschen Werten `True` und `False` zurück. Diese Reihe kann verwendet werden, um nur die Zeilen herauszufiltern, in denen der Wert in der Reihe `True` ist. Das Ergebnis ist ein Data Frame mit einer Teilmenge der Zeilen des Originals.\n\nWir können dies prägnant in eine einzelne Zeile schreiben, indem wir den booleschen Ausdruck als Index an das Data Frame übergeben.\n\nDas Data Frame enthält 72 Zeilen, aber der Kürze halber werden bei Jupyter standardmäßig nur die ersten 5 und die letzten 5 Zeilen angezeigt. Um alle Zeilen anzuzeigen, können wir einige Anzeigeoptionen ändern.\n\nWir können auch komplexere Abfragen formulieren, die mehrere Spalten umfassen. Versuchen wir beispielsweise, die Tage zu ermitteln, an denen das Verhältnis der gemeldeten Fälle zu den durchgeführten Tests höher ist als die Gesamt-`positive_rate`.\n\nDas Ausführen von Operationen an mehreren Spalten führt zu einer neuen Serie.\n\nDarüber hinaus können wir diese Series verwenden, um dem Data Frame eine neue Spalte hinzuzufügen.\n\nBeachten Sie jedoch, dass es manchmal einige Tage dauert, bis die Ergebnisse eines Tests vorliegen, sodass wir die Anzahl neuer Fälle nicht wirklich mit der Anzahl der am selben Tag durchgeführten Tests vergleichen können. Jede Schlussfolgerung, die auf dieser Spalte `positive_rate` basiert, ist wahrscheinlich falsch. Es ist wichtig, auf subtile Beziehungen wie diese zu achten, die oft nicht in der CSV-Datei vermittelt werden und einen externen Kontext erfordern. Es ist immer eine gute Idee, die mit dem Datensatz gelieferte Dokumentation durchzulesen oder weitere Informationen anzufordern.\n\nEntfernen wir zunächst die Spalte `positive_rate` mit der `drop`-Methode.\n\nKönnen Sie herausfinden, wofür das `inplace`-Argument verwendet wird?\n\n### Zeilen anhand von Spaltenwerten sortieren\n\nDie Zeilen können mit `.sort_values` auch nach einer bestimmten Spalte sortiert werden. Sortieren wir, um die Tage mit der höchsten Anzahl an Fällen zu identifizieren, und verketten wir sie dann mit der `head`-Methode, um die 10 Tage mit den meisten Fällen zu erhalten.\n\nEs sieht so aus, als ob die letzten beiden Märzwochen die höchste Anzahl täglicher Fälle verzeichneten. Vergleichen wir dies mit den Tagen, an denen die meisten Todesfälle verzeichnet wurden.\n\nEs scheint, dass die täglichen Todesfälle etwa eine Woche nach dem Höhepunkt der täglichen Neuerkrankungen ihren Höhepunkt erreichen.\n\nSchauen wir uns auch die Tage mit den wenigsten Fällen an. Wir können davon ausgehen, dass wir in dieser Liste die ersten Tage des Jahres sehen werden.\n\nScheint, als ob die Zahl der neuen Fälle am 20. Juni bei `-148` lag, eine negative Zahl! Das hätten wir vielleicht nicht erwartet, aber das liegt in der Natur von Daten aus der realen Welt. Es könnte sich einfach um einen Dateneingabefehler handeln, oder es ist möglich, dass die Regierung eine Korrektur vorgenommen hat, um Fehlzählungen in der Vergangenheit zu berücksichtigen. Können Sie Nachrichtenartikel online durchforsten und herausfinden, warum die Zahl negativ war?\n\nSchauen wir uns einige Tage vor und nach dem 20. Juni an.\n\nWenn es sich tatsächlich um einen Dateneingabefehler handelte, können wir einen der folgenden Ansätze verwenden, um mit dem fehlenden oder fehlerhaften Wert umzugehen:\n1. Ersetzen Sie es durch `0`.\n2. Ersetzen Sie ihn durch den Durchschnitt der gesamten Spalte\n3. Ersetzen Sie es durch den Durchschnitt der Werte am vorherigen und nächsten Datum\n4. Verwerfen Sie die Zeile vollständig\n\nFür welchen Ansatz Sie sich entscheiden, erfordert einen gewissen Kontext zu den Daten und dem Problem. Da es sich in diesem Fall um nach Datum geordnete Daten handelt, können wir Ansatz 3 wählen.\n\nDie Methode `.at` kann verwendet werden, um einen bestimmten Wert innerhalb des Data Frames zu ändern.\n\nHier ist eine Zusammenfassung der Funktionen und Methoden, die wir in diesem Abschnitt betrachtet haben:\n\n- `covid_df.new_cases.sum()` - die Summe der Werte in einer Spalte oder Serie finden\n- `covid_df[covid_df.new_cases > 1000]` - Abfrage einer Teilmenge von Zeilen, die die gewählten Kriterien erfüllen, mit Hilfe von booleschen Ausdrücken\n- `df['pos_rate'] = df.new_cases/df.new_tests` - Hinzufügen neuer Spalten durch Kombination von Daten aus bestehenden Spalten\n- `covid_df.drop('positive_rate')` - Entfernen einer oder mehrerer Spalten aus dem DataFrame\n- `sort_values` - Sortieren der Zeilen eines DataFrame nach Spaltenwerten\n- `covid_df.at[172, 'new_cases'] = ...` - Ersetzen eines Wertes innerhalb des DataFrame\n\n<a id='datumsangaben-arbeiten'></a>\n\n## Mit Datumsangaben arbeiten\n\nWährend wir uns die Gesamtzahlen für Fälle, Tests, Positivraten usw. angesehen haben, wäre es auch nützlich, diese Zahlen auf monatlicher Basis zu untersuchen. Die Spalte `date` könnte hier nützlich sein, da Pandas viele Dienstprogramme zum Arbeiten mit Datumsangaben bereitstellt.\n\nDer Datentyp des Datums ist derzeit `object`, sodass Pandas nicht weiß, dass es sich bei dieser Spalte um ein Datum handelt. Wir können es mit der Methode `pd.to_datetime` in eine `datetime`-Spalte konvertieren.\n\nSie können sehen, dass es jetzt den Datentyp `datetime64` hat. Mit der Klasse `DatetimeIndex` ([Link](https://pandas.pydata.org/pandas-docs/version/0.23.4/generated/pandas.DatetimeIndex.html)) können wir jetzt verschiedene Teile der Daten in separate Spalten extrahieren.\n\nSehen wir uns die Gesamtkennzahlen für den Monat Mai an. Wir können die Zeilen für Mai abfragen, eine Teilmenge der Spalten auswählen, die wir aggregieren möchten, und die `sum`-Methode des Data Frames verwenden, um die Summe der Werte in jeder ausgewählten Spalte zu erhalten.\n\nDie oben genannten Operationen können auch in einer einzigen Anweisung kombiniert werden.\n\nHier ist ein weiteres Beispiel: Lassen Sie uns prüfen, ob die Anzahl der sonntags gemeldeten Fälle höher ist als die durchschnittliche Anzahl der täglich gemeldeten Fälle. Dieses Mal möchten wir mit der Methode `.mean` aggregieren.\n\nEs scheint, dass an Sonntagen mehr Fälle gemeldet wurden als an anderen Tagen.\n\nVersuchen Sie, mithilfe der folgenden Zellen weitere datumsbezogene Fragen zu den Daten zu stellen und zu beantworten.\n\n<a id='gruppierung-aggregation'></a>\n\n## Gruppierung und Aggregation\n\nAls nächsten Schritt möchten wir die Tagesdaten zusammenfassen und ein neues Data Frame mit Monatsdaten erstellen. Hier ist die `groupby`-Funktion nützlich. Zusammen mit einer Gruppierung müssen wir eine Option angeben, die Daten für jede Gruppe zu aggregieren.\n\nDas Ergebnis ist ein neues Data Frame, das eindeutige Werte aus der an `groupby` übergebenen Spalte als Index verwendet. Gruppierung und Aggregation sind eine wirklich leistungsstarke Methode, um Daten schrittweise in kleineren Data Frames zusammenzufassen.\n\nAnstatt nach der Summe zu aggregieren, können Sie auch nach anderen Kennzahlen wie dem Mittelwert aggregieren\n\nNeben der Gruppierung besteht eine weitere Form der Aggregation darin, für jede Zeile die laufende oder kumulative Summe der Fälle, Tests oder Todesfälle bis zum aktuellen Datum zu berechnen. Dies kann mit der `cumsum`-Methode erfolgen. Fügen wir drei neue Spalten hinzu: `total_cases`, `total_deaths` und `total_tests`.\n\nWir haben auch die anfängliche Testanzahl in `total_test` aufgenommen, um Tests zu berücksichtigen, die vor Beginn der täglichen Berichterstattung durchgeführt wurden.\n\nBeachten Sie, dass die `NaN`-Werte in der Spalte `total_tests` davon unberührt bleiben.\n\n<a id='mehrere-quellen'></a>\n\n## Daten aus mehreren Quellen zusammenführen\n\nUm andere Kennzahlen wie Tests pro Million, Fälle pro Million usw. zu ermitteln, benötigen wir weitere Informationen über das Land, nämlich. seine Bevölkerung. Laden wir eine weitere Datei `locations.csv` herunter, die gesundheitsbezogene Informationen für verschiedene Länder auf der ganzen Welt, einschließlich Italien, enthält.\n\nWir können diese Daten in unser bestehendes Data Frame einbinden, indem wir weitere Spalten hinzufügen. Um jedoch zwei Data Frames zusammenzuführen, benötigen wir mindestens eine gemeinsame Spalte. Fügen wir also eine Spalte `location` in das Data Frame `covid_df` ein, wobei alle Werte auf `\"Italy\"` eingestellt sind.\n\nWir können jetzt die Spalten von `locations_df` in `covid_df` hinzufügen, indem wir die Methode `.merge` verwenden.\n\nDie Standortdaten für Italien werden an jede Zeile in `covid_df` angehängt. Wenn das Data Frame `covid_df` Daten für mehrere Standorte enthalten würde, würden die standortersetzten Daten für das jeweilige Land für jede Zeile angehängt.\n\nWir können jetzt Kennzahlen wie Fälle pro Million, Todesfälle pro Million und Tests pro Million berechnen.\n\n<a id='dateien-schreiben'></a>\n\n## Daten zurück in Dateien schreiben\n\nNachdem Sie einige Analysen durchgeführt und neue Spalten zum Data Frame hinzugefügt haben, wäre es eine gute Idee, die Ergebnisse zurück in eine Datei zu schreiben, da die Daten sonst beim Herunterfahren des Jupyter-Notebooks verloren gehen. Bevor wir in eine Datei schreiben, erstellen wir zunächst ein Data Frame, das den spezifischen Spaltensatz enthält, den wir in die Datei schreiben möchten.\n\nUm die Daten aus dem Data Frame in eine Datei zu schreiben, können wir die Funktion `to_csv` verwenden.\n\nDie `to_csv` Funktion beinhaltet standardmäßig auch eine zusätzliche Spalte zum Speichern des Index des DataFrames. Wir geben `index=None` an, um dieses Verhalten abzuschalten. Du kannst nun überprüfen, dass die `results.csv` in dem data Ordner erstellt wurde und Daten aus dem DataFrame im CSV-Format enthält:\n\n```\ndate,new_cases,total_cases,new_deaths,total_deaths,new_tests,total_tests,cases_per_million,deaths_per_million,tests_per_million\n2020-02-27,78.0,400.0,1.0,12.0,,,6.61574439992122,0.1984723319976366,\n2020-02-28,250.0,650.0,5.0,17.0,,,10.750584649871982,0.28116913699665186,\n2020-02-29,238.0,888.0,4.0,21.0,,,14.686952567825108,0.34732658099586405,\n2020-03-01,240.0,1128.0,8.0,29.0,,,18.656399207777838,0.47964146899428844,\n2020-03-02,561.0,1689.0,6.0,35.0,,,27.93498072866735,0.5788776349931067,\n2020-03-03,347.0,2036.0,17.0,52.0,,,33.67413899559901,0.8600467719897585,\n...\n```\n\n<a id='bonus-plotten'></a>\n\n## Bonus: Grundlegendes Plotten mit Pandas\n\nWährend wir normalerweise eine Bibliothek wie `matplotlib` oder `seaborn`-Plotdiagramme mit einem Juptyer-Notizbuch verwenden, bieten Pandas-Data Frame und -Serien auch eine praktische `.plot`-Methode für schnelles und einfaches Plotten.\n\nLassen Sie uns ein Liniendiagramm zeichnen, das zeigt, wie die Nr. der täglichen Fälle variiert im Laufe der Zeit unter Verwendung der `plot`-Methode einer Pandas-Serie.\n\nWährend dieses Diagramm den Gesamttrend zeigt, ist es schwer zu sagen, wo der Höhepunkt auftrat, da es auf der X-Achse keine Daten gibt. Wir können die Spalte `date` als Index für das Data Frame verwenden, um dieses Problem zu beheben.\n\nDas ist richtig, der Index eines Data Frames muss nicht numerisch sein. Durch die Umwandlung des Datums in einen Index können wir auch die Daten für bestimmte Daten mithilfe von `.loc` abrufen\n\nLassen Sie uns die neuen Fälle und neuen Todesfälle pro Tag als Liniendiagramme darstellen.\n\nWir können auch die Gesamtzahl der Fälle mit der Gesamtzahl der Todesfälle vergleichen.\n\nSehen wir uns an, wie sich die Sterblichkeitsrate und die positiven Testraten im Laufe der Zeit ändern.\n\nLassen Sie uns abschließend einige monatliche Daten mithilfe eines Balkendiagramms darstellen, um den Trend auf einer höheren Ebene zu visualisieren.\n\n## Weiterführende Literatur\n\nSchauen Sie sich die folgenden Ressourcen an, um mehr über Pandas zu erfahren:\n\n* [Pandas-Übungen](https://github.com/guipsamora/pandas_exercises)\n* [Benutzerhandbuch für Pandas](https://pandas.pydata.org/docs/user_guide/index.html)\n* [Python for Data Analysis (Buch von Wes McKinney – Entwickler von Pandas)](https://wesmckinney.com/book/)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"css":["styles.css"],"output-file":"kapitel6.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":{"light":"flatly","dark":"darkly"},"code-copy":true,"smooth-scroll":true,"title":"Analyse tabellarischer Daten mit Python und Pandas"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
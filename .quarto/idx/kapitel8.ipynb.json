{"title":"Explorative Datenanalyse mit Python – Eine Fallstudie","markdown":{"yaml":{"title":"Explorative Datenanalyse mit Python – Eine Fallstudie"},"headingText":"Einführung","containsRefs":false,"markdown":"\n\n\n\n\n*Analyse der Antworten aus der jährlichen Entwicklerumfrage 2020 von Stack Overflow*\n\nDieses Tutorial ist das achte (und letzte) in einer Reihe zur Einführung in die Programmierung und Datenanalyse mit der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\n\nDie folgenden Themen werden in diesem Tutorial behandelt:\n\n* [Datenvorbereitung und -aufbereitung](#datenvorbereitung)\n* [Explorative Analyse und Visualisierung](#visualisierung)\n* [Fragen stellen und beantworten](#fragen)\n* [Schlussfolgerungen und Ergebnisse](#ergebnisse)\n\n\n\n\nFür unsere Analyse verwenden wir den StackOverflow-Entwicklerumfragedatensatz. Dies ist eine jährliche Umfrage, die von StackOverflow durchgeführt wird. Die Rohdaten und Ergebnisse finden Sie [hier](https://insights.stackoverflow.com/survey).\n\nEs gibt mehrere Möglichkeiten, den Datensatz in Jupyter zu importieren:\n\n- Laden Sie die CSV-Datei manuell herunter und laden Sie sie über die Jupyter-GUI hoch\n- Verwenden Sie die Funktion „urlretrieve“ aus `urllib.request`, um CSV-Dateien direkt von einer Roh-URL herunterzuladen\n\nWir nutzen die bereits heruntergeladene Datei, die sich im `data` Ordner befindet.\n\nSie können die heruntergeladenen Dateien mit der Menüoption `Datei > Öffnen` in Jupyter durchsuchen. Es scheint, als ob der Datensatz drei Dateien enthält:\n\n- `README.txt` – enthält Informationen zum Datensatz\n- `survey_results_schema.csv` – enthält die Liste der Fragen (und Kurzcodes für jede Frage)\n- `survey_results_public.csv` – die vollständige Liste der Antworten auf die Fragen\n\nLaden wir die CSV-Dateien mithilfe der Pandas-Bibliothek. Wir verwenden den Namen `survey_raw_df` für das Data Frame, um anzuzeigen, dass es sich um unverarbeitete Daten handelt, die wir möglicherweise bereinigen, filtern und ändern, um ein Data Frame vorzubereiten, der für die Analyse bereit ist.\n\nDer Datensatz enthält über 64.000 Antworten auf 60 Fragen (obwohl viele Fragen optional sind). Die Antworten wurden anonymisiert und es stehen uns keine personenbezogenen Daten zur Verfügung – obwohl jedem Befragten eine zufällige Befragten-ID zugewiesen wurde.\n\nSehen wir uns die Liste der Spalten im Data Frame an.\n\nEs scheint, dass Kurzcodes für Fragen als Spaltennamen verwendet werden.\n\nWir können auf die Schemadatei verweisen, um den vollständigen Text jeder Frage anzuzeigen. Die Schemadatei enthält nur zwei Spalten: `Column` und `QuestionText`, sodass wir sie als Pandas-Serie mit `Column` als Index und `QuestionText` als Wert laden können.\n\nWir können jetzt `schema_raw` verwenden, um den vollständigen Fragentext für jede Spalte in `survey_raw_df` abzurufen.\n\nWir haben den Datensatz nun geladen und können mit dem nächsten Schritt der Vorverarbeitung und Bereinigung der Daten für unsere Analyse fortfahren.\n\n<a id='datenvorbereitung'></a>\n\n## Datenvorbereitung und -aufbereitung\n\nObwohl die Umfrageantworten eine Fülle von Informationen enthalten, beschränken wir unsere Analyse auf die folgenden Bereiche:\n\n- Demografische Daten der Umfrageteilnehmer und der globalen Programmiergemeinschaft\n- Verteilung von Programmierkenntnissen, Erfahrungen und Vorlieben\n- Beschäftigungsbezogene Informationen, Vorlieben und Meinungen\n\nWählen wir eine Teilmenge von Spalten mit den relevanten Daten für unsere Analyse aus.\n\nExtrahieren wir eine Kopie der Daten aus diesen Spalten in einem neuen Data Frame `survey_df`, das wir weiter ändern können, ohne das ursprüngliche Data Frame zu beeinträchtigen.\n\nSehen wir uns einige grundlegende Informationen zum Data Frame an.\n\nDie meisten Spalten haben den Datentyp `Objekt`, entweder weil sie Werte unterschiedlichen Typs enthalten, oder weil sie leere Werte enthalten, die mit `NaN` dargestellt werden. Es scheint, dass jede Spalte einige leere Werte enthält, da die Nicht-Null-Anzahl für jede Spalte niedriger ist als die Gesamtzahl der Zeilen (64461). Wir müssen mit leeren Werten umgehen und den Datentyp für jede Spalte von Fall zu Fall manuell anpassen.\n\nNur zwei der Spalten wurden als numerische Spalten (`Age` und `WorkWeekHrs`) erkannt, obwohl es einige andere Spalten gibt, die überwiegend numerische Werte enthalten. Um unsere Analyse zu vereinfachen, konvertieren wir einige andere Spalten in numerische Datentypen und ignorieren dabei alle nicht numerischen Werte (sie werden in NaNs konvertiert).\n\nSehen wir uns nun einige grundlegende Statistiken zu den numerischen Spalten an.\n\nEs scheint ein Problem mit der Altersspalte zu geben, da der Mindestwert 1 und der Höchstwert 279 beträgt. Dies ist ein häufiges Problem bei Umfragen: Antworten können aufgrund versehentlicher oder absichtlicher Fehler bei der Beantwortung ungültige Werte enthalten. Eine einfache Lösung besteht darin, die Zeilen, in denen der Wert in der Altersspalte höher als 100 Jahre oder niedriger als 10 Jahre ist, als ungültige Umfrageantworten zu ignorieren. Dies kann mit der `.drop`-Methode erfolgen, [wie hier erklärt](https://www.geeksforgeeks.org/drop-rows-from-the-dataframe-based-on-certain-condition-applied-on-a-column/).\n\nDas Gleiche gilt für `WorkWeekHrs`. Ignorieren wir Einträge, bei denen der Wert für die Spalte höher als 140 Stunden ist. (~20 Stunden pro Tag).\n\nIn der Spalte `Gender` können auch mehrere Optionen ausgewählt werden. Um unsere Analyse zu vereinfachen, entfernen wir jedoch Werte, die mehr als eine Option enthalten.\n\nWir haben den Datensatz nun bereinigt und für die Analyse vorbereitet. Werfen wir einen Blick auf beispielhafte Zeilen aus dem Data Frame.\n\n<a id='visualisierung'></a>\n\n## Explorative Analyse und Visualisierung\n\nBevor wir interessante Fragen zu den Umfrageantworten stellen können, wäre es hilfreich zu verstehen, wie die demografischen Merkmale, d. h. Land, Alter, Geschlecht, Bildungsniveau, Beschäftigungsniveau usw., der Befragten aussehen. Es ist wichtig, diese Variablen zu untersuchen, um zu verstehen, wie repräsentativ die Umfrage für die weltweite Programmiergemeinschaft ist, da eine Umfrage dieser Größenordnung im Allgemeinen zu einem gewissen [selection bias](https://en.wikipedia.org/wiki/Selection_bias) führt.\n\nBeginnen wir mit dem Import von `matplotlib.pyplot` and `seaborn`.\n\n### Land\n\nSchauen wir uns die Anzahl der Länder an, aus denen in der Umfrage Antworten vorliegen, und zeichnen wir die 10 Länder mit der höchsten Anzahl an Antworten auf.\n\nMit der Methode `value_counts` können wir die Länder mit der höchsten Anzahl an Befragten identifizieren.\n\nWir können diese Informationen mithilfe eines Balkendiagramms visualisieren.\n\nEs scheint, dass überproportional viele Befragte aus den USA und Indien stammen – was zu erwarten ist, da diese Länder (abgesehen von China) die höchste Bevölkerungszahl haben und die Umfrage auf Englisch erfolgt, der von Fachleuten in China allgemein verwendeten Sprache USA, Indien und Großbritannien. Wir können bereits erkennen, dass die Umfrage möglicherweise nicht repräsentativ für die gesamte Programmiergemeinschaft ist – insbesondere für nicht englischsprachige Länder.\n\n**Übung**:\nVersuchen Sie, den Prozentsatz der Antworten aus englischsprachigen im Vergleich zu nicht englischsprachigen Ländern zu ermitteln. Sie können [diese Liste der in verschiedenen Ländern gesprochenen Sprachen](https://github.com/JovianML/opendatasets/blob/master/data/countries-linguals-spoken/countries-linguals.csv) verwenden.\n\n### Alter\n\nDie Verteilung des Alters der Befragten ist ein weiterer wichtiger zu betrachtender Faktor, den wir mithilfe eines Histogramms visualisieren können.\n\nEs scheint, dass ein großer Prozentsatz der Befragten im Alter zwischen 20 und 45 Jahren ist, was einigermaßen repräsentativ für die Programmiergemeinschaft im Allgemeinen ist, da viele junge Menschen in den letzten 20 Jahren Computer als Studienfach oder Beruf gewählt haben.\n\n**Übung**: Möglicherweise möchten Sie die Antworten nach Alter (oder Altersgruppe) herausfiltern, wenn Sie die Ergebnisse der Umfrage für verschiedene Altersgruppen analysieren und vergleichen möchten. Erstellen Sie eine neue Spalte mit dem Namen `AgeGroup`, die Werte wie `Less than 10 years`, `10-18 years`, `18-30 years`, `30-45 years`, `45-60 years`, `Older than 60 years` und wiederholen Sie die Analyse im Rest dieses Notizbuchs für jede Altersgruppe.\n\n### Geschlecht\n\nSchauen wir uns die Verteilung der Antworten für das Geschlecht an. Es ist eine bekannte Tatsache, dass Frauen und nicht-binäre Geschlechter in der Programmiergemeinschaft unterrepräsentiert sind, sodass wir hier mit einer ungleichen Verteilung rechnen können.\n\nEin Kreisdiagramm wäre eine gute Möglichkeit, die Verteilung zu visualisieren.\n\nNur etwa 8 % der Umfrageteilnehmer, die die Frage beantwortet haben, identifizieren sich als Frauen oder nicht-binär. Diese Zahl ist niedriger als der Gesamtanteil von Frauen und nicht-binären Geschlechtern in der Programmiergemeinschaft, der auf etwa 12 % geschätzt wird.\n\n**Übung**: Es wäre interessant, die Antworten und Präferenzen der Umfrage nach Geschlechtern zu vergleichen. Wir empfehlen Ihnen, diese Analyse mit diesen Aufschlüsselungen zu wiederholen. Wie unterscheiden sich die relativen Bildungsniveaus zwischen den Geschlechtern? Wie unterscheiden sich die Gehälter? Sie finden diese Analyse möglicherweise auf der Website [Gender Divide in Data Science](https://medium.com/datadriveninvestor/exploratory-data-analysis-eda-understanding-the-gender-divide-in-data-science-roles-9faa5da44f5b) nützlich.\n\n### Bildungsniveau\n\nEine formale Ausbildung in Informatik wird oft als wichtige Voraussetzung für die Karriere als Programmierer angesehen. Mal sehen, ob dies tatsächlich der Fall ist, insbesondere da online viele kostenlose Ressourcen und Tutorials zum Erlernen des Programmierens verfügbar sind. Wir verwenden ein horizontales Balkendiagramm, um das Bildungsniveau der Befragten zu vergleichen.\n\nEs scheint, dass deutlich mehr als die Hälfte der Befragten einen Bachelor- oder Master-Abschluss haben, die meisten Programmierer scheinen also definitiv über eine Hochschulausbildung zu verfügen, obwohl aus dieser Grafik allein nicht klar hervorgeht, ob sie einen Abschluss in Informatik haben.\n\n**Übungen**: Das Diagramm zeigt derzeit die Anzahl der Befragten für jede Option. Können Sie es ändern, um stattdessen den Prozentsatz anzuzeigen? Können Sie die Grafik außerdem aufschlüsseln, um die Prozentsätze für jeden Grad für Männer und Frauen zu vergleichen?\n\nLassen Sie uns auch die Bachelor-Studiengänge grafisch darstellen, aber dieses Mal werden wir die Zahlen in Prozentsätze umwandeln und nach Prozentwerten sortieren, um die Reihenfolge besser visualisieren zu können.\n\nEs stellt sich heraus, dass 40 % der Programmierer mit Hochschulabschluss ein anderes Studienfach als Informatik haben – was sehr ermutigend ist. Dies scheint darauf hinzudeuten, dass eine Hochschulausbildung zwar im Allgemeinen hilfreich ist, Sie jedoch kein Hauptfach in Informatik absolvieren müssen, um ein erfolgreicher Programmierer zu werden.\n\n**Übungen**: Analysieren Sie die Ergebnisse der Spalte `NEWEdImpt` für Befragte mit einem Hochschulabschluss im Vergleich zu denen ohne Hochschulabschluss. Bemerken Sie einen Meinungsunterschied?\n\n### Arbeitsverhältnis\n\nProgrammierer entscheiden sich häufig für freiberufliche Arbeit oder Vertragsarbeit, daher wäre es interessant, die Aufteilung zwischen Vollzeit-, Teilzeit- und freiberuflicher Arbeit zu vergleichen. Lassen Sie uns die Daten aus der Spalte `Employment` visualisieren.\n\nEs scheint, dass knapp 10 % der Befragten in Teilzeit oder als Freiberufler beschäftigt sind.\n\n**Übung**: Fügen Sie eine neue Spalte `EmploymentType` hinzu, die die Werte `Enthusiast` (Student oder nicht angestellt, aber auf der Suche nach Arbeit), `Professional` (vollzeitbeschäftigt, Teilzeit oder freiberuflich tätig) und enthält `Other` (nicht angestellt oder im Ruhestand). Zeigen Sie für jede der folgenden Grafiken einen Vergleich zwischen `Enthusiast` und `Professional`.\n\nDas Feld `DevType` enthält Informationen zu den Rollen, die die Befragten innehaben. Da die Frage mehrere Antworten zulässt, enthält die Spalte Wertelisten, die durch `;` getrennt sind, was die direkte Analyse etwas schwieriger macht.\n\nDefinieren wir eine Hilfsfunktion, die eine Spalte mit Wertelisten (wie `survey_df.DevType`) in einem Data Frame mit einer Spalte für jede mögliche Option umwandelt.\n\n`dev_type_df` hat eine Spalte für jede Option, die als Antwort ausgewählt werden kann. Wenn ein Befragter die Option ausgewählt hat, ist der Wert in der Spalte `True`, andernfalls ist er `False`.\n\nWir können nun die spaltenweisen Summen verwenden, um die häufigsten Rollen zu identifizieren.\n\nWie zu erwarten ist, enthalten die häufigsten Rollen „Developer“ im Namen.\n\n**Übungen**:\n\n* Können Sie herausfinden, wie viel Prozent der Befragten in Rollen mit Bezug zur Datenwissenschaft arbeiten?\n* Welche Rolle hat den höchsten Frauenanteil?\n\nWir haben nur eine Handvoll der 20 ausgewählten Spalten untersucht. Erkunden und visualisieren Sie die verbleibenden Spalten mithilfe der leeren Zellen unten.\n\n<a id='fragen'></a>\n\n## Fragen stellen und beantworten\n\nWir haben bereits mehrere Erkenntnisse über die Befragten und die Programmiergemeinschaft im Allgemeinen gewonnen, indem wir einfach einzelne Spalten des Datensatzes untersucht haben. Lassen Sie uns einige spezifische Fragen stellen und versuchen, sie mithilfe von Data Frame-Operationen und interessanten Visualisierungen zu beantworten.\n\n### F: Welche waren die beliebtesten Programmiersprachen im Jahr 2020?\n\nUm dies zu beantworten, können wir die Spalte `LanguageWorkedWith` verwenden. Ähnlich wie bei `DevType` konnten die Befragten hier mehrere Optionen auswählen.\n\nZuerst teilen wir diese Spalte in ein Data Frame auf, der eine Spalte für jede in den Optionen aufgeführte Sprache enthält.\n\nEs scheint, dass insgesamt 25 Sprachen in den Optionen enthalten waren. Fassen wir diese zusammen, um den Prozentsatz der Befragten zu ermitteln, die die einzelnen Sprachen ausgewählt haben.\n\nWir können diese Informationen mithilfe eines horizontalen Balkendiagramms darstellen.\n\nEs überrascht vielleicht nicht, dass Javascript und HTML/CSS an der Spitze stehen, da die Webentwicklung heutzutage eine der gefragtesten Fähigkeiten ist und zufälligerweise auch eine der am einfachsten zu erlernenden Fähigkeiten ist. SQL ist für die Arbeit mit relationalen Datenbanken notwendig, daher ist es keine Überraschung, dass die meisten Programmierer regelmäßig mit SQL arbeiten. Für andere Entwicklungsformen scheint Python die beliebteste Wahl zu sein und Java zu verdrängen, das über zwei Jahrzehnte lang der Industriestandard für die Server- und Anwendungsentwicklung war.\n\n**Übungen**:\n\n* Welche Sprachen werden von Studierenden am häufigsten verwendet? Wie schneidet die Liste im Vergleich zu den am häufigsten von professionellen Entwicklern verwendeten Sprachen ab?\n* Welches sind die häufigsten Sprachen unter den Befragten, die sich selbst nicht als „Entwickler, Frontend“ bezeichnen?\n* Welche Sprachen werden unter den Befragten, die in Bereichen mit Bezug zur Datenwissenschaft arbeiten, am häufigsten gesprochen?\n* Welche Sprachen werden am häufigsten von Entwicklern verwendet, die älter als 35 Jahre sind?\n* Welche Sprachen werden von Entwicklern in Ihrem Heimatland am häufigsten verwendet?\n\n### F: Welche Sprachen möchten die Menschen im nächsten Jahr am meisten lernen?\n\nHierzu können wir die Spalte `LanguageDesireNextYear` mit ähnlicher Verarbeitung wie die vorherige verwenden.\n\nAuch hier ist es nicht verwunderlich, dass Python die Sprache ist, die die meisten Menschen lernen möchten – da es sich um eine leicht zu erlernende Allzweck-Programmiersprache handelt, die sich gut für eine Vielzahl von Bereichen eignet: Anwendungsentwicklung, numerische Berechnungen, Datenanalyse, maschinelles Lernen , Big Data, Cloud-Automatisierung, Web Scraping, Scripting usw. usw. Wir verwenden Python für genau diese Analyse, also sind wir in guter Gesellschaft!\n\n**Übungen**: Wiederholen Sie alle Übungen für die vorherige Frage und ersetzen Sie dabei „am häufigsten verwendete Sprachen“ durch „Sprachen, die Menschen gerne lernen/anwenden“.\n\n### F: Welche sind die beliebtesten Sprachen, d. h. ein hoher Prozentsatz der Menschen, die die Sprache verwendet haben, möchten sie im nächsten Jahr weiter lernen und verwenden?\n\nAuch wenn diese Frage auf den ersten Blick schwierig erscheinen mag, ist sie mit Pandas-Array-Operationen wirklich einfach zu lösen. Folgendes können wir tun:\n\n- Erstellen Sie ein neues Data Frame `languages_loved_df`, der nur dann einen `True`-Wert für eine Sprache enthält, wenn die entsprechenden Werte in `languages_worked_df` und `languages_interested_df` beide `True` sind.\n- Nehmen Sie die spaltenweise Summe von `languages_loved_df` und dividieren Sie sie durch die spaltenweise Summe von `languages_worked_df`, um den Prozentsatz der Befragten zu erhalten, die die Sprache „lieben“.\n- Sortieren Sie die Ergebnisse in absteigender Reihenfolge und zeichnen Sie ein horizontales Balkendiagramm\n\n[Rust](https://www.rust-lang.org) ist seit [4 Jahren in Folge](https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/) die beliebteste Sprache auf StackOverflow, gefolgt von TypeScript, das in den letzten Jahren als gute Alternative zu JavaScript für die Webentwicklung an Popularität gewonnen hat.\n\nPython rangiert auf Platz 3, obwohl es bereits eine der am weitesten verbreiteten Sprachen der Welt ist. Dies zeigt auf, dass die Sprache eine solide Grundlage hat, wirklich einfach zu erlernen und zu verwenden ist, ein starkes Ökosystem von Bibliotheken für verschiedene Anwendungsfälle besitzt und eine riesige weltweite Gemeinschaft von Entwicklern hat, die Freude am Umgang mit ihr haben.\n\n**Übungen:** Was sind die _meistgefürchteten Sprachen_, also Sprachen, die die Leute im vergangenen Jahr verwendet haben, aber im nächsten Jahr nicht erlernen oder verwenden wollen. Hinweis: `~languages_interested_df`\n\n### F: In welchen Ländern arbeiten Entwickler am meisten Stunden pro Woche? Berücksichtigen Sie nur Länder mit mehr als 250 Antworten.\n\nUm diese Frage zu beantworten, müssen wir die Data Frame-Methode `groupby` verwenden, um die Zeilen für jedes Land zu aggregieren. Außerdem müssen wir die Ergebnisse filtern, um nur die Länder einzuschließen, die mehr als 250 Befragte haben.\n\nDie asiatischen Länder wie Iran, China und Israel haben die höchsten Arbeitszeiten, gefolgt von den Vereinigten Staaten. Allerdings gibt es insgesamt keine allzu großen Unterschiede und die durchschnittliche Arbeitszeit scheint bei etwa 40 Stunden pro Woche zu liegen.\n\n**Übungen:**\n\n* Wie sind die durchschnittlichen Arbeitsstunden auf verschiedenen Kontinenten zu vergleichen? Möglicherweise finden Sie diese Liste von [Ländern auf jedem Kontinent](https://hub.jovian.ml/wp-content/uploads/2020/09/countries.csv) hilfreich.\n* Welche Rolle hat die höchste durchschnittliche Anzahl an Arbeitsstunden pro Woche? Welche Rolle hat die niedrigste?\n* Wie sind die geleisteten Arbeitsstunden im Vergleich zwischen Freiberuflern und Entwicklern, die Vollzeit arbeiten?\n\n### F: Wie wichtig ist es, jung anzufangen, um eine Karriere im Programmieren aufzubauen?\n\nLassen Sie uns ein Streudiagramm von `Age` vs. `YearsCodePro` (d. h. Jahre Programmiererfahrung) erstellen, um diese Frage zu beantworten.\n\nSie können überall in der Grafik Punkte sehen, was darauf hindeutet, dass Sie **in jedem Alter professionell mit dem Programmieren beginnen können**. Außerdem scheinen viele Menschen, die seit mehreren Jahrzehnten beruflich mit dem Programmieren beschäftigt sind, auch als Hobby Spaß daran haben.\n\nWir können auch die Verteilung der Spalte `Age1stCode` anzeigen, um zu sehen, wann die Befragten zum ersten Mal versucht haben, zu programmieren.\n\nWie zu erwarten ist, scheinen die meisten Menschen bereits vor ihrem 40. Lebensjahr mit dem Programmieren in Berührung gekommen zu sein, aber es gibt Menschen jeden Alters und jeder Gesellschaftsschicht, die das Programmieren lernen.\n\n**Übungen**:\n* Wie verändert Erfahrung Meinungen und Vorlieben? Wiederholen Sie die gesamte Analyse und vergleichen Sie dabei die Antworten von Personen mit mehr als 10 Jahren professioneller Programmiererfahrung mit denen von Personen, die weniger als 10 Jahre professionelle Programmiererfahrung verfügen. Sehen Sie interessante Trends?\n* Vergleichen Sie die Jahre professioneller Programmiererfahrung verschiedener Geschlechter.\n\nBenutzen Sie die leeren Zellen unten, um weitere Fragen zu stellen und zu beantworten.\n\n<a id='ergebnisse'></a>\n\n## Schlussfolgerungen und Ergebnisse\n\nWir haben viele interessante Schlussfolgerungen aus der Umfrage gezogen, hier ist eine Zusammenfassung von einigen davon:\n\n- Basierend auf den demografischen Daten der Umfrageteilnehmer können wir schließen, dass die Umfrage in gewisser Weise repräsentativ für die gesamte Programmiergemeinschaft ist, obwohl sie definitiv weniger Antworten von Programmierern aus nicht-englischsprachigen Ländern und von Frauen & nicht-binären Geschlechtern hat.\n\n- Die Programmiergemeinschaft ist nicht so vielfältig, wie sie sein könnte, und obwohl sich die Dinge verbessern, sollten wir mehr Anstrengungen unternehmen, um Mitglieder von unterrepräsentierten Gemeinschaften zu unterstützen und zu ermutigen - sei es hinsichtlich des Alters, des Landes, der Rasse, des Geschlechts oder sonstiger Aspekte.\n\n- Die meisten Programmierer haben einen Hochschulabschluss, obwohl ein ziemlich großer Prozentsatz im College nicht Informatik als Hauptfach hatte. Daher ist ein Informatikabschluss nicht zwingend notwendig, um das Programmieren zu erlernen oder eine Karriere in der Programmierung aufzubauen.\n\n- Ein bedeutender Prozentsatz der Programmierer arbeitet entweder Teilzeit oder als Freiberufler, und das kann ein großartiger Weg sein, um in das Feld einzusteigen, besonders wenn man gerade erst anfängt.\n\n- Javascript & HTML/CSS sind die am häufigsten verwendeten Programmiersprachen im Jahr 2020, dicht gefolgt von SQL & Python.\n\n- Python ist die Sprache, die die meisten Leute lernen möchten - da es eine leicht zu erlernende allgemeine Programmiersprache ist, die gut für eine Vielzahl von Bereichen geeignet ist.\n\n- Rust und TypeScript sind die \"beliebtesten\" Sprachen im Jahr 2020, beide haben kleine, aber schnell wachsende Gemeinschaften. Python ist ein enger Dritter, obwohl es bereits eine weit verbreitete Sprache ist.\n\n- Programmierer auf der ganzen Welt scheinen durchschnittlich etwa 40 Stunden pro Woche zu arbeiten, mit leichten Variationen je nach Land.\n\n- Man kann in jedem Alter programmieren lernen und professionell einsteigen, und man hat wahrscheinlich eine lange und erfüllende Karriere, wenn man auch das Programmieren als Hobby genießt.\n\n## Referenzen und zukünftige Arbeit\n\nMit der Umfrage lässt sich eine Fülle von Informationen entdecken, und wir haben gerade erst an der Oberfläche gekratzt. Hier sind einige Ideen für eine weitere Erkundung:\n\n- Wiederholen Sie die Analyse für verschiedene Altersgruppen und Geschlechter und vergleichen Sie die Ergebnisse.\n- Wählen Sie eine andere Gruppe von Spalten (wir haben 20 von 65 gewählt) aus, um andere Aspekte der Daten zu analysieren.\n- Bereiten Sie eine Analyse mit Schwerpunkt auf Vielfalt vor und identifizieren Sie Bereiche, in denen unterrepräsentierte Gemeinschaften mit der Mehrheit gleichauf sind (z.B. Bildung) und wo sie es nicht sind (z.B. Gehälter).\n- Vergleichen Sie die Ergebnisse dieser Umfrage mit denen der Vorjahre und identifizieren Sie interessante Trends.\n\nReferenzen:\n\n- [Stack Overflow Entwicklerumfrage](https://insights.stackoverflow.com/survey)\n- [Pandas Benutzerhandbuch](https://pandas.pydata.org/docs/user_guide/index.html)\n- [Matplotlib Benutzerhandbuch](https://matplotlib.org/3.3.1/users/index.html)\n- [Seaborn Benutzerhandbuch & Tutorial](https://seaborn.pydata.org/tutorial.html)\n- [`opendatasets` Python-Bibliothek](https://github.com/JovianML/opendatasets)\n","srcMarkdownNoYaml":"\n\n\n\n\n*Analyse der Antworten aus der jährlichen Entwicklerumfrage 2020 von Stack Overflow*\n\nDieses Tutorial ist das achte (und letzte) in einer Reihe zur Einführung in die Programmierung und Datenanalyse mit der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\n\nDie folgenden Themen werden in diesem Tutorial behandelt:\n\n* [Datenvorbereitung und -aufbereitung](#datenvorbereitung)\n* [Explorative Analyse und Visualisierung](#visualisierung)\n* [Fragen stellen und beantworten](#fragen)\n* [Schlussfolgerungen und Ergebnisse](#ergebnisse)\n\n\n\n## Einführung\n\nFür unsere Analyse verwenden wir den StackOverflow-Entwicklerumfragedatensatz. Dies ist eine jährliche Umfrage, die von StackOverflow durchgeführt wird. Die Rohdaten und Ergebnisse finden Sie [hier](https://insights.stackoverflow.com/survey).\n\nEs gibt mehrere Möglichkeiten, den Datensatz in Jupyter zu importieren:\n\n- Laden Sie die CSV-Datei manuell herunter und laden Sie sie über die Jupyter-GUI hoch\n- Verwenden Sie die Funktion „urlretrieve“ aus `urllib.request`, um CSV-Dateien direkt von einer Roh-URL herunterzuladen\n\nWir nutzen die bereits heruntergeladene Datei, die sich im `data` Ordner befindet.\n\nSie können die heruntergeladenen Dateien mit der Menüoption `Datei > Öffnen` in Jupyter durchsuchen. Es scheint, als ob der Datensatz drei Dateien enthält:\n\n- `README.txt` – enthält Informationen zum Datensatz\n- `survey_results_schema.csv` – enthält die Liste der Fragen (und Kurzcodes für jede Frage)\n- `survey_results_public.csv` – die vollständige Liste der Antworten auf die Fragen\n\nLaden wir die CSV-Dateien mithilfe der Pandas-Bibliothek. Wir verwenden den Namen `survey_raw_df` für das Data Frame, um anzuzeigen, dass es sich um unverarbeitete Daten handelt, die wir möglicherweise bereinigen, filtern und ändern, um ein Data Frame vorzubereiten, der für die Analyse bereit ist.\n\nDer Datensatz enthält über 64.000 Antworten auf 60 Fragen (obwohl viele Fragen optional sind). Die Antworten wurden anonymisiert und es stehen uns keine personenbezogenen Daten zur Verfügung – obwohl jedem Befragten eine zufällige Befragten-ID zugewiesen wurde.\n\nSehen wir uns die Liste der Spalten im Data Frame an.\n\nEs scheint, dass Kurzcodes für Fragen als Spaltennamen verwendet werden.\n\nWir können auf die Schemadatei verweisen, um den vollständigen Text jeder Frage anzuzeigen. Die Schemadatei enthält nur zwei Spalten: `Column` und `QuestionText`, sodass wir sie als Pandas-Serie mit `Column` als Index und `QuestionText` als Wert laden können.\n\nWir können jetzt `schema_raw` verwenden, um den vollständigen Fragentext für jede Spalte in `survey_raw_df` abzurufen.\n\nWir haben den Datensatz nun geladen und können mit dem nächsten Schritt der Vorverarbeitung und Bereinigung der Daten für unsere Analyse fortfahren.\n\n<a id='datenvorbereitung'></a>\n\n## Datenvorbereitung und -aufbereitung\n\nObwohl die Umfrageantworten eine Fülle von Informationen enthalten, beschränken wir unsere Analyse auf die folgenden Bereiche:\n\n- Demografische Daten der Umfrageteilnehmer und der globalen Programmiergemeinschaft\n- Verteilung von Programmierkenntnissen, Erfahrungen und Vorlieben\n- Beschäftigungsbezogene Informationen, Vorlieben und Meinungen\n\nWählen wir eine Teilmenge von Spalten mit den relevanten Daten für unsere Analyse aus.\n\nExtrahieren wir eine Kopie der Daten aus diesen Spalten in einem neuen Data Frame `survey_df`, das wir weiter ändern können, ohne das ursprüngliche Data Frame zu beeinträchtigen.\n\nSehen wir uns einige grundlegende Informationen zum Data Frame an.\n\nDie meisten Spalten haben den Datentyp `Objekt`, entweder weil sie Werte unterschiedlichen Typs enthalten, oder weil sie leere Werte enthalten, die mit `NaN` dargestellt werden. Es scheint, dass jede Spalte einige leere Werte enthält, da die Nicht-Null-Anzahl für jede Spalte niedriger ist als die Gesamtzahl der Zeilen (64461). Wir müssen mit leeren Werten umgehen und den Datentyp für jede Spalte von Fall zu Fall manuell anpassen.\n\nNur zwei der Spalten wurden als numerische Spalten (`Age` und `WorkWeekHrs`) erkannt, obwohl es einige andere Spalten gibt, die überwiegend numerische Werte enthalten. Um unsere Analyse zu vereinfachen, konvertieren wir einige andere Spalten in numerische Datentypen und ignorieren dabei alle nicht numerischen Werte (sie werden in NaNs konvertiert).\n\nSehen wir uns nun einige grundlegende Statistiken zu den numerischen Spalten an.\n\nEs scheint ein Problem mit der Altersspalte zu geben, da der Mindestwert 1 und der Höchstwert 279 beträgt. Dies ist ein häufiges Problem bei Umfragen: Antworten können aufgrund versehentlicher oder absichtlicher Fehler bei der Beantwortung ungültige Werte enthalten. Eine einfache Lösung besteht darin, die Zeilen, in denen der Wert in der Altersspalte höher als 100 Jahre oder niedriger als 10 Jahre ist, als ungültige Umfrageantworten zu ignorieren. Dies kann mit der `.drop`-Methode erfolgen, [wie hier erklärt](https://www.geeksforgeeks.org/drop-rows-from-the-dataframe-based-on-certain-condition-applied-on-a-column/).\n\nDas Gleiche gilt für `WorkWeekHrs`. Ignorieren wir Einträge, bei denen der Wert für die Spalte höher als 140 Stunden ist. (~20 Stunden pro Tag).\n\nIn der Spalte `Gender` können auch mehrere Optionen ausgewählt werden. Um unsere Analyse zu vereinfachen, entfernen wir jedoch Werte, die mehr als eine Option enthalten.\n\nWir haben den Datensatz nun bereinigt und für die Analyse vorbereitet. Werfen wir einen Blick auf beispielhafte Zeilen aus dem Data Frame.\n\n<a id='visualisierung'></a>\n\n## Explorative Analyse und Visualisierung\n\nBevor wir interessante Fragen zu den Umfrageantworten stellen können, wäre es hilfreich zu verstehen, wie die demografischen Merkmale, d. h. Land, Alter, Geschlecht, Bildungsniveau, Beschäftigungsniveau usw., der Befragten aussehen. Es ist wichtig, diese Variablen zu untersuchen, um zu verstehen, wie repräsentativ die Umfrage für die weltweite Programmiergemeinschaft ist, da eine Umfrage dieser Größenordnung im Allgemeinen zu einem gewissen [selection bias](https://en.wikipedia.org/wiki/Selection_bias) führt.\n\nBeginnen wir mit dem Import von `matplotlib.pyplot` and `seaborn`.\n\n### Land\n\nSchauen wir uns die Anzahl der Länder an, aus denen in der Umfrage Antworten vorliegen, und zeichnen wir die 10 Länder mit der höchsten Anzahl an Antworten auf.\n\nMit der Methode `value_counts` können wir die Länder mit der höchsten Anzahl an Befragten identifizieren.\n\nWir können diese Informationen mithilfe eines Balkendiagramms visualisieren.\n\nEs scheint, dass überproportional viele Befragte aus den USA und Indien stammen – was zu erwarten ist, da diese Länder (abgesehen von China) die höchste Bevölkerungszahl haben und die Umfrage auf Englisch erfolgt, der von Fachleuten in China allgemein verwendeten Sprache USA, Indien und Großbritannien. Wir können bereits erkennen, dass die Umfrage möglicherweise nicht repräsentativ für die gesamte Programmiergemeinschaft ist – insbesondere für nicht englischsprachige Länder.\n\n**Übung**:\nVersuchen Sie, den Prozentsatz der Antworten aus englischsprachigen im Vergleich zu nicht englischsprachigen Ländern zu ermitteln. Sie können [diese Liste der in verschiedenen Ländern gesprochenen Sprachen](https://github.com/JovianML/opendatasets/blob/master/data/countries-linguals-spoken/countries-linguals.csv) verwenden.\n\n### Alter\n\nDie Verteilung des Alters der Befragten ist ein weiterer wichtiger zu betrachtender Faktor, den wir mithilfe eines Histogramms visualisieren können.\n\nEs scheint, dass ein großer Prozentsatz der Befragten im Alter zwischen 20 und 45 Jahren ist, was einigermaßen repräsentativ für die Programmiergemeinschaft im Allgemeinen ist, da viele junge Menschen in den letzten 20 Jahren Computer als Studienfach oder Beruf gewählt haben.\n\n**Übung**: Möglicherweise möchten Sie die Antworten nach Alter (oder Altersgruppe) herausfiltern, wenn Sie die Ergebnisse der Umfrage für verschiedene Altersgruppen analysieren und vergleichen möchten. Erstellen Sie eine neue Spalte mit dem Namen `AgeGroup`, die Werte wie `Less than 10 years`, `10-18 years`, `18-30 years`, `30-45 years`, `45-60 years`, `Older than 60 years` und wiederholen Sie die Analyse im Rest dieses Notizbuchs für jede Altersgruppe.\n\n### Geschlecht\n\nSchauen wir uns die Verteilung der Antworten für das Geschlecht an. Es ist eine bekannte Tatsache, dass Frauen und nicht-binäre Geschlechter in der Programmiergemeinschaft unterrepräsentiert sind, sodass wir hier mit einer ungleichen Verteilung rechnen können.\n\nEin Kreisdiagramm wäre eine gute Möglichkeit, die Verteilung zu visualisieren.\n\nNur etwa 8 % der Umfrageteilnehmer, die die Frage beantwortet haben, identifizieren sich als Frauen oder nicht-binär. Diese Zahl ist niedriger als der Gesamtanteil von Frauen und nicht-binären Geschlechtern in der Programmiergemeinschaft, der auf etwa 12 % geschätzt wird.\n\n**Übung**: Es wäre interessant, die Antworten und Präferenzen der Umfrage nach Geschlechtern zu vergleichen. Wir empfehlen Ihnen, diese Analyse mit diesen Aufschlüsselungen zu wiederholen. Wie unterscheiden sich die relativen Bildungsniveaus zwischen den Geschlechtern? Wie unterscheiden sich die Gehälter? Sie finden diese Analyse möglicherweise auf der Website [Gender Divide in Data Science](https://medium.com/datadriveninvestor/exploratory-data-analysis-eda-understanding-the-gender-divide-in-data-science-roles-9faa5da44f5b) nützlich.\n\n### Bildungsniveau\n\nEine formale Ausbildung in Informatik wird oft als wichtige Voraussetzung für die Karriere als Programmierer angesehen. Mal sehen, ob dies tatsächlich der Fall ist, insbesondere da online viele kostenlose Ressourcen und Tutorials zum Erlernen des Programmierens verfügbar sind. Wir verwenden ein horizontales Balkendiagramm, um das Bildungsniveau der Befragten zu vergleichen.\n\nEs scheint, dass deutlich mehr als die Hälfte der Befragten einen Bachelor- oder Master-Abschluss haben, die meisten Programmierer scheinen also definitiv über eine Hochschulausbildung zu verfügen, obwohl aus dieser Grafik allein nicht klar hervorgeht, ob sie einen Abschluss in Informatik haben.\n\n**Übungen**: Das Diagramm zeigt derzeit die Anzahl der Befragten für jede Option. Können Sie es ändern, um stattdessen den Prozentsatz anzuzeigen? Können Sie die Grafik außerdem aufschlüsseln, um die Prozentsätze für jeden Grad für Männer und Frauen zu vergleichen?\n\nLassen Sie uns auch die Bachelor-Studiengänge grafisch darstellen, aber dieses Mal werden wir die Zahlen in Prozentsätze umwandeln und nach Prozentwerten sortieren, um die Reihenfolge besser visualisieren zu können.\n\nEs stellt sich heraus, dass 40 % der Programmierer mit Hochschulabschluss ein anderes Studienfach als Informatik haben – was sehr ermutigend ist. Dies scheint darauf hinzudeuten, dass eine Hochschulausbildung zwar im Allgemeinen hilfreich ist, Sie jedoch kein Hauptfach in Informatik absolvieren müssen, um ein erfolgreicher Programmierer zu werden.\n\n**Übungen**: Analysieren Sie die Ergebnisse der Spalte `NEWEdImpt` für Befragte mit einem Hochschulabschluss im Vergleich zu denen ohne Hochschulabschluss. Bemerken Sie einen Meinungsunterschied?\n\n### Arbeitsverhältnis\n\nProgrammierer entscheiden sich häufig für freiberufliche Arbeit oder Vertragsarbeit, daher wäre es interessant, die Aufteilung zwischen Vollzeit-, Teilzeit- und freiberuflicher Arbeit zu vergleichen. Lassen Sie uns die Daten aus der Spalte `Employment` visualisieren.\n\nEs scheint, dass knapp 10 % der Befragten in Teilzeit oder als Freiberufler beschäftigt sind.\n\n**Übung**: Fügen Sie eine neue Spalte `EmploymentType` hinzu, die die Werte `Enthusiast` (Student oder nicht angestellt, aber auf der Suche nach Arbeit), `Professional` (vollzeitbeschäftigt, Teilzeit oder freiberuflich tätig) und enthält `Other` (nicht angestellt oder im Ruhestand). Zeigen Sie für jede der folgenden Grafiken einen Vergleich zwischen `Enthusiast` und `Professional`.\n\nDas Feld `DevType` enthält Informationen zu den Rollen, die die Befragten innehaben. Da die Frage mehrere Antworten zulässt, enthält die Spalte Wertelisten, die durch `;` getrennt sind, was die direkte Analyse etwas schwieriger macht.\n\nDefinieren wir eine Hilfsfunktion, die eine Spalte mit Wertelisten (wie `survey_df.DevType`) in einem Data Frame mit einer Spalte für jede mögliche Option umwandelt.\n\n`dev_type_df` hat eine Spalte für jede Option, die als Antwort ausgewählt werden kann. Wenn ein Befragter die Option ausgewählt hat, ist der Wert in der Spalte `True`, andernfalls ist er `False`.\n\nWir können nun die spaltenweisen Summen verwenden, um die häufigsten Rollen zu identifizieren.\n\nWie zu erwarten ist, enthalten die häufigsten Rollen „Developer“ im Namen.\n\n**Übungen**:\n\n* Können Sie herausfinden, wie viel Prozent der Befragten in Rollen mit Bezug zur Datenwissenschaft arbeiten?\n* Welche Rolle hat den höchsten Frauenanteil?\n\nWir haben nur eine Handvoll der 20 ausgewählten Spalten untersucht. Erkunden und visualisieren Sie die verbleibenden Spalten mithilfe der leeren Zellen unten.\n\n<a id='fragen'></a>\n\n## Fragen stellen und beantworten\n\nWir haben bereits mehrere Erkenntnisse über die Befragten und die Programmiergemeinschaft im Allgemeinen gewonnen, indem wir einfach einzelne Spalten des Datensatzes untersucht haben. Lassen Sie uns einige spezifische Fragen stellen und versuchen, sie mithilfe von Data Frame-Operationen und interessanten Visualisierungen zu beantworten.\n\n### F: Welche waren die beliebtesten Programmiersprachen im Jahr 2020?\n\nUm dies zu beantworten, können wir die Spalte `LanguageWorkedWith` verwenden. Ähnlich wie bei `DevType` konnten die Befragten hier mehrere Optionen auswählen.\n\nZuerst teilen wir diese Spalte in ein Data Frame auf, der eine Spalte für jede in den Optionen aufgeführte Sprache enthält.\n\nEs scheint, dass insgesamt 25 Sprachen in den Optionen enthalten waren. Fassen wir diese zusammen, um den Prozentsatz der Befragten zu ermitteln, die die einzelnen Sprachen ausgewählt haben.\n\nWir können diese Informationen mithilfe eines horizontalen Balkendiagramms darstellen.\n\nEs überrascht vielleicht nicht, dass Javascript und HTML/CSS an der Spitze stehen, da die Webentwicklung heutzutage eine der gefragtesten Fähigkeiten ist und zufälligerweise auch eine der am einfachsten zu erlernenden Fähigkeiten ist. SQL ist für die Arbeit mit relationalen Datenbanken notwendig, daher ist es keine Überraschung, dass die meisten Programmierer regelmäßig mit SQL arbeiten. Für andere Entwicklungsformen scheint Python die beliebteste Wahl zu sein und Java zu verdrängen, das über zwei Jahrzehnte lang der Industriestandard für die Server- und Anwendungsentwicklung war.\n\n**Übungen**:\n\n* Welche Sprachen werden von Studierenden am häufigsten verwendet? Wie schneidet die Liste im Vergleich zu den am häufigsten von professionellen Entwicklern verwendeten Sprachen ab?\n* Welches sind die häufigsten Sprachen unter den Befragten, die sich selbst nicht als „Entwickler, Frontend“ bezeichnen?\n* Welche Sprachen werden unter den Befragten, die in Bereichen mit Bezug zur Datenwissenschaft arbeiten, am häufigsten gesprochen?\n* Welche Sprachen werden am häufigsten von Entwicklern verwendet, die älter als 35 Jahre sind?\n* Welche Sprachen werden von Entwicklern in Ihrem Heimatland am häufigsten verwendet?\n\n### F: Welche Sprachen möchten die Menschen im nächsten Jahr am meisten lernen?\n\nHierzu können wir die Spalte `LanguageDesireNextYear` mit ähnlicher Verarbeitung wie die vorherige verwenden.\n\nAuch hier ist es nicht verwunderlich, dass Python die Sprache ist, die die meisten Menschen lernen möchten – da es sich um eine leicht zu erlernende Allzweck-Programmiersprache handelt, die sich gut für eine Vielzahl von Bereichen eignet: Anwendungsentwicklung, numerische Berechnungen, Datenanalyse, maschinelles Lernen , Big Data, Cloud-Automatisierung, Web Scraping, Scripting usw. usw. Wir verwenden Python für genau diese Analyse, also sind wir in guter Gesellschaft!\n\n**Übungen**: Wiederholen Sie alle Übungen für die vorherige Frage und ersetzen Sie dabei „am häufigsten verwendete Sprachen“ durch „Sprachen, die Menschen gerne lernen/anwenden“.\n\n### F: Welche sind die beliebtesten Sprachen, d. h. ein hoher Prozentsatz der Menschen, die die Sprache verwendet haben, möchten sie im nächsten Jahr weiter lernen und verwenden?\n\nAuch wenn diese Frage auf den ersten Blick schwierig erscheinen mag, ist sie mit Pandas-Array-Operationen wirklich einfach zu lösen. Folgendes können wir tun:\n\n- Erstellen Sie ein neues Data Frame `languages_loved_df`, der nur dann einen `True`-Wert für eine Sprache enthält, wenn die entsprechenden Werte in `languages_worked_df` und `languages_interested_df` beide `True` sind.\n- Nehmen Sie die spaltenweise Summe von `languages_loved_df` und dividieren Sie sie durch die spaltenweise Summe von `languages_worked_df`, um den Prozentsatz der Befragten zu erhalten, die die Sprache „lieben“.\n- Sortieren Sie die Ergebnisse in absteigender Reihenfolge und zeichnen Sie ein horizontales Balkendiagramm\n\n[Rust](https://www.rust-lang.org) ist seit [4 Jahren in Folge](https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/) die beliebteste Sprache auf StackOverflow, gefolgt von TypeScript, das in den letzten Jahren als gute Alternative zu JavaScript für die Webentwicklung an Popularität gewonnen hat.\n\nPython rangiert auf Platz 3, obwohl es bereits eine der am weitesten verbreiteten Sprachen der Welt ist. Dies zeigt auf, dass die Sprache eine solide Grundlage hat, wirklich einfach zu erlernen und zu verwenden ist, ein starkes Ökosystem von Bibliotheken für verschiedene Anwendungsfälle besitzt und eine riesige weltweite Gemeinschaft von Entwicklern hat, die Freude am Umgang mit ihr haben.\n\n**Übungen:** Was sind die _meistgefürchteten Sprachen_, also Sprachen, die die Leute im vergangenen Jahr verwendet haben, aber im nächsten Jahr nicht erlernen oder verwenden wollen. Hinweis: `~languages_interested_df`\n\n### F: In welchen Ländern arbeiten Entwickler am meisten Stunden pro Woche? Berücksichtigen Sie nur Länder mit mehr als 250 Antworten.\n\nUm diese Frage zu beantworten, müssen wir die Data Frame-Methode `groupby` verwenden, um die Zeilen für jedes Land zu aggregieren. Außerdem müssen wir die Ergebnisse filtern, um nur die Länder einzuschließen, die mehr als 250 Befragte haben.\n\nDie asiatischen Länder wie Iran, China und Israel haben die höchsten Arbeitszeiten, gefolgt von den Vereinigten Staaten. Allerdings gibt es insgesamt keine allzu großen Unterschiede und die durchschnittliche Arbeitszeit scheint bei etwa 40 Stunden pro Woche zu liegen.\n\n**Übungen:**\n\n* Wie sind die durchschnittlichen Arbeitsstunden auf verschiedenen Kontinenten zu vergleichen? Möglicherweise finden Sie diese Liste von [Ländern auf jedem Kontinent](https://hub.jovian.ml/wp-content/uploads/2020/09/countries.csv) hilfreich.\n* Welche Rolle hat die höchste durchschnittliche Anzahl an Arbeitsstunden pro Woche? Welche Rolle hat die niedrigste?\n* Wie sind die geleisteten Arbeitsstunden im Vergleich zwischen Freiberuflern und Entwicklern, die Vollzeit arbeiten?\n\n### F: Wie wichtig ist es, jung anzufangen, um eine Karriere im Programmieren aufzubauen?\n\nLassen Sie uns ein Streudiagramm von `Age` vs. `YearsCodePro` (d. h. Jahre Programmiererfahrung) erstellen, um diese Frage zu beantworten.\n\nSie können überall in der Grafik Punkte sehen, was darauf hindeutet, dass Sie **in jedem Alter professionell mit dem Programmieren beginnen können**. Außerdem scheinen viele Menschen, die seit mehreren Jahrzehnten beruflich mit dem Programmieren beschäftigt sind, auch als Hobby Spaß daran haben.\n\nWir können auch die Verteilung der Spalte `Age1stCode` anzeigen, um zu sehen, wann die Befragten zum ersten Mal versucht haben, zu programmieren.\n\nWie zu erwarten ist, scheinen die meisten Menschen bereits vor ihrem 40. Lebensjahr mit dem Programmieren in Berührung gekommen zu sein, aber es gibt Menschen jeden Alters und jeder Gesellschaftsschicht, die das Programmieren lernen.\n\n**Übungen**:\n* Wie verändert Erfahrung Meinungen und Vorlieben? Wiederholen Sie die gesamte Analyse und vergleichen Sie dabei die Antworten von Personen mit mehr als 10 Jahren professioneller Programmiererfahrung mit denen von Personen, die weniger als 10 Jahre professionelle Programmiererfahrung verfügen. Sehen Sie interessante Trends?\n* Vergleichen Sie die Jahre professioneller Programmiererfahrung verschiedener Geschlechter.\n\nBenutzen Sie die leeren Zellen unten, um weitere Fragen zu stellen und zu beantworten.\n\n<a id='ergebnisse'></a>\n\n## Schlussfolgerungen und Ergebnisse\n\nWir haben viele interessante Schlussfolgerungen aus der Umfrage gezogen, hier ist eine Zusammenfassung von einigen davon:\n\n- Basierend auf den demografischen Daten der Umfrageteilnehmer können wir schließen, dass die Umfrage in gewisser Weise repräsentativ für die gesamte Programmiergemeinschaft ist, obwohl sie definitiv weniger Antworten von Programmierern aus nicht-englischsprachigen Ländern und von Frauen & nicht-binären Geschlechtern hat.\n\n- Die Programmiergemeinschaft ist nicht so vielfältig, wie sie sein könnte, und obwohl sich die Dinge verbessern, sollten wir mehr Anstrengungen unternehmen, um Mitglieder von unterrepräsentierten Gemeinschaften zu unterstützen und zu ermutigen - sei es hinsichtlich des Alters, des Landes, der Rasse, des Geschlechts oder sonstiger Aspekte.\n\n- Die meisten Programmierer haben einen Hochschulabschluss, obwohl ein ziemlich großer Prozentsatz im College nicht Informatik als Hauptfach hatte. Daher ist ein Informatikabschluss nicht zwingend notwendig, um das Programmieren zu erlernen oder eine Karriere in der Programmierung aufzubauen.\n\n- Ein bedeutender Prozentsatz der Programmierer arbeitet entweder Teilzeit oder als Freiberufler, und das kann ein großartiger Weg sein, um in das Feld einzusteigen, besonders wenn man gerade erst anfängt.\n\n- Javascript & HTML/CSS sind die am häufigsten verwendeten Programmiersprachen im Jahr 2020, dicht gefolgt von SQL & Python.\n\n- Python ist die Sprache, die die meisten Leute lernen möchten - da es eine leicht zu erlernende allgemeine Programmiersprache ist, die gut für eine Vielzahl von Bereichen geeignet ist.\n\n- Rust und TypeScript sind die \"beliebtesten\" Sprachen im Jahr 2020, beide haben kleine, aber schnell wachsende Gemeinschaften. Python ist ein enger Dritter, obwohl es bereits eine weit verbreitete Sprache ist.\n\n- Programmierer auf der ganzen Welt scheinen durchschnittlich etwa 40 Stunden pro Woche zu arbeiten, mit leichten Variationen je nach Land.\n\n- Man kann in jedem Alter programmieren lernen und professionell einsteigen, und man hat wahrscheinlich eine lange und erfüllende Karriere, wenn man auch das Programmieren als Hobby genießt.\n\n## Referenzen und zukünftige Arbeit\n\nMit der Umfrage lässt sich eine Fülle von Informationen entdecken, und wir haben gerade erst an der Oberfläche gekratzt. Hier sind einige Ideen für eine weitere Erkundung:\n\n- Wiederholen Sie die Analyse für verschiedene Altersgruppen und Geschlechter und vergleichen Sie die Ergebnisse.\n- Wählen Sie eine andere Gruppe von Spalten (wir haben 20 von 65 gewählt) aus, um andere Aspekte der Daten zu analysieren.\n- Bereiten Sie eine Analyse mit Schwerpunkt auf Vielfalt vor und identifizieren Sie Bereiche, in denen unterrepräsentierte Gemeinschaften mit der Mehrheit gleichauf sind (z.B. Bildung) und wo sie es nicht sind (z.B. Gehälter).\n- Vergleichen Sie die Ergebnisse dieser Umfrage mit denen der Vorjahre und identifizieren Sie interessante Trends.\n\nReferenzen:\n\n- [Stack Overflow Entwicklerumfrage](https://insights.stackoverflow.com/survey)\n- [Pandas Benutzerhandbuch](https://pandas.pydata.org/docs/user_guide/index.html)\n- [Matplotlib Benutzerhandbuch](https://matplotlib.org/3.3.1/users/index.html)\n- [Seaborn Benutzerhandbuch & Tutorial](https://seaborn.pydata.org/tutorial.html)\n- [`opendatasets` Python-Bibliothek](https://github.com/JovianML/opendatasets)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"css":["styles.css"],"output-file":"kapitel8.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":{"light":"flatly","dark":"darkly"},"code-copy":true,"smooth-scroll":true,"title":"Explorative Datenanalyse mit Python – Eine Fallstudie"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
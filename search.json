[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmierung und Datenanalyse mit Python: Eine Einführung",
    "section": "",
    "text": "1 Willkommen zu „Programmierung und Datenanalyse mit Python: Eine Einführung“",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Willkommen zu „Programmierung und Datenanalyse mit Python: Eine Einführung“</span>"
    ]
  },
  {
    "objectID": "index.html#ziel-dieses-kapitels",
    "href": "index.html#ziel-dieses-kapitels",
    "title": "Programmierung und Datenanalyse mit Python: Eine Einführung",
    "section": "1.1 Ziel dieses Kapitels",
    "text": "1.1 Ziel dieses Kapitels\nDieses Eröffnungskapitel hat vier Ziele:\n\nIhnen einen klaren Überblick über den Zweck und Aufbau des Buches/Tutoriums zu geben.\nDie Zielgruppe, ihre Voraussetzungen und erwarteten Lernziele zu benennen.\nHinweise zum praktischen Arbeiten mit den enthaltenen Jupyter-Notebooks, Datensätzen und der technischen Umgebung zu liefern.\nTipps zu weiterführenden Ressourcen und zur effizienten Nutzung des Buches zu geben.\n\nDas Kapitel soll Ihnen helfen, strukturiert und effizient mit den folgenden Kapiteln zu arbeiten — sei es beim Selbststudium, in Lehrveranstaltungen oder in beruflichen Weiterbildungen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Willkommen zu „Programmierung und Datenanalyse mit Python: Eine Einführung“</span>"
    ]
  },
  {
    "objectID": "index.html#für-wen-ist-dieses-buch",
    "href": "index.html#für-wen-ist-dieses-buch",
    "title": "Programmierung und Datenanalyse mit Python: Eine Einführung",
    "section": "1.2 Für wen ist dieses Buch?",
    "text": "1.2 Für wen ist dieses Buch?\nDieses Buch richtet sich an Einsteiger und Fortgeschrittene, die mit Python arbeiten wollen, um:\n\ngrundlegende Programmierkonzepte sicher anzuwenden,\ntabellarische Daten zu analysieren und zu visualisieren,\neinfache Datenpipelines zu bauen und reproduzierbare Analysen durchzuführen.\n\nVoraussetzungen: Es werden keine tieferen Vorkenntnisse in Programmierung vorausgesetzt. Grundlegende mathematische Kenntnisse (Schulniveau) sind ausreichend. Etwas Erfahrung mit Tabellenkalkulationen (z. B. Excel) ist hilfreich, aber nicht notwendig.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Willkommen zu „Programmierung und Datenanalyse mit Python: Eine Einführung“</span>"
    ]
  },
  {
    "objectID": "index.html#was-lernen-sie-in-diesem-buch",
    "href": "index.html#was-lernen-sie-in-diesem-buch",
    "title": "Programmierung und Datenanalyse mit Python: Eine Einführung",
    "section": "1.3 Was lernen Sie in diesem Buch?",
    "text": "1.3 Was lernen Sie in diesem Buch?\nAm Ende des Buches sollten Sie in der Lage sein:\n\nEine Python-Entwicklungsumgebung einzurichten (z. B. Anaconda, JupyterLab).\nGrundlegende Programmierkonzepte wie Variablen, Datentypen, Kontrollstrukturen und Funktionen sicher anzuwenden.\nNumerische Berechnungen mit NumPy durchzuführen.\nTabellarische Daten mit Pandas zu laden, zu bereinigen, zu transformieren und zu analysieren.\nAnschauliche Visualisierungen mit Matplotlib und Seaborn zu erstellen.\nEine einfache explorative Datenanalyse (EDA) an realen Beispieldaten durchzuführen und die Ergebnisse zu interpretieren.\nSauberen, wiederverwendbaren Code zu schreiben und einfache Arbeitsabläufe zu dokumentieren.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Willkommen zu „Programmierung und Datenanalyse mit Python: Eine Einführung“</span>"
    ]
  },
  {
    "objectID": "index.html#aufbau-und-didaktik",
    "href": "index.html#aufbau-und-didaktik",
    "title": "Programmierung und Datenanalyse mit Python: Eine Einführung",
    "section": "1.4 Aufbau und Didaktik",
    "text": "1.4 Aufbau und Didaktik\nDas Buch ist praxisorientiert aufgebaut. Jedes Kapitel besteht aus drei Teilen:\n\nKurztheorie: Eine prägnante, intuitive Darstellung der zugrunde liegenden Konzepte.\nCodebeispiele: Schritt-für-Schritt-Implementierungen in Jupyter-Notebooks mit ausführlichen Kommentaren.\nFallstudie / Übung: Ein konkretes Beispiel mit realen oder realistisch simulierten Daten, das die Anwendung der zuvor gezeigten Methoden demonstriert.\n\nAuf diese Weise möchten wir sicherstellen, dass Sie nicht nur verstehen, warum etwas funktioniert, sondern vor allem wie Sie es praktisch anwenden.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Willkommen zu „Programmierung und Datenanalyse mit Python: Eine Einführung“</span>"
    ]
  },
  {
    "objectID": "index.html#technische-voraussetzungen-installation",
    "href": "index.html#technische-voraussetzungen-installation",
    "title": "Programmierung und Datenanalyse mit Python: Eine Einführung",
    "section": "1.5 Technische Voraussetzungen & Installation",
    "text": "1.5 Technische Voraussetzungen & Installation\n\n1.5.1 Empfohlene Umgebung\n\nAnaconda (empfohlen) oder Miniconda: einfache Verwaltung von Python-Versionen und Paketen.\nJupyterLab oder Jupyter Notebook als interaktive Arbeitsumgebung.\n\n\n\n1.5.2 Empfohlene Pakete\nInstallieren Sie die Pakete idealerweise in einer separaten Conda-Umgebung:\nconda create -n pydata python=3.10 -y\nconda activate pydata\nconda install -c conda-forge jupyterlab pandas numpy matplotlib seaborn scikit-learn -y\nOptional:\n\nstatsmodels für Zeitreihen- und Regressionsanalysen\nplotly für interaktive Visualisierungen\njupyter_contrib_nbextensions für produktivitätssteigernde Erweiterungen",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Willkommen zu „Programmierung und Datenanalyse mit Python: Eine Einführung“</span>"
    ]
  },
  {
    "objectID": "index.html#arbeitsweise-best-practices",
    "href": "index.html#arbeitsweise-best-practices",
    "title": "Programmierung und Datenanalyse mit Python: Eine Einführung",
    "section": "1.6 Arbeitsweise & Best Practices",
    "text": "1.6 Arbeitsweise & Best Practices\n\nKleine Schritte: Führen Sie Code-Zellen schrittweise aus und prüfen Sie die Zwischenergebnisse.\nReproduzierbarkeit: Dokumentieren Sie alle Datenquellen und verwendeten Paketversionen.\nKommentierter Code: Schreiben Sie kurze, erklärende Kommentare — sie sind wertvoll beim späteren Nachvollziehen.\nBackups: Speichern Sie wichtige Notebooks regelmäßig; GitHub oder persönliche Cloudlaufwerke sind hilfreich.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Willkommen zu „Programmierung und Datenanalyse mit Python: Eine Einführung“</span>"
    ]
  },
  {
    "objectID": "index.html#weiterführende-ressourcen",
    "href": "index.html#weiterführende-ressourcen",
    "title": "Programmierung und Datenanalyse mit Python: Eine Einführung",
    "section": "1.7 Weiterführende Ressourcen",
    "text": "1.7 Weiterführende Ressourcen\n\nPython-Dokumentation\n\nPandas\n\nNumPy\n\nMatplotlib\n\nSeaborn\n\nJupyter",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Willkommen zu „Programmierung und Datenanalyse mit Python: Eine Einführung“</span>"
    ]
  },
  {
    "objectID": "index.html#abschlusswort",
    "href": "index.html#abschlusswort",
    "title": "Programmierung und Datenanalyse mit Python: Eine Einführung",
    "section": "1.8 Abschlusswort",
    "text": "1.8 Abschlusswort\nDieses Buch begleitet Sie vom ersten Kontakt mit Python bis hin zu einer vollständigen, reproduzierbaren explorativen Datenanalyse. Arbeiten Sie aktiv mit, probieren Sie Variationen der Beispiele aus und nutzen Sie die Notebooks als Vorlage für eigene Projekte.\nViel Erfolg und Freude beim Lernen!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Willkommen zu „Programmierung und Datenanalyse mit Python: Eine Einführung“</span>"
    ]
  },
  {
    "objectID": "kapitel1.html",
    "href": "kapitel1.html",
    "title": "2  Erste Schritte mit Python und Jupyter",
    "section": "",
    "text": "2.1 Ausführen des Codes\nDieses Tutorial ist das erste einer Reihe anfängerfreundlicher Tutorials zum Programmieren und zur Datenanalyse mit Python. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\nDie folgenden Themen werden in diesem Tutorial behandelt:\nDieses Tutorial ist ein ausführbares Jupyter Notebook. Sie können dieses Tutorial ausführen und mit den Codebeispielen experimentieren, indem Sie es auf Ihrem eigenen Computer ausführen.\nAusführen auf Ihrem eigenen Computer\nUm dieses Notebook auf Ihrem Computer auszuführen, müssen Sie Python über die Anaconda-Distribution einrichten und das Notebook herunterladen. Hier sind die Schritte, die Sie befolgen müssen, um loszulegen:\nBeachten Sie, dass Sie mit Anaconda auch verschiedene Umgebungen für verschiedene Projekte erstellen können. Jede Umgebung kann ihre eigenen spezifischen Pakete und Versionen haben, sodass Sie sicherstellen können, dass Ihre Projekte isoliert voneinander laufen und nicht miteinander interferieren. Sie können Umgebungen direkt im Anaconda Navigator erstellen und verwalten.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Erste Schritte mit Python und Jupyter</span>"
    ]
  },
  {
    "objectID": "kapitel1.html#ausführen-des-codes",
    "href": "kapitel1.html#ausführen-des-codes",
    "title": "2  Erste Schritte mit Python und Jupyter",
    "section": "",
    "text": "Laden Sie die Anaconda-Distribution herunter und installieren Sie sie auf Ihrem Computer. Anaconda ist eine kostenlose Distribution von Python und R, die sich besonders für Data Science und Machine Learning eignet. Sie enthält bereits die meisten Bibliotheken, die Sie benötigen werden.\nNach der Installation können Sie den “Anaconda Navigator” öffnen, eine Art Dashboard, das Sie durch Ihre Anaconda-Installation führt. Der Navigator ermöglicht den Zugriff auf die verschiedenen Softwarepakete, Umgebungen und Tools, die Teil der Anaconda-Distribution sind.\nIm Anaconda Navigator, finden Sie “Jupyter Notebook” unter der Liste der installierten Anwendungen. Klicken Sie auf “Launch”, um Jupyter Notebook zu starten.\nEin neues Browserfenster sollte sich öffnen, in dem Sie die Verzeichnisstruktur Ihres Computers sehen. Navigieren Sie zu dem Ordner, in dem Sie Ihr Jupyter Notebook gespeichert haben, und klicken Sie darauf, um es zu öffnen.\nJetzt können Sie das Jupyter Notebook verwenden! Es besteht aus Zellen, die Text (in Markdown) oder Code (in Python) enthalten können. Sie können eine Zelle ausführen, indem Sie sie auswählen und dann Shift+Enter drücken. Der Code wird ausgeführt und das Ergebnis wird unter der Zelle angezeigt.\nWenn Sie mit Ihrer Sitzung fertig sind, können Sie das Jupyter Notebook speichern und schließen. Vergessen Sie nicht, auch den Anaconda Navigator zu schließen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Erste Schritte mit Python und Jupyter</span>"
    ]
  },
  {
    "objectID": "kapitel1.html#arithmetische-operationen-mit-python-ausführen",
    "href": "kapitel1.html#arithmetische-operationen-mit-python-ausführen",
    "title": "2  Erste Schritte mit Python und Jupyter",
    "section": "2.2 Arithmetische Operationen mit Python ausführen",
    "text": "2.2 Arithmetische Operationen mit Python ausführen\nBeginnen wir mit der Verwendung von Python als Taschenrechner. Sie können Python mithilfe einer Codezelle in Jupyter schreiben und ausführen.\n\nArbeiten mit Zellen: Um eine neue Zelle in Jupyter zu erstellen, können Sie in der Menüleiste Einfügen &gt; Zelle darunter einfügen auswählen oder einfach die Schaltfläche + in der Symbolleiste drücken. Sie können auch die Tastenkombination Esc+B verwenden, um eine neue Zelle zu erstellen. Sobald eine Zelle erstellt wurde, klicken Sie darauf, um sie auszuwählen. Anschließend können Sie den Zelltyp mithilfe der Menüoption Zelle &gt; Zelltyp in Code oder Markdown (Text) ändern. Sie können auch die Tastenkombinationen Esc+Y und Esc+M verwenden. Doppelklicken Sie auf eine Zelle, um den Inhalt innerhalb der Zelle zu bearbeiten. Um Ihre Änderungen zu übernehmen und eine Zelle auszuführen, verwenden Sie die Menüoption Zelle &gt; Zellen ausführen, klicken Sie auf die Schaltfläche Ausführen in der Symbolleiste oder verwenden Sie einfach die Tastenkombination Shift+Enter. Eine vollständige Liste der Tastaturkürzel können Sie über die Menüoption „Hilfe &gt; Tastaturkürzel“ anzeigen.\n\nFühren Sie die folgenden Codezellen aus, um Berechnungen durchzuführen und deren Ergebnisse anzuzeigen. Versuchen Sie, die Zahlen zu ändern, und führen Sie die geänderten Zellen erneut aus, um aktualisierte Ergebnisse anzuzeigen. Können Sie erraten, wofür die Operatoren //, % und ** verwendet werden?\n\n\nCode\n2 + 3 + 9\n\n\n14\n\n\n\n\nCode\n99 - 73\n\n\n26\n\n\n\n\nCode\n23.54 * -1432\n\n\n-33709.28\n\n\n\n\nCode\n100 / 7\n\n\n14.285714285714286\n\n\n\n\nCode\n100 // 7\n\n\n14\n\n\n\n\nCode\n100 % 7\n\n\n2\n\n\n\n\nCode\n5 ** 3\n\n\n125\n\n\nWie Sie vielleicht erwarten, haben bestimmte Operatoren wie / und * gemäß mathematischen Konventionen Vorrang vor anderen Operatoren wie + und -. Sie können Klammern verwenden, z. B. ( und ), um die Reihenfolge anzugeben, in der Vorgänge ausgeführt werden.\n\n\nCode\n((2 + 5) * (17 - 3)) / (4 ** 3)\n\n\n1.53125\n\n\nPython unterstützt die folgenden arithmetischen Operatoren:\n\n\n\nOperator\nZweck\nBeispiel\nErgebnis\n\n\n\n\n+\nAddition\n2 + 3\n5\n\n\n-\nSubtraktion\n3 - 2\n1\n\n\n*\nMultiplikation\n8 * 12\n96\n\n\n/\nDivision\n100 / 7\n14.28..\n\n\n//\nGanzzahlige Division\n100 // 7\n14\n\n\n%\nModulus/Rest\n100 % 7\n2\n\n\n**\nExponent\n5 ** 3\n125",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Erste Schritte mit Python und Jupyter</span>"
    ]
  },
  {
    "objectID": "kapitel1.html#mehrstufige-probleme-mithilfe-von-variablen-lösen",
    "href": "kapitel1.html#mehrstufige-probleme-mithilfe-von-variablen-lösen",
    "title": "2  Erste Schritte mit Python und Jupyter",
    "section": "2.3 Mehrstufige Probleme mithilfe von Variablen lösen",
    "text": "2.3 Mehrstufige Probleme mithilfe von Variablen lösen\nVersuchen wir, die folgende Textaufgabe mit Python zu lösen:\n\nEin Lebensmittelgeschäft verkauft eine Tüte Eis für 1,25 $ und macht 20% Gewinn. Wenn es 500 Beutel Eis verkauft, wie hoch ist dann der Gesamtgewinn?\n\nWir können die uns zur Verfügung stehenden Informationen systematisch zusammentragen und die Aufgabenstellung nach und nach in eine mathematische Formel überführen, die wir dann mithilfe von Python auswerten können.\nCost of ice bag ($) = 1.25\nProfit margin = 20% = .2\nProfit per bag ($) = profit margin * cost of ice bag = .2 * 1.25\nNo. of bags = 500\nTotal profit = no. of bags * profit per bag = 500 * (.2 * 1.25)\n\n\nCode\n500 * (.2 * 1.25)\n\n\n125.0\n\n\nSomit erzielt das Lebensmittelgeschäft einen Gesamtgewinn von 125,0 $. Obwohl dies eine vernünftige Möglichkeit ist, ein Problem zu lösen, wird aus der Codezelle nicht ganz klar, was die Zahlen darstellen. Wir können jeder Zahl einen Namen geben, indem wir Python-Variablen erstellen.\n\nVariablen: Beim Arbeiten mit einer Programmiersprache wie Python werden Informationen in Variablen gespeichert. Sie können sich Variablen als Container zum Speichern von Daten vorstellen. Die in einer Variablen gespeicherten Daten werden als Wert bezeichnet.\n\n\n\nCode\ncost_of_ice_bag = 1.25\n\n\n\n\nCode\nprofit_margin = .2\n\n\n\n\nCode\nnumber_of_bags = 500\n\n\nDie Variablen cost_of_ice_bag, profit_margin and number_of_bags enthalten nun die in der Textaufgabe bereitgestellten Informationen. Wir können den Wert einer Variablen überprüfen, indem wir ihren Namen in eine Zelle eingeben, und wir können Variablen mithilfe arithmetischer Operationen kombinieren, um andere Variablen zu erstellen.\n\nTipp: Während Sie den Namen einer vorhandenen Variablen in eine Codezelle in Jupyter eingeben, können Sie die ersten paar Zeichen eingeben und die “Tabulatortaste“ Tab drücken, um den Variablennamen automatisch zu vervollständigen. Geben Sie pro in eine Codezelle unten ein und drücken Sie die Tabulatortaste, um die automatische Vervollständigung zu profit_margin durchzuführen.\n\n\n\nCode\nprofit_margin\n\n\n0.2\n\n\n\n\nCode\nprofit_per_bag = cost_of_ice_bag * profit_margin\n\n\n\n\nCode\nprofit_per_bag\n\n\n0.25\n\n\n\n\nCode\ntotal_profit = number_of_bags * profit_per_bag\n\n\n\n\nCode\ntotal_profit\n\n\n125.0\n\n\nWenn Sie versuchen, den Wert einer Variablen anzuzeigen, die nicht definiert ist, d. h. ihr mit der Zuweisungsanweisung Variablenname = Wert ein Wert zugewiesen wurde, zeigt Python einen Fehler an.\n\n\nCode\nnet_profit = 100\n\n\nDas Speichern und Bearbeiten von Daten mithilfe entsprechend benannter Variablen ist eine hervorragende Möglichkeit, die Funktionsweise Ihres Codes zu erklären.\nLassen Sie uns das Ergebnis der Textaufgabe mit einer freundlichen Nachricht anzeigen. Wir können dies mit der print Funktion tun.\n\nFunktionen: Eine Funktion ist ein wiederverwendbarer Satz von Anweisungen. Eine Funktion nimmt eine oder mehrere Eingaben entgegen, führt bestimmte Operationen aus und gibt häufig eine Ausgabe zurück. Python bietet viele integrierte Funktionen wie print und ermöglicht uns auch die Definition unserer eigenen Funktionen.\n\n\n\nCode\nprint(\"The grocery store makes a total profit of $\", total_profit)\n\n\nThe grocery store makes a total profit of $ 125.0\n\n\n\nprint: Die Funktion print dient der Anzeige von Informationen. Es werden eine oder mehrere Eingaben benötigt, bei denen es sich um Text (in Anführungszeichen, z. B. Das ist Text), Zahlen, Variablen, mathematische Ausdrücke usw. handeln kann. Im nächsten Abschnitt erfahren Sie mehr über Variablen und Funktionen.\n\nDas Erstellen einer Codezelle für jede Variable oder mathematische Operation kann mühsam sein. Glücklicherweise können Sie mit Jupyter mehrere Codezeilen in einer einzigen Codezelle schreiben. Schreiben wir die Lösung unseres Wortproblems in einer einzigen Zelle um.\n\n\nCode\n# Speichern Sie Eingabedaten in Variablen\ncost_of_ice_bag = 1.25\nprofit_margin = .2\nnumber_of_bags = 500\n\n# Führen Sie die erforderlichen Berechnungen durch\nprofit_per_bag = cost_of_ice_bag * profit_margin\ntotal_profit = number_of_bags * profit_per_bag\n\n# Ergebnis anzeigen\nprint(\"The grocery store makes a total profit of $\", total_profit)\n\n\nThe grocery store makes a total profit of $ 125.0\n\n\nBeachten Sie, dass wir das Zeichen # verwenden, um Kommentare in unseren Code einzufügen.\n\nKommentare: Kommentare und Leerzeilen werden während der Ausführung ignoriert, sind aber nützlich, um anderen Menschen (einschließlich Ihnen selbst) Informationen darüber zu geben, was der Code tut. Kommentare können inline (am Ende eines Codes), in einer separaten Zeile oder sogar über mehrere Zeilen hinweg erfolgen.\n\nInline- und einzeilige Kommentare beginnen mit #, während mehrzeilige Kommentare mit drei Anführungszeichen beginnen und enden, z. B. “““. Hier sind einige Beispiele für Codekommentare:\n\n\nCode\nmy_favorite_number = 1 # ein \"Inline-Kommentar\"\n\n\n\n\nCode\n# Dieser Kommentar ist in einer separaten Zeile\nmy_least_favorite_number = 3\n\n\n\n\nCode\n\"\"\"Das ist ein mehrzeiliger Kommentar.\nSchreibe so wenig oder so viel wie du möchtest.\n\nKommentare sind sehr hilfreich für Leute, die \ndeinen Code lesen, aber versuche sie kurz und prägnant zu halten.\n\nAußerdem, wenn du gute Variablennamen verwendest, dann ist dein Code \noft selbsterklärend und du benötigst vielleicht nicht einmal Kommentare!\n\"\"\"\na_neutral_number = 5",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Erste Schritte mit Python und Jupyter</span>"
    ]
  },
  {
    "objectID": "kapitel1.html#bedingungen-mit-python-auswerten",
    "href": "kapitel1.html#bedingungen-mit-python-auswerten",
    "title": "2  Erste Schritte mit Python und Jupyter",
    "section": "2.4 Bedingungen mit Python auswerten",
    "text": "2.4 Bedingungen mit Python auswerten\nNeben arithmetischen Operationen bietet Python auch mehrere Möglichkeiten zum Vergleichen von Zahlen und Variablen.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n==\nÜberprüfen, ob die Operanden gleich sind\n\n\n!=\nÜberprüfen, ob die Operanden ungleich sind\n\n\n&gt;\nÜberprüfen, ob der linke Operand größer als der rechte ist\n\n\n&lt;\nÜberprüfen, ob der linke Operand kleiner als der rechte ist\n\n\n&gt;=\nÜberprüfen, ob der linke Operand größer oder gleich dem rechten ist\n\n\n&lt;=\nÜberprüfen, ob der linke Operand kleiner oder gleich dem rechten ist\n\n\n\nDas Ergebnis einer Vergleichsoperation ist entweder True oder Falsch (beachten Sie die Großbuchstaben T und F). Dies sind spezielle Schlüsselwörter in Python. Probieren wir ein Experiment mit Vergleichsoperatoren aus.\n\n\nCode\nmy_favorite_number = 1\nmy_least_favorite_number = 5\na_neutral_number = 3\n\n\n\n\nCode\n# Überprüfung auf Gleichheit - True\nmy_favorite_number == 1\n\n\nTrue\n\n\n\n\nCode\n# Überprüfung auf Gleichheit - False\nmy_favorite_number == my_least_favorite_number\n\n\nFalse\n\n\n\n\nCode\n# Überprüfung auf Ungleichheit - True\nmy_favorite_number != a_neutral_number\n\n\nTrue\n\n\n\n\nCode\n# Überprüfung auf Ungleichheit - False\na_neutral_number != 3\n\n\nFalse\n\n\n\n\nCode\n# Überprüfung auf größer - True\nmy_least_favorite_number &gt; a_neutral_number\n\n\nTrue\n\n\n\n\nCode\n# Überprüfung auf größer - False\nmy_favorite_number &gt; my_least_favorite_number\n\n\nFalse\n\n\n\n\nCode\n# Überprüfung auf kleiner - True\nmy_favorite_number &lt; 10\n\n\nTrue\n\n\n\n\nCode\n# Überprüfung auf kleiner - False\nmy_least_favorite_number &lt; my_favorite_number\n\n\nFalse\n\n\n\n\nCode\n# Überprüfung auf größer oder gleich - True\nmy_favorite_number &gt;= 1\n\n\nTrue\n\n\n\n\nCode\n# Überprüfung auf größer oder gleich - False\nmy_favorite_number &gt;= 3\n\n\nFalse\n\n\n\n\nCode\n# Überprüfung auf kleiner oder gleich - True\n3 + 6 &lt;= 9\n\n\nTrue\n\n\n\n\nCode\n# Überprüfung auf kleiner oder gleich - False\nmy_favorite_number + a_neutral_number &lt;= 3\n\n\nFalse\n\n\nEbenso wie arithmetische Operationen kann auch das Ergebnis einer Vergleichsoperation in einer Variablen gespeichert werden.\n\n\nCode\ncost_of_ice_bag = 1.25\nis_ice_bag_expensive = cost_of_ice_bag &gt;= 10\nprint(\"Is the ice bag expensive?\", is_ice_bag_expensive)\n\n\nIs the ice bag expensive? False",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Erste Schritte mit Python und Jupyter</span>"
    ]
  },
  {
    "objectID": "kapitel1.html#bedingungen-mit-logischen-operatoren-verbinden",
    "href": "kapitel1.html#bedingungen-mit-logischen-operatoren-verbinden",
    "title": "2  Erste Schritte mit Python und Jupyter",
    "section": "2.5 Bedingungen mit logischen Operatoren verbinden",
    "text": "2.5 Bedingungen mit logischen Operatoren verbinden\nDie logischen Operatoren and, or und not wirken auf Bedingungen und True & False Werte (auch bekannt als boolesche Werte). and und or wirken auf zwei Bedingungen, während not auf eine einzelne Bedingung wirkt.\nDer Operator and gibt True zurück, wenn beide Bedingungen zu True ausgewertet werden. Andernfalls gibt er False zurück.\n\n\n\na\nb\na and b\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\n\n\nFalse\nFalse\nFalse\n\n\n\n\n\nCode\nmy_favorite_number\n\n\n1\n\n\n\n\nCode\nmy_favorite_number &gt; 0 and my_favorite_number &lt;= 3\n\n\nTrue\n\n\n\n\nCode\nmy_favorite_number &lt; 0 and my_favorite_number &lt;= 3\n\n\nFalse\n\n\n\n\nCode\nmy_favorite_number &gt; 0 and my_favorite_number &gt;= 3\n\n\nFalse\n\n\n\n\nCode\nTrue and False\n\n\nFalse\n\n\n\n\nCode\nTrue and True\n\n\nTrue\n\n\nDer Operator or gibt True zurück, wenn mindestens eine der Bedingungen zu True ausgewertet wird. Er gibt False nur zurück, wenn beide Bedingungen False sind.\n\n\n\na\nb\na oder b\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse\n\n\n\n\n\nCode\na_neutral_number = 3\n\n\n\n\nCode\na_neutral_number == 3 or my_favorite_number &lt; 0\n\n\nTrue\n\n\n\n\nCode\na_neutral_number != 3 or my_favorite_number &lt; 0\n\n\nFalse\n\n\n\n\nCode\nmy_favorite_number &lt; 0 or True\n\n\nTrue\n\n\n\n\nCode\nFalse or False\n\n\nFalse\n\n\nDer not-Operator gibt False zurück, wenn eine Bedingung True ist, und True, wenn die Bedingung False ist.\n\n\nCode\nnot a_neutral_number == 3\n\n\nFalse\n\n\n\n\nCode\nnot my_favorite_number &lt; 0\n\n\nTrue\n\n\n\n\nCode\nnot False\n\n\nTrue\n\n\n\n\nCode\nnot True\n\n\nFalse\n\n\nLogische Operatoren können zu komplexen Bedingungen kombiniert werden. Verwenden Sie runde Klammern oder Klammern ( und ), um die Reihenfolge anzugeben, in der logische Operatoren angewendet werden sollen.\n\n\nCode\n(2 &gt; 3 and 4 &lt;= 5) or not (my_favorite_number &lt; 0 and True)\n\n\nTrue\n\n\n\n\nCode\nnot (True and 0 &lt; 1) or (False and True)\n\n\nFalse\n\n\nWenn keine Klammern verwendet werden, werden logische Operatoren von links nach rechts angewendet.\n\n\nCode\nnot True and 0 &lt; 1 or False and True\n\n\nFalse\n\n\nExperimentieren Sie mit arithmetischen, bedingten und logischen Operatoren in Python und nutzen Sie dabei die interaktive Natur des Jupyter-Notebooks. Wir werden in zukünftigen Tutorials mehr über Variablen und Funktionen erfahren.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Erste Schritte mit Python und Jupyter</span>"
    ]
  },
  {
    "objectID": "kapitel1.html#textstile-mit-markdown-hinzufügen",
    "href": "kapitel1.html#textstile-mit-markdown-hinzufügen",
    "title": "2  Erste Schritte mit Python und Jupyter",
    "section": "2.6 Textstile mit Markdown hinzufügen",
    "text": "2.6 Textstile mit Markdown hinzufügen\nDas Hinzufügen von Erklärungen mithilfe von Textzellen (wie dieser) ist eine großartige Möglichkeit, Ihr Notizbuch für andere Leser und für Sie selbst informativ zu gestalten, wenn Sie in Zukunft darauf zurückgreifen müssen. Doppelklicken Sie auf eine Textzelle in Jupyter, um sie zu bearbeiten. Im Bearbeitungsmodus werden Sie feststellen, dass der Text etwas anders aussieht (z. B. hat die Überschrift ein ##-Präfix). Dieser Text wird mit Markdown geschrieben, einer einfachen Möglichkeit, Ihrem Text Stile hinzuzufügen. Führen Sie diese Zelle aus, um Sehen Sie sich die Ausgabe ohne Sonderzeichen an. Sie können zwischen der Quelle und der Ausgabe hin und her wechseln, um zu sehen, wie ein bestimmter Stil erstellt wird.\nSie können beispielsweise ein oder mehrere #-Zeichen am Anfang einer Zeile verwenden, um Kopfzeilen unterschiedlicher Größe zu erstellen:\n# Kopfzeile 1\n## Kopfzeile 2\n### Kopfzeile 3\n#### Kopfzeile 4\nUm eine Liste mit Aufzählungszeichen oder Nummern zu erstellen, beginnen Sie einfach eine Zeile mit * oder 1..\nEine Liste mit Aufzählungszeichen:\n\nItem 1\nItem 2\nItem 3\n\nEine nummerierte Liste:\n\nApfel\nBanane\nAnanas\n\nSie können Text mit ** fett formatieren, z. B. **Dies ist ein fetter Text**, oder machen Sie ihn kursiv mit *, z. B. *Dies ist ein kursiver Text.* Sie können auch Links erstellen, z. B. [Dies ist ein Link](https://www.ku.de/wfi). Auch Bilder lassen sich ganz einfach einbetten:\n![](https://www.ku.de/fileadmin/_processed_/a/a/csm_WFI_Logo_12df3953ca.webp)\nEin weiteres wirklich nettes Feature von Markdown ist die Möglichkeit, Codeblöcke einzubinden. Beachten Sie, dass Codeblöcke innerhalb von Markdown-Zellen nicht ausgeführt werden können.\n# Perform the required calculations\nprofit_per_bag = cost_of_ice_bag * profit_margin\ntotal_profit = number_of_bags * profit_per_bag\n\n# Display the result\nprint(\"The grocery store makes a total profit of $\", total_profit)\n\nDie vollständige Syntax von Markdown können Sie hier erfahren: https://learnxinyminutes.com/docs/markdown/",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Erste Schritte mit Python und Jupyter</span>"
    ]
  },
  {
    "objectID": "kapitel1.html#weiterführende-literatur-und-referenzen",
    "href": "kapitel1.html#weiterführende-literatur-und-referenzen",
    "title": "2  Erste Schritte mit Python und Jupyter",
    "section": "2.7 Weiterführende Literatur und Referenzen",
    "text": "2.7 Weiterführende Literatur und Referenzen\nIm Folgenden finden Sie einige Ressourcen zum Erlernen weiterer arithmetischer, bedingter und logischer Operationen in Python:\n\nPython-Tutorial bei W3Schools\nPraktische Python-Programmierung\nOffizielle Python-Dokumentation",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Erste Schritte mit Python und Jupyter</span>"
    ]
  },
  {
    "objectID": "kapitel2.html",
    "href": "kapitel2.html",
    "title": "3  Eine kurze Tour durch Variablen und Datentypen in Python",
    "section": "",
    "text": "3.1 Informationen mithilfe von Variablen speichern\nDieses Tutorial ist das zweite einer Reihe zur Einführung in die Programmierung und Datenanalyse mit der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\nDie folgenden Themen werden in diesem Tutorial behandelt:\nComputer sind für zwei Zwecke nützlich: zum Speichern von Informationen und zum Durchführen von Operationen an gespeicherten Informationen. Beim Arbeiten mit einer Programmiersprache wie Python werden Informationen in Variablen gespeichert. Sie können sich Variablen als Container zum Speichern von Daten vorstellen. Die in einer Variablen gespeicherten Daten werden als Wert bezeichnet.\nCode\nmy_favorite_color = \"blue\"\nCode\nmy_favorite_color\n\n\n'blue'\nEine Variable wird mit einer Zuweisungsanweisung erstellt, die mit dem Namen der Variablen beginnt, gefolgt vom Zuweisungsoperator = (anders als der Gleichheitsvergleichsoperator ==), gefolgt vom zu speichernden Wert innerhalb der Variablen.\nSie können in einer einzigen Anweisung auch Werte für mehrere Variablen angeben, indem Sie die Variablennamen und -werte durch Kommas trennen.\nCode\ncolor1, color2, color3 = \"red\", \"green\", \"blue\"\nCode\ncolor1\n\n\n'red'\nCode\ncolor2\n\n\n'green'\nCode\ncolor3\n\n\n'blue'\nSie können mehreren Variablen denselben Wert zuweisen, indem Sie mehrere Zuweisungsvorgänge in einer einzigen Anweisung verketten.\nCode\ncolor4 = color5 = color6 = \"magenta\"\nCode\ncolor4\n\n\n'magenta'\nCode\ncolor5\n\n\n'magenta'\nCode\ncolor6\n\n\n'magenta'\nSie können den in einer Variablen gespeicherten Wert einfach ändern, indem Sie ihr mithilfe einer anderen Zuweisungsanweisung einen neuen Wert zuweisen. Seien Sie beim Neuzuweisen von Variablen vorsichtig: Wenn Sie der Variablen einen neuen Wert zuweisen, geht der alte Wert verloren und ist nicht mehr zugänglich.\nCode\nmy_favorite_color = \"red\"\nCode\nmy_favorite_color\n\n\n'red'\nWährend Sie einer Variablen einen neuen Wert zuweisen, können Sie auch den vorherigen Wert der Variablen verwenden, um den neuen Wert zu bestimmen.\nCode\ncounter = 10\nCode\ncounter = counter + 1\nCode\ncounter\n\n\n11\nDas Muster var = var op x (wobei op ein arithmetischer Operator wie +, -, * oder / ist) wird sehr häufig verwendet.\nCode\ncounter = 10\nCode\n# Same as `counter = counter + 4`\ncounter += 4\nCode\ncounter\n\n\n14\nVariablennamen können kurz (a, x, y usw.) oder beschreibend (my_favorite_color, profit_margin usw.). Sie müssen jedoch beim Benennen von Python-Variablen die folgenden Regeln befolgen:\nHier sind einige gültige Variablennamen:\nCode\na_variable = 23\nis_today_Saturday = False\nmy_favorite_car = \"Delorean\"\nthe_3_musketeers = [\"Athos\", \"Porthos\", \"Aramis\"]\nVersuchen wir auch, einige Variablen mit ungültigen Namen zu erstellen. Python gibt einen Syntaxfehler aus, wenn der Name Ihrer Variablen ungültig ist.\nCode\na variable = 23\n\n\n\n  Cell In[20], line 1\n    a variable = 23\n      ^\nSyntaxError: invalid syntax\nCode\nis_today_$aturday = False\n\n\n\n  Cell In[21], line 1\n    is_today_$aturday = False\n             ^\nSyntaxError: invalid syntax\nCode\nmy-favorite-car = \"Delorean\"\n\n\n\n  Cell In[22], line 1\n    my-favorite-car = \"Delorean\"\n    ^\nSyntaxError: cannot assign to expression here. Maybe you meant '==' instead of '='?\nCode\n3_musketeers = [\"Athos\", \"Porthos\", \"Aramis\"]\n\n\n\n  Cell In[23], line 1\n    3_musketeers = [\"Athos\", \"Porthos\", \"Aramis\"]\n     ^\nSyntaxError: invalid decimal literal",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Eine kurze Tour durch Variablen und Datentypen in Python</span>"
    ]
  },
  {
    "objectID": "kapitel2.html#informationen-mithilfe-von-variablen-speichern",
    "href": "kapitel2.html#informationen-mithilfe-von-variablen-speichern",
    "title": "3  Eine kurze Tour durch Variablen und Datentypen in Python",
    "section": "",
    "text": "Der Name einer Variablen muss mit einem Buchstaben oder dem Unterstrichzeichen _ beginnen. Es darf nicht mit einer Zahl beginnen.\nEin Variablenname darf nur Klein- oder Großbuchstaben, Ziffern oder Unterstriche enthalten (a-z, A-Z, 0-9 und _).\nBei Variablennamen wird die Groß-/Kleinschreibung beachtet, d. h. a_variable, A_variable und A_VARIABLE sind allesamt unterschiedliche Variablen.\n\n\n\n\n\nSyntax: Die Syntax einer Programmiersprache bezieht sich auf die Regeln, die bestimmen, wie eine gültige Anweisung (ein Statement) in der Sprache aussehen soll. Wenn eine Anweisung diesen Regeln nicht entspricht, stoppt Python die Ausführung und informiert Sie darüber, dass ein Syntaxfehler vorliegt. Sie können sich Syntax als die Grammatikregeln einer Programmiersprache vorstellen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Eine kurze Tour durch Variablen und Datentypen in Python</span>"
    ]
  },
  {
    "objectID": "kapitel2.html#integrierte-datentypen-in-python",
    "href": "kapitel2.html#integrierte-datentypen-in-python",
    "title": "3  Eine kurze Tour durch Variablen und Datentypen in Python",
    "section": "3.2 Integrierte Datentypen in Python",
    "text": "3.2 Integrierte Datentypen in Python\nAlle in einer Python-Variablen gespeicherten Daten oder Informationen haben einen Datentyp. Der Datentyp der in einer Variablen gespeicherten Daten kann mit der Funktion type überprüft werden.\n\n\nCode\na_variable\n\n\n23\n\n\n\n\nCode\ntype(a_variable)\n\n\nint\n\n\n\n\nCode\nis_today_Saturday\n\n\nFalse\n\n\n\n\nCode\ntype(is_today_Saturday)\n\n\nbool\n\n\n\n\nCode\nmy_favorite_car\n\n\n'Delorean'\n\n\n\n\nCode\ntype(my_favorite_car)\n\n\nstr\n\n\n\n\nCode\nthe_3_musketeers\n\n\n['Athos', 'Porthos', 'Aramis']\n\n\n\n\nCode\ntype(the_3_musketeers)\n\n\nlist\n\n\nPython hat mehrere built-in Datentypen zur Speicherung verschiedener Arten von Informationen in Variablen. Hier sind einige häufig verwendete Datentypen:\n\nInteger\nFloat\nBoolean\nNone\nString\nList\nTuple\nDictionary\n\nInteger, Float, Boolean, None und String sind primitive Datentypen, weil sie einen einzelnen Wert darstellen. Andere Datentypen wie List, Tuple und Dictionary werden oft als Datenstrukturen oder Container bezeichnet, weil sie mehrere Daten zusammenhalten.\n\n\n3.2.1 Integer\nGanzzahlen stellen positive oder negative ganze Zahlen dar, von negativ unendlich bis unendlich. Beachten Sie, dass Ganzzahlen keine Dezimalstellen enthalten sollten. Ganzzahlen haben den Typ int.\n\n\nCode\ncurrent_year = 2020\n\n\n\n\nCode\ncurrent_year\n\n\n2020\n\n\n\n\nCode\ntype(current_year)\n\n\nint\n\n\nIm Gegensatz zu einigen anderen Programmiersprachen können ganze Zahlen in Python beliebig groß (oder klein) sein. Es gibt keinen niedrigsten oder höchsten Wert für Ganzzahlen und nur einen int Datentyp.\n\n\nCode\na_large_negative_number = -23374038374832934334234317348343\n\n\n\n\nCode\na_large_negative_number\n\n\n-23374038374832934334234317348343\n\n\n\n\nCode\ntype(a_large_negative_number)\n\n\nint\n\n\n\n\n\n3.2.2 Float\nFloats (oder Gleitkommazahlen) sind Zahlen mit einem Dezimalpunkt. Es gibt keine Begrenzung für den Wert einer Gleitkommazahl oder die Anzahl der Stellen vor oder nach dem Dezimalpunkt. Gleitkommazahlen haben den Datentyp float.\n\n\nCode\npi = 3.141592653589793238\n\n\n\n\nCode\npi\n\n\n3.141592653589793\n\n\n\n\nCode\ntype(pi)\n\n\nfloat\n\n\nBeachten Sie, dass eine ganze Zahl als Gleitkommazahl behandelt wird, wenn sie mit einem Dezimalpunkt geschrieben wird, auch wenn der Dezimalteil der Zahl Null ist.\n\n\nCode\na_number = 3.0\n\n\n\n\nCode\na_number\n\n\n3.0\n\n\n\n\nCode\ntype(a_number)\n\n\nfloat\n\n\n\n\nCode\nanother_number = 4.\n\n\n\n\nCode\nanother_number\n\n\n4.0\n\n\n\n\nCode\ntype(another_number)\n\n\nfloat\n\n\nGleitkommazahlen können auch in der wissenschaftlichen Schreibweise geschrieben werden, wobei ein „e“ die Zehnerpotenz angibt.\n\n\nCode\none_hundredth = 1e-2\n\n\n\n\nCode\none_hundredth\n\n\n0.01\n\n\n\n\nCode\ntype(one_hundredth)\n\n\nfloat\n\n\n\n\nCode\navogadro_number = 6.02214076e23\n\n\n\n\nCode\navogadro_number\n\n\n6.02214076e+23\n\n\n\n\nCode\ntype(avogadro_number)\n\n\nfloat\n\n\nFloats können mit den Funktionen float und int in Ganzzahlen umgewandelt werden und umgekehrt. Die Umwandlung in einen anderen Datentyp wird als Casting bezeichnet.\n\n\nCode\nfloat(current_year)\n\n\n2020.0\n\n\n\n\nCode\na_large_negative_number\n\n\n-23374038374832934334234317348343\n\n\n\n\nCode\nfloat(a_large_negative_number)\n\n\n-2.3374038374832935e+31\n\n\n\n\nCode\nint(pi)\n\n\n3\n\n\n\n\nCode\nint(avogadro_number)\n\n\n602214075999999987023872\n\n\nBei der Durchführung arithmetischer Operationen werden Ganzzahlen automatisch in Gleitkommazahlen umgewandelt, wenn einer der Operanden eine Gleitkommazahl ist. Außerdem gibt der Divisionsoperator / immer eine Gleitkommazahl zurück, auch wenn beide Operanden Ganzzahlen sind. Verwenden Sie den Operator //, wenn das Ergebnis der Division ein int sein soll.\n\n\nCode\ntype(45 * 3.0)\n\n\nfloat\n\n\n\n\nCode\ntype(45 * 3)\n\n\nint\n\n\n\n\nCode\ntype(10/3)\n\n\nfloat\n\n\n\n\nCode\ntype(10/2)\n\n\nfloat\n\n\n\n\nCode\ntype(10//2)\n\n\nint\n\n\n\n\nCode\ntype(11//2)\n\n\nint\n\n\n\n\n\n3.2.3 Boolean\nBoolesche Werte stellen einen von zwei Werten dar: True und False. Boolesche Werte haben den Datentyp bool.\n\n\nCode\nis_today_Sunday = True\n\n\n\n\nCode\nis_today_Sunday\n\n\nTrue\n\n\n\n\nCode\ntype(is_today_Saturday)\n\n\nbool\n\n\nBoolesche Werte werden im Allgemeinen als Ergebnis einer Vergleichsoperation zurückgegeben (z. B. ==, &gt;= usw.).\n\n\nCode\ncost_of_ice_bag = 1.25\nis_ice_bag_expensive = cost_of_ice_bag &gt;= 10\n\n\n\n\nCode\nis_ice_bag_expensive\n\n\nFalse\n\n\n\n\nCode\ntype(is_ice_bag_expensive)\n\n\nbool\n\n\nBoolesche Werte werden bei der Verwendung in arithmetischen Operationen automatisch in int umgewandelt. True wird in 1 umgewandelt und False wird in 0 umgewandelt.\n\n\nCode\n5 + False\n\n\n5\n\n\n\n\nCode\n3. + True\n\n\n4.0\n\n\nJeder Wert in Python kann mit der bool Funktion in einen Boolean umgewandelt werden.\nNur die folgenden Werte ergeben False (sie werden oft als falsy Werte bezeichnet):\n\nDer Wert False selbst\nDie ganze Zahl 0\nDie Fließkommazahl 0.0\nDer leere Wert None\nDer leere Text \"\"\nDie leere Liste []\nDas leere Tupel ()\nDas leere Wörterbuch {}\nDie leere Menge set()\nDer leere Bereich range(0)\n\nAlles andere ergibt True (ein Wert, der zu True ausgewertet wird, wird oft als truthy Wert bezeichnet).\n\n\nCode\nbool(False)\n\n\nFalse\n\n\n\n\nCode\nbool(0)\n\n\nFalse\n\n\n\n\nCode\nbool(0.0)\n\n\nFalse\n\n\n\n\nCode\nbool(None)\n\n\nFalse\n\n\n\n\nCode\nbool(\"\")\n\n\nFalse\n\n\n\n\nCode\nbool([])\n\n\nFalse\n\n\n\n\nCode\nbool(())\n\n\nFalse\n\n\n\n\nCode\nbool({})\n\n\nFalse\n\n\n\n\nCode\nbool(set())\n\n\nFalse\n\n\n\n\nCode\nbool(range(0))\n\n\nFalse\n\n\n\n\nCode\nbool(True), bool(1), bool(2.0), bool(\"hello\"), bool([1,2]), bool((2,3)), bool(range(10))\n\n\n(True, True, True, True, True, True, True)\n\n\n\n\n\n3.2.4 None\nDer None-Typ enthält einen einzigen Wert None, der dazu dient, das Fehlen eines Wertes anzuzeigen. None hat den Typ NoneType. Es wird oft verwendet, um eine Variable zu deklarieren, deren Wert später zugewiesen werden kann.\n\n\nCode\nnothing = None\n\n\n\n\nCode\ntype(nothing)\n\n\nNoneType\n\n\n\n\n\n3.2.5 String\nEine Zeichenfolge wird verwendet, um Text (eine Zeichenfolge) in Python darzustellen. Zeichenfolgen müssen in Anführungszeichen gesetzt werden (entweder das einfache Anführungszeichen ' oder das doppelte Anführungszeichen “). Zeichenfolgen haben den Datentyp str.\n\n\nCode\ntoday = \"Saturday\"\n\n\n\n\nCode\ntoday\n\n\n'Saturday'\n\n\n\n\nCode\ntype(today)\n\n\nstr\n\n\nSie können einfache Anführungszeichen innerhalb einer mit doppelten Anführungszeichen geschriebenen Zeichenfolge verwenden und umgekehrt.\n\n\nCode\nmy_favorite_movie = \"One Flew over the Cuckoo's Nest\" \n\n\n\n\nCode\nmy_favorite_movie\n\n\n\"One Flew over the Cuckoo's Nest\"\n\n\n\n\nCode\nmy_favorite_pun = 'Thanks for explaining the word \"many\" to me, it means a lot.'\n\n\n\n\nCode\nmy_favorite_pun\n\n\n'Thanks for explaining the word \"many\" to me, it means a lot.'\n\n\nUm ein doppeltes Anführungszeichen innerhalb einer mit doppelten Anführungszeichen geschriebenen Zeichenfolge zu verwenden, maskieren Sie die inneren Anführungszeichen, indem Sie ihnen das Zeichen \\ voranstellen.\n\n\nCode\nanother_pun = \"The first time I got a universal remote control, I thought to myself \\\"This changes everything\\\".\"\n\n\n\n\nCode\nanother_pun\n\n\n'The first time I got a universal remote control, I thought to myself \"This changes everything\".'\n\n\nMit einfachen oder doppelten Anführungszeichen erstellte strings müssen in derselben Zeile beginnen und enden. Um mehrzeilige strings zu erstellen, verwenden Sie drei einfache Anführungszeichen ''' oder drei doppelte Anführungszeichen “““, um den string zu beginnen und zu beenden. Zeilenumbrüche werden durch das Zeilenumbruchzeichen \\n dargestellt.\n\n\nCode\nyet_another_pun = '''Son: \"Dad, can you tell me what a solar eclipse is?\" \nDad: \"No sun.\"'''\n\n\n\n\nCode\nyet_another_pun\n\n\n'Son: \"Dad, can you tell me what a solar eclipse is?\" \\nDad: \"No sun.\"'\n\n\nMehrzeilige Zeichenfolgen werden am besten mit der Funktion print angezeigt.\n\n\nCode\nprint(yet_another_pun)\n\n\nSon: \"Dad, can you tell me what a solar eclipse is?\" \nDad: \"No sun.\"\n\n\n\n\nCode\na_music_pun = \"\"\"\nTwo windmills are standing in a field and one asks the other, \n\"What kind of music do you like?\"  \n\nThe other says, \n\"I'm a big metal fan.\"\n\"\"\"\n\n\n\n\nCode\nprint(a_music_pun)\n\n\n\nTwo windmills are standing in a field and one asks the other, \n\"What kind of music do you like?\"  \n\nThe other says, \n\"I'm a big metal fan.\"\n\n\n\nSie können die Länge einer Zeichenfolge mit der Funktion len überprüfen.\n\n\nCode\nlen(my_favorite_movie)\n\n\n31\n\n\nBeachten Sie, dass Sonderzeichen wie \\n und Escapezeichen wie \\\" als ein einzelnes Zeichen zählen, auch wenn sie als zwei Zeichen geschrieben und manchmal ausgegeben werden.\n\n\nCode\nmultiline_string = \"\"\"a\nb\"\"\"\nmultiline_string\n\n\n'a\\nb'\n\n\n\n\nCode\nlen(multiline_string)\n\n\n3\n\n\nMit der Funktion list kann eine Zeichenfolge in eine Liste von Zeichen umgewandelt werden.\n\n\nCode\nlist(multiline_string)\n\n\n['a', '\\n', 'b']\n\n\nStrings unterstützen auch mehrere Listenoperationen, die im nächsten Abschnitt besprochen werden. Wir werden uns hier einige Beispiele ansehen.\nMit der Indexierungsnotation [] können Sie auf einzelne Zeichen innerhalb einer Zeichenfolge zugreifen. Beachten Sie, dass die Zeichenindizes von 0 bis n-1 reichen, wobei n die Länge der Zeichenfolge ist.\n\n\nCode\ntoday = \"Saturday\"\n\n\n\n\nCode\ntoday[0]\n\n\n'S'\n\n\n\n\nCode\ntoday[3]\n\n\n'u'\n\n\n\n\nCode\ntoday[7]\n\n\n'y'\n\n\nSie können auf einen Teil einer Zeichenfolge zugreifen, indem Sie einen Start:End-Bereich anstelle eines einzelnen Indexes in [] angeben.\n\n\nCode\ntoday[5:8]\n\n\n'day'\n\n\nSie können auch mit dem „in“-Operator überprüfen, ob eine Zeichenfolge Text enthält.\n\n\nCode\n'day' in today\n\n\nTrue\n\n\n\n\nCode\n'Sun' in today\n\n\nFalse\n\n\nZwei oder mehr Zeichenfolgen können mit dem Operator + verbunden oder verkettet werden. Seien Sie beim Verketten von Zeichenfolgen vorsichtig. Manchmal müssen Sie möglicherweise ein Leerzeichen \" \" zwischen Wörtern einfügen.\n\n\nCode\nfull_name = \"Derek O'Brien\"\n\n\n\n\nCode\ngreeting = \"Hello\"\n\n\n\n\nCode\ngreeting + full_name\n\n\n\"HelloDerek O'Brien\"\n\n\n\n\nCode\ngreeting + \" \" + full_name + \"!\" # additional space\n\n\n\"Hello Derek O'Brien!\"\n\n\nStrings in Python verfügen über viele integrierte Methoden, mit denen sie manipuliert werden können. Probieren wir einige gängige String-Methoden aus.\n\nMethoden: Methoden sind Funktionen, die Datentypen zugeordnet sind und auf die mit der „.“-Notation zugegriffen wird, z. B. variable_name.method() oder \"a string\".method(). Methoden sind eine leistungsstarke Technik, um allgemeine Vorgänge mit Werten bestimmter Datentypen zu verknüpfen.\n\nDie Methoden .lower(), .upper() und .capitalize() werden verwendet, um die Groß-/Kleinschreibung der Zeichen zu ändern.\n\n\nCode\ntoday.lower()\n\n\n'saturday'\n\n\n\n\nCode\n\"saturday\".upper()\n\n\n'SATURDAY'\n\n\n\n\nCode\n\"monday\".capitalize() # changes first character to uppercase\n\n\n'Monday'\n\n\nDie Methode .replace wird verwendet, um einen Teil der Zeichenfolge durch eine andere Zeichenfolge zu ersetzen. Der zu ersetzende Teil und der Ersetzungstext werden als Eingaben oder Argumente angenommen.\n\n\nCode\nanother_day = today.replace(\"Satur\", \"Wednes\")\n\n\n\n\nCode\nanother_day\n\n\n'Wednesday'\n\n\nBeachten Sie, dass eine neue Zeichenfolge zurückgegeben wird und die ursprüngliche Zeichenfolge nicht geändert wird.\n\n\nCode\ntoday\n\n\n'Saturday'\n\n\nDie Methode .split kann verwendet werden, um eine Zeichenfolge anhand der bereitgestellten Zeichen in eine Liste von Zeichenfolgen aufzuteilen.\n\n\nCode\n\"Sun,Mon,Tue,Wed,Thu,Fri,Sat\".split(\",\")\n\n\n['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\n\n\nDie .strip Methode wird verwendet, um Leerzeichen am Anfang und Ende einer Zeichenfolge zu entfernen.\n\n\nCode\na_long_line = \"       This is a long line with some space before, after,     and some space in the middle..    \"\n\n\n\n\nCode\na_long_line_stripped = a_long_line.strip()\n\n\n\n\nCode\na_long_line_stripped\n\n\n'This is a long line with some space before, after,     and some space in the middle..'\n\n\nDie Methode .format wird verwendet, um Werte anderer Datentypen zu kombinieren, z. Ganzzahlen, Gleitkommazahlen, Boolesche Werte, Listen usw. mit Zeichenfolgen. Es wird häufig zum Erstellen von Ausgabemeldungen zur Anzeige verwendet.\n\n\nCode\n# Input variables\ncost_of_ice_bag = 1.25\nprofit_margin = .2\nnumber_of_bags = 500\n\n# Template for output message\noutput_template = \"\"\"If a grocery store sells ice bags at $ {} per bag, with a profit margin of {} %, \nthen the total profit it makes by selling {} ice bags is $ {}.\"\"\"\n\nprint(output_template)\n\n\nIf a grocery store sells ice bags at $ {} per bag, with a profit margin of {} %, \nthen the total profit it makes by selling {} ice bags is $ {}.\n\n\n\n\nCode\n# Inserting values into the string\ntotal_profit = cost_of_ice_bag * profit_margin * number_of_bags\noutput_message = output_template.format(cost_of_ice_bag, profit_margin*100, number_of_bags, total_profit)\n\nprint(output_message)\n\n\nIf a grocery store sells ice bags at $ 1.25 per bag, with a profit margin of 20.0 %, \nthen the total profit it makes by selling 500 ice bags is $ 125.0.\n\n\nBeachten Sie, wie die Platzhalter {} in der Zeichenfolge output_template durch die Argumente ersetzt werden, die der Methode .format bereitgestellt werden.\nEs ist auch möglich, den String-Verkettungsoperator + zu verwenden, um Strings mit anderen Werten zu kombinieren. Diese Werte müssen jedoch zuerst mit der Funktion str in Strings konvertiert werden.\n\n\nCode\n\"If a grocery store sells ice bags at $ \" + cost_of_ice_bag + \", with a profit margin of \" + profit_margin\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[126], line 1\n----&gt; 1 \"If a grocery store sells ice bags at $ \" + cost_of_ice_bag + \", with a profit margin of \" + profit_margin\n\nTypeError: can only concatenate str (not \"float\") to str\n\n\n\n\n\nCode\n\"If a grocery store sells ice bags at $ \" + str(cost_of_ice_bag) + \", with a profit margin of \" + str(profit_margin)\n\n\nTatsächlich kann str verwendet werden, um einen Wert eines beliebigen Datentyps in einen String umzuwandeln.\n\n\nCode\nstr(23)\n\n\n\n\nCode\nstr(23.432)\n\n\n'23.432'\n\n\n\n\nCode\nstr(True)\n\n\n'True'\n\n\n\n\nCode\nthe_3_musketeers = [\"Athos\", \"Porthos\", \"Aramis\"]\nstr(the_3_musketeers)\n\n\n\"['Athos', 'Porthos', 'Aramis']\"\n\n\nBeachten Sie, dass alle Zeichenfolgenmethoden neue Werte zurückgeben und die vorhandene Zeichenfolge NICHT ändern. Eine vollständige Liste der String-Methoden finden Sie hier.\nStrings unterstützen auch die Vergleichsoperatoren == und !=, um zu prüfen, ob zwei Strings gleich sind\n\n\nCode\nfirst_name = \"John\"\n\n\n\n\nCode\nfirst_name == \"Doe\"\n\n\nFalse\n\n\n\n\nCode\nfirst_name == \"John\"\n\n\nTrue\n\n\n\n\nCode\nfirst_name != \"Jane\"\n\n\nTrue\n\n\n\n\n\n3.2.6 List\nEine Liste in Python ist eine geordnete Sammlung von Werten. Listen können Werte unterschiedlicher Datentypen enthalten und Vorgänge zum Hinzufügen, Entfernen und Ändern von Werten unterstützen. Listen haben den Typ list.\nUm eine Liste zu erstellen, schließen Sie eine Werteliste in eckige Klammern [ und ] ein, getrennt durch Kommas.\n\n\nCode\nfruits = ['apple', 'banana', 'cherry']\n\n\n\n\nCode\nfruits\n\n\n['apple', 'banana', 'cherry']\n\n\n\n\nCode\ntype(fruits)\n\n\nlist\n\n\nVersuchen wir, eine Liste mit Werten verschiedener Datentypen zu erstellen, einschließlich einer anderen Liste.\n\n\nCode\na_list = [23, 'hello', None, 3.14, fruits, 3 &lt;= 5]\n\n\n\n\nCode\na_list\n\n\n[23, 'hello', None, 3.14, ['apple', 'banana', 'cherry'], True]\n\n\n\n\nCode\nempty_list = []\n\n\n\n\nCode\nempty_list\n\n\n[]\n\n\nUm die Anzahl der Werte in einer Liste zu bestimmen, verwenden Sie die Funktion len. Im Allgemeinen kann die Funktion len zur Bestimmung von Werten in mehreren anderen Datentypen verwendet werden.\n\n\nCode\nlen(fruits)\n\n\n3\n\n\n\n\nCode\nprint(\"Number of fruits:\", len(fruits))\n\n\nNumber of fruits: 3\n\n\n\n\nCode\nlen(a_list)\n\n\n6\n\n\n\n\nCode\nlen(empty_list)\n\n\n0\n\n\nSie können auf die Elemente einer Liste zugreifen, indem Sie den Index des Elements verwenden, beginnend mit dem Index 0.\n\n\nCode\nfruits[0]\n\n\n'apple'\n\n\n\n\nCode\nfruits[1]\n\n\n'banana'\n\n\n\n\nCode\nfruits[2]\n\n\n'cherry'\n\n\nWenn Sie versuchen, auf einen Index zuzugreifen, der gleich oder größer als die Länge der Liste ist, gibt Python einen IndexError zurück.\n\n\nCode\nfruits[3]\n\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[145], line 1\n----&gt; 1 fruits[3]\n\nIndexError: list index out of range\n\n\n\n\n\nCode\nfruits[4]\n\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[146], line 1\n----&gt; 1 fruits[4]\n\nIndexError: list index out of range\n\n\n\n\n\nCode\nfruits[-1]\n\n\n'cherry'\n\n\n\n\nCode\nfruits[-2]\n\n\n'banana'\n\n\n\n\nCode\nfruits[-3]\n\n\n'apple'\n\n\n\n\nCode\nfruits[-4]\n\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[150], line 1\n----&gt; 1 fruits[-4]\n\nIndexError: list index out of range\n\n\n\nSie können auch über die Liste auf einen Wertebereich zugreifen. Das Ergebnis ist selbst eine Liste. Schauen wir uns einige Beispiele an.\n\n\nCode\na_list = [23, 'hello', None, 3.14, fruits, 3 &lt;= 5]\n\n\n\n\nCode\na_list\n\n\n[23, 'hello', None, 3.14, ['apple', 'banana', 'cherry'], True]\n\n\n\n\nCode\nlen(a_list)\n\n\n6\n\n\n\n\nCode\na_list[2:5]\n\n\n[None, 3.14, ['apple', 'banana', 'cherry']]\n\n\nBeachten Sie, dass der Startindex (2 im obigen Beispiel) des Bereichs in der Liste enthalten ist, der Endindex (5 im obigen Beispiel) jedoch nicht. Das Ergebnis hat also 3 Werte (Indizes 2,3 und 4).\n\nDie flexible und interaktive Natur von Jupyter-Notebooks macht sie zu einem großartigen Werkzeug für Lernen und Experimentieren. Die meisten Fragen, die beim ersten Erlernen von Python auftauchen, können einfach durch Eingabe des Codes in eine Zelle und Ausführung desselben gelöst werden. Lassen Sie Ihrer Neugier freien Lauf und entdecken Sie, was mit Python möglich ist und was nicht!\n\nSie können den Wert an einem bestimmten Index innerhalb einer Liste auch mithilfe der Zuweisungsoperation ändern.\n\n\nCode\nfruits\n\n\n['apple', 'banana', 'cherry']\n\n\n\n\nCode\nfruits[1] = 'blueberry'\n\n\n\n\nCode\nfruits\n\n\n['apple', 'blueberry', 'cherry']\n\n\nMit der Methode append kann am Ende einer Liste ein neuer Wert hinzugefügt werden.\n\n\nCode\nfruits.append('dates')\n\n\n\n\nCode\nfruits\n\n\n['apple', 'blueberry', 'cherry', 'dates']\n\n\nEin neuer Wert kann auch mit der Methode insert in einen bestimmten Index eingefügt werden.\n\n\nCode\nfruits.insert(1, 'banana')\n\n\n\n\nCode\nfruits\n\n\n['apple', 'banana', 'blueberry', 'cherry', 'dates']\n\n\nSie können einen Wert mit der Methode remove aus der Liste entfernen.\n\n\nCode\nfruits.remove('blueberry')\n\n\n\n\nCode\nfruits\n\n\n['apple', 'banana', 'cherry', 'dates']\n\n\nWas passiert, wenn eine Liste mehrere Instanzen des an .remove übergebenen Werts enthält?\n\n\nCode\nfruits.remove\n\n\n&lt;function list.remove(value, /)&gt;\n\n\n\n\nCode\nfruits\n\n\n['apple', 'banana', 'cherry', 'dates']\n\n\nUm ein Element aus einem bestimmten Index zu entfernen, verwenden Sie die Methode pop. Die Methode gibt auch das entfernte Element zurück.\n\n\nCode\nfruits\n\n\n['apple', 'banana', 'cherry', 'dates']\n\n\n\n\nCode\nfruits.pop(1)\n\n\n'banana'\n\n\n\n\nCode\nfruits\n\n\n['apple', 'cherry', 'dates']\n\n\nWenn kein Index bereitgestellt wird, entfernt die Methode pop das letzte Element der Liste.\n\n\nCode\nfruits.pop()\n\n\n'dates'\n\n\n\n\nCode\nfruits\n\n\n['apple', 'cherry']\n\n\nMit dem in-Operator können Sie testen, ob eine Liste einen Wert enthält.\n\n\nCode\n'pineapple' in fruits\n\n\nFalse\n\n\n\n\nCode\n'cherry' in fruits\n\n\nTrue\n\n\nUm zwei oder mehr Listen zu kombinieren, verwenden Sie den Operator +. Dieser Vorgang wird auch Verkettung (concatenation) genannt.\n\n\nCode\nfruits\n\n\n['apple', 'cherry']\n\n\n\n\nCode\nmore_fruits = fruits + ['pineapple', 'tomato', 'guava'] + ['dates', 'banana']\n\n\n\n\nCode\nmore_fruits\n\n\n['apple', 'cherry', 'pineapple', 'tomato', 'guava', 'dates', 'banana']\n\n\nUm eine Kopie einer Liste zu erstellen, verwenden Sie die Methode copy. Das Ändern der kopierten Liste hat keine Auswirkungen auf die ursprüngliche Liste.\n\n\nCode\nmore_fruits_copy = more_fruits.copy()\n\n\n\n\nCode\nmore_fruits_copy\n\n\n['apple', 'cherry', 'pineapple', 'tomato', 'guava', 'dates', 'banana']\n\n\n\n\nCode\n# Modify the copy\nmore_fruits_copy.remove('pineapple')\nmore_fruits_copy.pop()\nmore_fruits_copy\n\n\n['apple', 'cherry', 'tomato', 'guava', 'dates']\n\n\n\n\nCode\n# Original list remains unchanged\nmore_fruits\n\n\n['apple', 'cherry', 'pineapple', 'tomato', 'guava', 'dates', 'banana']\n\n\nBeachten Sie, dass Sie keine Kopie einer Liste erstellen können, indem Sie einfach eine neue Variable mit dem Zuweisungsoperator = erstellen. Die neue Variable verweist auf dieselbe Liste und alle mit einer Variablen vorgenommenen Änderungen wirken sich auf die andere aus.\n\n\nCode\nmore_fruits\n\n\n['apple', 'cherry', 'pineapple', 'tomato', 'guava', 'dates', 'banana']\n\n\n\n\nCode\nmore_fruits_not_a_copy = more_fruits\n\n\n\n\nCode\nmore_fruits_not_a_copy.remove('pineapple')\nmore_fruits_not_a_copy.pop()\n\n\n'banana'\n\n\n\n\nCode\nmore_fruits_not_a_copy\n\n\n['apple', 'cherry', 'tomato', 'guava', 'dates']\n\n\n\n\nCode\nmore_fruits\n\n\n['apple', 'cherry', 'tomato', 'guava', 'dates']\n\n\nGenau wie bei Strings gibt es mehrere integrierte Methoden zum Bearbeiten einer Liste. Im Gegensatz zu Zeichenfolgen ändern die meisten Listenmethoden jedoch die ursprüngliche Liste, anstatt eine neue zurückzugeben. Schauen Sie sich hier einige gängige Listenoperationen an.\n\n\n\n3.2.7 Tuple\nEin Tupel ist eine geordnete Sammlung von Werten, ähnlich einer Liste, jedoch ist es nicht möglich, Werte in einem Tupel hinzuzufügen, zu entfernen oder zu ändern. Ein Tupel wird erstellt, indem Werte in Klammern ( und ), getrennt durch Kommas, eingeschlossen werden.\n\nJede Datenstruktur, die nach der Erstellung nicht mehr verändert werden kann, wird als unveränderlich bezeichnet. Sie können Tupel als unveränderliche Listen betrachten.\n\nLassen Sie uns einige Experimente mit Tupeln durchführen.\n\n\nCode\nfruits = ('apple', 'cherry', 'dates')\n\n\n\n\nCode\n# check no. of elements\nlen(fruits)\n\n\n3\n\n\n\n\nCode\n# get an element (positive index)\nfruits[0]\n\n\n'apple'\n\n\n\n\nCode\n# get an element (negative index)\nfruits[-2]\n\n\n'cherry'\n\n\n\n\nCode\n# check if it contains an element\n'dates' in fruits\n\n\nTrue\n\n\n\n\nCode\n# try to change an element\nfruits[0] = 'avocado'\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[190], line 2\n      1 # try to change an element\n----&gt; 2 fruits[0] = 'avocado'\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\n\nCode\n# try to append an element\nfruits.append('blueberry')\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[191], line 2\n      1 # try to append an element\n----&gt; 2 fruits.append('blueberry')\n\nAttributeError: 'tuple' object has no attribute 'append'\n\n\n\n\n\nCode\n# try to remove an element\nfruits.remove('apple')\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[192], line 2\n      1 # try to remove an element\n----&gt; 2 fruits.remove('apple')\n\nAttributeError: 'tuple' object has no attribute 'remove'\n\n\n\nSie können beim Erstellen eines Tupels auch die Klammern ( und ) überspringen. Python wandelt durch Kommas getrennte Werte automatisch in ein Tupel um.\n\n\nCode\nthe_3_musketeers = 'Athos', 'Porthos', 'Aramis'\n\n\n\n\nCode\nthe_3_musketeers\n\n\n('Athos', 'Porthos', 'Aramis')\n\n\nSie können ein Tupel auch mit nur einem Element erstellen, wenn Sie nach dem Element ein Komma einfügen. Wenn Sie es einfach mit den Klammern ( und ) umschließen, wird kein Tupel erstellt.\n\n\nCode\nsingle_element_tuple = 4,\n\n\n\n\nCode\nsingle_element_tuple\n\n\n(4,)\n\n\n\n\nCode\nanother_single_element_tuple = (4,)\n\n\n\n\nCode\nanother_single_element_tuple\n\n\n(4,)\n\n\n\n\nCode\nnot_a_tuple = (4)\n\n\n\n\nCode\nnot_a_tuple\n\n\n4\n\n\nTupel werden oft verwendet, um mehrere Variablen mit einer einzigen Anweisung zu erstellen.\n\n\nCode\npoint = (3, 4)\n\n\n\n\nCode\npoint_x, point_y = point\n\n\n\n\nCode\npoint_x\n\n\n3\n\n\n\n\nCode\npoint_y\n\n\n4\n\n\nSie können eine Liste mit der Funktion tuple in ein Tupel umwandeln und umgekehrt mit der Funktion list.\n\n\nCode\ntuple(['one', 'two', 'three'])\n\n\n('one', 'two', 'three')\n\n\n\n\nCode\nlist(('Athos', 'Porthos', 'Aramis'))\n\n\n['Athos', 'Porthos', 'Aramis']\n\n\nTupel haben nur zwei integrierte Methoden: count und index. Es gibt eine einfache Möglichkeit, die Dokumentation einer Methode mithilfe der help Funktion zu überprüfen.\n\n\nCode\na_tuple = 23, \"hello\", False, None, 23, 37, \"hello\"\n\n\n\n\nCode\nhelp(a_tuple.count)\n\n\nHelp on built-in function count:\n\ncount(value, /) method of builtins.tuple instance\n    Return number of occurrences of value.\n\n\n\nIn einem Jupyter-Notizbuch können Sie eine Codezelle auch mit „?“ beginnen und den Namen einer Funktion oder Methode eingeben. Wenn Sie diese Zelle ausführen, wird die Dokumentation für die Funktion/Methode in einem Popup-Fenster angezeigt.\n\n\nCode\n?a_tuple.index\n\n\n\n\n\n3.2.8 Dictionary\nEin Dictionary ist eine ungeordnete Sammlung von Elementen. Jedes in einem Dictionary gespeicherte Element hat einen Schlüssel und einen Wert. Schlüssel werden verwendet, um Werte aus dem Dictionary abzurufen. Dictionaries haben den Typ dict.\nDictionaries werden oft verwendet, um viele Informationen, z.B. Details über eine Person, in einer einzigen Variable zu speichern. Dictionaries werden erstellt, indem Schlüssel-Wert-Paare in geschweiften Klammern { und } eingeschlossen werden.\n\n\nCode\nperson1 = {\n    'name': 'John Doe',\n    'sex': 'Male',\n    'age': 32,\n    'married': True\n}\n\n\n\n\nCode\nperson1\n\n\n{'name': 'John Doe', 'sex': 'Male', 'age': 32, 'married': True}\n\n\nDictionaries können auch mit der Funktion dict erstellt werden.\n\n\nCode\nperson2 = dict(name='Jane Judy', sex='Female', age=28, married=False)\n\n\n\n\nCode\nperson2\n\n\n{'name': 'Jane Judy', 'sex': 'Female', 'age': 28, 'married': False}\n\n\n\n\nCode\ntype(person1)\n\n\ndict\n\n\nSchlüssel können verwendet werden, um auf Werte zuzugreifen, die die eckigen Klammern [ und ] verwenden.\n\n\nCode\nperson1['name']\n\n\n'John Doe'\n\n\n\n\nCode\nperson1['married']\n\n\nTrue\n\n\n\n\nCode\nperson2['name']\n\n\n'Jane Judy'\n\n\nWenn ein Schlüssel nicht im Dictionary vorhanden ist, wird ein KeyError zurückgegeben.\n\n\nCode\nperson1['address']\n\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[218], line 1\n----&gt; 1 person1['address']\n\nKeyError: 'address'\n\n\n\nDie Methode get kann auch verwendet werden, um auf den mit einem Schlüssel verknüpften Wert zuzugreifen.\n\n\nCode\nperson2.get(\"name\")\n\n\n'Jane Judy'\n\n\nDie Methode get akzeptiert auch einen Standardwert, der zurückgegeben wird, wenn der Schlüssel nicht im Dictionary vorhanden ist.\n\n\nCode\nperson2.get(\"address\", \"Unknown\")\n\n\n'Unknown'\n\n\nMit dem in Operator können Sie überprüfen, ob ein Schlüssel in einem Dictionary vorhanden ist.\n\n\nCode\n'name' in person1\n\n\nTrue\n\n\n\n\nCode\n'address' in person1\n\n\nFalse\n\n\nSie können den einem Schlüssel zugeordneten Wert mithilfe des Zuweisungsoperators ändern.\n\n\nCode\nperson2['married']\n\n\nFalse\n\n\n\n\nCode\nperson2['married'] = True\n\n\n\n\nCode\nperson2['married']\n\n\nTrue\n\n\nDer Zuweisungsoperator kann auch verwendet werden, um dem Dictionary neue Schlüssel-Wert-Paare hinzuzufügen.\n\n\nCode\nperson1\n\n\n{'name': 'John Doe', 'sex': 'Male', 'age': 32, 'married': True}\n\n\n\n\nCode\nperson1['address'] = '1, Penny Lane'\n\n\n\n\nCode\nperson1\n\n\n{'name': 'John Doe',\n 'sex': 'Male',\n 'age': 32,\n 'married': True,\n 'address': '1, Penny Lane'}\n\n\nUm einen Schlüssel und den zugehörigen Wert aus einem Dictionary zu entfernen, verwenden Sie die Methode pop.\n\n\nCode\nperson1.pop('address')\n\n\n'1, Penny Lane'\n\n\n\n\nCode\nperson1\n\n\n{'name': 'John Doe', 'sex': 'Male', 'age': 32, 'married': True}\n\n\nDictonaries bieten auch Methoden zum Anzeigen der Liste der darin enthaltenen Schlüssel, Werte oder Schlüssel-Wert-Paare.\n\n\nCode\nperson1.keys()\n\n\ndict_keys(['name', 'sex', 'age', 'married'])\n\n\n\n\nCode\nperson1.values()\n\n\ndict_values(['John Doe', 'Male', 32, True])\n\n\n\n\nCode\nperson1.items()\n\n\ndict_items([('name', 'John Doe'), ('sex', 'Male'), ('age', 32), ('married', True)])\n\n\n\n\nCode\nperson1.items()[1]\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[234], line 1\n----&gt; 1 person1.items()[1]\n\nTypeError: 'dict_items' object is not subscriptable\n\n\n\nDas Ergebnis der Funktionen keys, values oder items sieht zwar aus wie Listen, unterstützt aber anscheinend nicht den Indexoperator [] zum Abrufen von Elementen.\nDictionaries bieten viele weitere Methoden. Mehr darüber erfahren Sie hier.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Eine kurze Tour durch Variablen und Datentypen in Python</span>"
    ]
  },
  {
    "objectID": "kapitel2.html#weiterführende-literatur",
    "href": "kapitel2.html#weiterführende-literatur",
    "title": "3  Eine kurze Tour durch Variablen und Datentypen in Python",
    "section": "3.3 Weiterführende Literatur",
    "text": "3.3 Weiterführende Literatur\nWir haben unsere Untersuchung von Variablen und gängigen Datentypen in Python nun abgeschlossen. Im Folgenden finden Sie einige Ressourcen, um mehr über Datentypen in Python zu erfahren:\n\nOffizielle Python-Dokumentation\nPython-Tutorial bei W3Schools\nPraktische Python-Programmierung",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Eine kurze Tour durch Variablen und Datentypen in Python</span>"
    ]
  },
  {
    "objectID": "kapitel3.html",
    "href": "kapitel3.html",
    "title": "4  Verzweigungen mit bedingten Anweisungen und Schleifen in Python",
    "section": "",
    "text": "4.1 Verzweigungen mit if, else und elif\nDieses Tutorial ist das dritte einer Reihe zur Einführung in die Programmierung und Datenanalyse mit der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\nDie folgenden Themen werden in diesem Tutorial behandelt:\nEine wirklich mächtige Funktion von Programmiersprachen ist Verzweigung: die Fähigkeit, Entscheidungen zu treffen und abhängig davon, ob eine oder mehrere Bedingungen wahr sind, einen anderen Satz von Anweisungen auszuführen.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verzweigungen mit bedingten Anweisungen und Schleifen in Python</span>"
    ]
  },
  {
    "objectID": "kapitel3.html#verzweigungen-mit-if-else-und-elif",
    "href": "kapitel3.html#verzweigungen-mit-if-else-und-elif",
    "title": "4  Verzweigungen mit bedingten Anweisungen und Schleifen in Python",
    "section": "",
    "text": "4.1.1 Die if Anweisung\nIn Python wird die Verzweigung mit der if Anweisung durchgeführt, die folgendermaßen geschrieben wird:\nif Bedingung:\n    Anweisung1\n    Anweisung2\nDie Bedingung kann entweder eine Variable oder ein Ausdruck sein. Wenn die Bedingung zu True auswertet, dann werden die Anweisungen innerhalb des if-Blocks ausgeführt. Beachte die 4 Leerzeichen vor Anweisung1, Anweisung2 usw. Die Leerzeichen informieren Python, dass diese Anweisungen mit der darüber liegenden if Anweisung in Verbindung stehen. Diese Technik, den Code durch Hinzufügen von Leerzeichen zu strukturieren, wird Einrückung genannt.\n\nEinrückung: Python stützt sich stark auf Einrückungen (indentation) (Leerraum vor einer Anweisung) um die Struktur im Code zu definieren. Das macht den Python-Code leicht zu lesen und zu verstehen, aber du kannst auf Probleme stoßen, wenn du die Einrückung nicht richtig verwendest. Rücke deinen Code ein, indem du den Cursor am Anfang der Zeile platzierst und einmal die Tab Taste drückst, um 4 Leerzeichen hinzuzufügen. Wenn du Tab noch einmal drückst, wird der Code um weitere 4 Leerzeichen eingerückt, und durch Drücken von Shift+Tab wird die Einrückung um 4 Leerzeichen reduziert.\n\nAls Beispiel schreiben wir einen Code, um eine Nachricht auszugeben, wenn eine gegebene Zahl gerade ist.\n\n\nCode\na_number = 34\n\n\n\n\nCode\nif a_number % 2 == 0:\n    print(\"We're inside an if block\")\n    print('The given number {} is even.'.format(a_number))\n\n\nWe're inside an if block\nThe given number 34 is even.\n\n\nBeachte, dass wir den Modulus-Operator % verwenden, um den Rest der Division von a_number durch 2 zu finden, und dann den Vergleichsoperator == verwenden, um zu überprüfen, ob der Rest 0 ist, was darauf hinweist, dass die Zahl durch 2 teilbar ist, also gerade ist.\nDa die Zahl 34 tatsächlich durch 2 teilbar ist, ergibt der Ausdruck a_number % 2 == 0 den Wert True, sodass die print Anweisung unter der if Anweisung ausgeführt wird. Beachte auch, dass wir die String format Methode verwenden, um die Zahl in die Nachricht einzufügen.\nVersuchen wir das oben Gesagte erneut mit einer ungeraden Zahl.\n\n\nCode\nanother_number = 33\n\n\n\n\nCode\nif another_number % 2 == 0:\n    print('The given number {} is even.'.format(a_number))\n\n\nDa die Bedingung another_number % 2 == 0 erwartungsgemäß False ergibt, wird keine Meldung ausgegeben.\n\n\n4.1.2 Die else Anweisung\nWenn die Zahl im obigen Beispiel nicht gerade ist, möchten wir ebenfalls eine Meldung ausgeben. Dies kann durch Hinzufügen der else-Anweisung erfolgen.\nif condition:\n    statement1\n    statement2\nelse:\n    statement4\n    statement5\nWenn die Bedingung True ergibt, werden die Anweisungen im if-Block ausgeführt, und wenn sie False ergibt, werden die Anweisungen im else-Block ausgeführt.\n\n\nCode\na_number = 34\n\n\n\n\nCode\nif a_number % 2 == 0:\n    print('The given number {} is even.'.format(a_number))\nelse:\n    print('The given number {} is odd.'.format(a_number))\n\n\nThe given number 34 is even.\n\n\n\n\nCode\nanother_number = 33\n\n\n\n\nCode\nif another_number % 2 == 0:\n    print('The given number {} is even.'.format(another_number))\nelse:\n    print('The given number {} is odd.'.format(another_number))\n\n\nThe given number 33 is odd.\n\n\nHier ist ein weiteres Beispiel, das den in-Operator verwendet, um die Existenz innerhalb eines Tupels zu überprüfen.\n\n\nCode\nthe_3_musketeers = ('Athos', 'Porthos', 'Aramis')\n\n\n\n\nCode\na_candidate = \"D'Artagnan\"\n\n\n\n\nCode\nif a_candidate in the_3_musketeers:\n    print(\"{} is a musketeer\".format(a_candidate))\nelse:\n    print(\"{} is not a musketeer\".format(a_candidate))\n\n\nD'Artagnan is not a musketeer\n\n\n\n\n4.1.3 Die elif Anweisung\nPython bietet auch eine elif Anweisung (kurz für “else if”), um eine Reihe von bedingten Blöcken zu verketten. Die Bedingungen werden nacheinander ausgewertet. Für die erste Bedingung, die True ergibt, werden die Anweisungen im jeweiligen Block ausgeführt und die restlichen Bedingungen werden nicht ausgewertet. So wird in einer Kette von if, elif, elif… Anweisungen genau ein bedingter Block ausgewertet.\n\n\nCode\ntoday = 'Wednesday'\n\n\n\n\nCode\nif today == 'Sunday':\n    print(\"Today is the day of the sun.\")\nelif today == 'Monday':\n    print(\"Today is the day of the moon.\")\nelif today == 'Tuesday':\n    print(\"Today is the day of Tyr, the god of war.\")\nelif today == 'Wednesday':\n    print(\"Today is the day of Odin, the supreme diety.\")\nelif today == 'Thursday':\n    print(\"Today is the day of Thor, the god of thunder.\")\nelif today == 'Friday':\n    print(\"Today is the day of Frigga, the goddess of beauty.\")\nelif today == 'Saturday':\n    print(\"Today is the day of Saturn, the god of fun and feasting.\")\n\n\nToday is the day of Odin, the supreme diety.\n\n\nIm obigen Beispiel werden die ersten drei Bedingungen als False ausgewertet, sodass keine der ersten drei Nachrichten ausgegeben wird. Die vierte Bedingung wird mit True ausgewertet, sodass die entsprechende Meldung ausgegeben wird. Die übrigen Bedingungen werden übersprungen. Versuchen Sie, den Wert von today oben zu ändern und die Zellen erneut auszuführen, um alle verschiedenen Nachrichten zu auszugeben.\nUm zu überprüfen, ob die übrigen Bedingungen übersprungen werden, versuchen wir es mit einem anderen Beispiel.\n\n\nCode\na_number = 15\n\n\n\n\nCode\nif a_number % 2 == 0:\n    print('{} is divisible by 2'.format(a_number))\nelif a_number % 3 == 0:\n    print('{} is divisible by 3'.format(a_number))\nelif a_number % 5 == 0:\n    print('{} is divisible by 5'.format(a_number))\nelif a_number % 7 == 0:\n    print('{} is divisible by 7'.format(a_number))\n\n\n15 is divisible by 3\n\n\nBeachten Sie, dass die Nachricht 15 is divisible by 5 nicht ausgegeben wird, weil die Bedingung a_number % 5 == 0 nicht ausgewertet wird, da die vorherige Bedingung a_number % 3 == 0 zu True auswertet. Dies ist der entscheidende Unterschied zwischen einer Kette von if, elif, elif… Anweisungen und einfach einer Kette von if Anweisungen, bei denen jede Bedingung unabhängig ausgewertet wird.\n\n\nCode\nif a_number % 2 == 0:\n    print('{} is divisible by 2'.format(a_number))\nif a_number % 3 == 0:\n    print('{} is divisible by 3'.format(a_number))\nif a_number % 5 == 0:\n    print('{} is divisible by 5'.format(a_number))\nif a_number % 7 == 0:\n    print('{} is divisible by 7'.format(a_number))\n\n\n15 is divisible by 3\n15 is divisible by 5\n\n\n\n\n4.1.4 Gemeinsame Verwendung von if, elif und else.\nSie können auch eine else-Anweisung am Ende einer Kette von if, elif…-Anweisungen einfügen. Dieser Code im else-Block wird ausgewertet, wenn keine der Bedingungen zutrifft.\n\n\nCode\na_number = 49\n\n\n\n\nCode\nif a_number % 2 == 0:\n    print('{} is divisible by 2'.format(a_number))\nelif a_number % 3 == 0:\n    print('{} is divisible by 3'.format(a_number))\nelif a_number % 5 == 0:\n    print('{} is divisible by 5'.format(a_number))\nelse:\n    print('All checks failed!')\n    print('{} is not divisible by 2, 3 or 5'.format(a_number))\n\n\nAll checks failed!\n49 is not divisible by 2, 3 or 5\n\n\nBedingungen können auch mit den logischen Operatoren and, or und not kombiniert werden.\n\n\nCode\na_number = 15\n\n\n\n\nCode\nif a_number % 3 == 0 and a_number % 5 == 0:\n    print(\"The number {} is divisible by 3 and 5\".format(a_number))\nelif not a_number % 5 == 0:\n    print(\"The number {} is not divisible by 5\".format(a_number))\n\n\nThe number 15 is divisible by 3 and 5\n\n\n\n\n4.1.5 Nicht-Boolesche Bedingungen\nBeachten Sie, dass Bedingungen nicht unbedingt boolesche Werte sein müssen. Tatsächlich kann eine Bedingung einen beliebigen Wert haben. Der Wert wird mithilfe des bool Operators automatisch in einen booleschen Wert umgewandelt. Das bedeutet, dass falsche Werte wie 0, '', {}, [] usw. als False und alle anderen Werte als True ausgewertet werden.\n\n\nCode\nif '':\n    print('The condition evaluted to True')\nelse:\n    print('The condition evaluted to False')\n\n\nThe condition evaluted to False\n\n\n\n\nCode\nif 'Hello':\n    print('The condition evaluted to True')\nelse:\n    print('The condition evaluted to False')\n\n\nThe condition evaluted to True\n\n\n\n\nCode\nif { 'a': 34 }:\n    print('The condition evaluted to True')\nelse:\n    print('The condition evaluted to False')\n\n\nThe condition evaluted to True\n\n\n\n\nCode\nif None:\n    print('The condition evaluted to True')\nelse:\n    print('The condition evaluted to False')\n\n\nThe condition evaluted to False\n\n\n\n\n4.1.6 Verschachtelte bedingte Anweisungen\nDer Code in einem if-Block kann auch eine if Anweisung enthalten. Dieses Muster wird Verschachtelung (nesting) genannt und wird verwendet, wenn Sie nach einer anderen Bedingung suchen müssen, nachdem eine bestimmte Bedingung als wahr bewertet wurde.\n\n\nCode\na_number = 15\n\n\n\n\nCode\nif a_number % 2 == 0:\n    print(\"{} is even\".format(a_number))\n    if a_number % 3 == 0:\n        print(\"{} is also divisible by 3\".format(a_number))\n    else:\n        print(\"{} is not divisibule by 3\".format(a_number))\nelse:\n    print(\"{} is odd\".format(a_number))\n    if a_number % 5 == 0:\n        print(\"{} is also divisible by 5\".format(a_number))\n    else:\n        print(\"{} is not divisibule by 5\".format(a_number))\n\n\n15 is odd\n15 is also divisible by 5\n\n\nBeachten Sie, dass die print Anweisungen um 8 Leerzeichen eingerückt sind, um anzuzeigen, dass sie Teil der inneren if/else Blöcke sind.\n\nVerschachtelte if- und else-Anweisungen sind oft verwirrend zu lesen und anfällig für menschliches Versagen. Es empfiehlt sich, die Verschachtelung nach Möglichkeit zu vermeiden oder die Verschachtelung auf 1 oder 2 Ebenen zu beschränken.\n\n\n\n4.1.7 Abkürzung für den bedingten Ausdruck if\nEin häufiger Anwendungsfall der if-Anweisung besteht darin, eine Bedingung zu testen und den Wert einer Variablen basierend auf der Bedingung festzulegen.\n\n\nCode\na_number = 13\n\nif a_number % 2 == 0:\n    parity = 'even'\nelse:\n    parity = 'odd'\n\nprint('The number {} is {}.'.format(a_number, parity))\n\n\nThe number 13 is odd.\n\n\nPython bietet eine kürzere Syntax, die das Schreiben solcher Bedingungen in einer einzigen Codezeile ermöglicht. Es ist als bedingter Ausdruck bekannt, manchmal auch als ternärer Operator. Es hat die folgende Syntax:\nx = true_value if condition else false_value\nEs hat das gleiche Verhalten wie der folgende if-else-Block:\nif condition:\n    x = true_value\nelse:\n    x = false_value\nProbieren wir es am Beispiel oben aus.\n\n\nCode\nparity = 'even' if a_number % 2 == 0 else 'odd'\n\n\n\n\nCode\nprint('The number {} is {}.'.format(a_number, parity))\n\n\nThe number 13 is odd.\n\n\n\n\n4.1.8 Anweisungen und Ausdrücke\nDer bedingte Ausdruck unterstreicht eine wichtige Unterscheidung zwischen Anweisungen und Ausdrücken in Python.\n\nAnweisungen: Eine Anweisung (statement) ist eine ausführbare Anweisung. Jede Zeile Code, die wir bisher geschrieben haben, ist eine Anweisung, z. B. das Zuweisen einer Variable, das Aufrufen einer Funktion, bedingte Anweisungen mit if, else und elif, Schleifen mit for und while usw.\n\n\nAusdrücke: Ein Ausdruck (expression) ist ein Code, der zu einem Wert ausgewertet wird. Beispiele sind Werte verschiedener Datentypen, arithmetische Ausdrücke, Bedingungen, Variablen, Funktionsaufrufe, bedingte Ausdrücke usw.\n\nDie meisten Ausdrücke können als Anweisungen ausgeführt werden, aber nicht alle Anweisungen sind Ausdrücke. Zum Beispiel ist die if-Anweisung kein Ausdruck, da sie nicht zu einem Wert ausgewertet wird, sie führt einfach nur eine Verzweigung im Code aus. Ähnlich verhält es sich mit Schleifen und Funktionsdefinitionen, die keine Ausdrücke sind (wir werden in späteren Abschnitten mehr darüber lernen).\nAls Faustregel gilt: Ein Ausdruck ist alles, was auf der rechten Seite des Zuweisungsoperators = erscheinen kann. Sie können dies als Test verwenden, um zu überprüfen, ob etwas ein Ausdruck ist oder nicht. Sie erhalten einen Syntaxfehler, wenn Sie versuchen, etwas zuzuweisen, das kein Ausdruck ist.\n\n\nCode\n# if statement\nresult = if a_number % 2 == 0: \n    'even'\nelse:\n    'odd'\n\n\n\n  Cell In[30], line 2\n    result = if a_number % 2 == 0:\n             ^\nSyntaxError: invalid syntax\n\n\n\n\n\n\nCode\n# if expression\nresult = 'even' if a_number % 2 == 0 else 'odd'\n\n\n\n\n4.1.9 Die pass Anweisung\nif Anweisungen können nicht leer sein, es muss mindestens eine Anweisung in jedem if und elif Block geben. Sie können die pass Anweisung verwenden, um nichts zu tun und einen Fehler zu vermeiden.\n\n\nCode\na_number = 9\n\n\n\n\nCode\nif a_number % 2 == 0:\nelif a_number % 3 == 0:\n    print('{} is divisible by 3 but not divisible by 2')\n\n\n\n  Cell In[33], line 2\n    elif a_number % 3 == 0:\n    ^\nIndentationError: expected an indented block after 'if' statement on line 1\n\n\n\n\n\n\nCode\nif a_number % 2 == 0:\n    pass\nelif a_number % 3 == 0:\n    print('{} is divisible by 3 but not divisible by 2'.format(a_number))\n\n\n9 is divisible by 3 but not divisible by 2",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verzweigungen mit bedingten Anweisungen und Schleifen in Python</span>"
    ]
  },
  {
    "objectID": "kapitel3.html#iteration-mit-while-schleifen",
    "href": "kapitel3.html#iteration-mit-while-schleifen",
    "title": "4  Verzweigungen mit bedingten Anweisungen und Schleifen in Python",
    "section": "4.2 Iteration mit while Schleifen",
    "text": "4.2 Iteration mit while Schleifen\n\n4.2.1 Grundlagen\nEine weitere leistungsstarke Funktion von Programmiersprachen, die eng mit Verzweigungen verbunden ist, ist die Fähigkeit, eine oder mehrere Anweisungen mehrmals auszuführen. Diese Funktion wird oft als Iteration oder Schleifenbildung bezeichnet, und es gibt zwei Möglichkeiten, dies in Python zu tun: Mit while Schleifen und for Schleifen.\nwhile Schleifen haben die folgende Syntax:\nwhile Bedingung:\n    Anweisung(en)\nDie Anweisungen im Block unter while werden wiederholt ausgeführt, solange die Bedingung zu True ausgewertet wird. In den meisten Fällen bewirkt der Block von Anweisungen eine Änderung einer Variablen, die dazu führt, dass die Bedingung nach einer bestimmten Anzahl von Iterationen zu False ausgewertet wird.\nVersuchen wir als Beispiel, die Fakultät von 100 mit einer while Schleife zu berechnen. Die Fakultät einer Zahl n ist definiert als das Produkt oder die Multiplikation aller Zahlen von 1 bis n, also 1*2*3*...*(n-2)*(n-1)*n.\n\n\nCode\nresult = 1\ni = 1\n\nwhile i &lt;= 100:\n    result = result * i\n    i = i+1\n\nprint('The factorial of 100 is: {}'.format(result))\n\n\nThe factorial of 100 is: 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000\n\n\nSo funktioniert der obige Code:\n\nWir initialisieren zwei Variablen result und i. result enthält das endgültige Ergebnis der Berechnung. Und i wird verwendet, um die nächste zu result zu multiplizierende Zahl zu verfolgen. Beide werden auf 1 initialisiert (können Sie erklären warum?)\nDie Bedingung i&lt;=100 gilt als wahr (da i zunächst 1 ist), daher werden die Anweisungen im Block unter while ausgeführt.\nDas result wird auf result * i aktualisiert, und i wird um 1 erhöht und hat nun den Wert 2.\nAn diesem Punkt wird die Bedingung i&lt;=100 erneut ausgeführt, und da sie weiterhin als wahr gilt, wird das result erneut auf result * i aktualisiert und i wird auf 3 erhöht.\nDieser Prozess wird wiederholt, bis die Bedingung falsch wird, was passiert, wenn i den Wert 101 hat. Sobald die Bedingung zu False ausgewertet wird, endet die Ausführung der Schleife und die darunter liegende print Anweisung wird ausgeführt.\n\nKönnen Sie sehen, warum result am Ende der Schleife den Wert der Fakultät von 100 hat? Wenn nicht, versuchen Sie, print Anweisungen innerhalb der Schleife hinzuzufügen, um die Werte von result und i am Ende jeder Schleife auszugeben.\n\nIteration ist eine wirklich mächtige Technik, denn sie gibt Computern einen großen Vorteil gegenüber Menschen, wenn es darum geht, Hunderte oder Millionen von wiederholten Operationen sehr schnell auszuführen. Mit nur 4-5 Zeilen Code konnten wir fast sofort 100 Zahlen multiplizieren. Was noch interessanter ist, ist, dass der gleiche Code verwendet werden kann, um tausend Zahlen zu multiplizieren (ändern Sie einfach die Bedingung auf i &lt;= 1000) in nur wenigen Sekunden.\n\nSie können überprüfen, wie lange eine Zelle zur Ausführung braucht, indem Sie den speziellen magic Befehl %%time an den Anfang einer Zelle setzen. Versuchen Sie zu überprüfen, wie lange es dauert, die Fakultät von 100, 1000, 10000, 100000 usw. zu berechnen.\n\n\nCode\n%%time\n\nresult = 1\ni = 1\n\nwhile i &lt;= 1000:\n    result *= i # same as result = result * i\n    i += 1 # same as i = i+1\n\nprint(result)\n\n\n402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\nCPU times: user 956 µs, sys: 82 µs, total: 1.04 ms\nWall time: 1.06 ms\n\n\nHier ist ein weiteres Beispiel, das zwei while-Schleifen verwendet, um ein interessantes Muster zu erstellen.\n\n\nCode\nline = '*'\nmax_length = 10\n\nwhile len(line) &lt;= max_length:\n    print(line)\n    line += \"*\"\n    \nwhile len(line) &gt; 0:\n    print(line)\n    line = line[:-1]\n\n\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\n***********\n**********\n*********\n********\n*******\n******\n*****\n****\n***\n**\n*\n\n\n\n\n4.2.2 Endlosschleifen\nWenn die Bedingung in einer while-Schleife immer wahr ist, führt Python den Code innerhalb der Schleife immer wieder aus und die Ausführung des Codes wird nie abgeschlossen. Diese Situation wird als Endlosschleife bezeichnet und weist im Allgemeinen darauf hin, dass Sie einen Fehler in Ihrem Code gemacht haben, z. B. Verwenden der falschen Bedingung oder Vergessen, eine Variable mit einer Schleife zu aktualisieren, wodurch die Bedingung letztendlich falsch wird.\nWenn Ihr Code während der Ausführung in einer Endlosschleife stecken bleibt, klicken Sie einfach auf die Schaltfläche Stop in der Symbolleiste (neben Run) oder wählen Sie Kernel &gt; Interrupt aus der Jupyter-Menüleiste, um die Ausführung zu stoppen bzw unterbricht die Ausführung des Codes. Die nächsten beiden Zellen führen beide zu Endlosschleifen und müssen unterbrochen werden.\n\n\nCode\n# INFINITE LOOP - INTERRUPT THIS CELL\n\nresult = 1\ni = 1\n\nwhile i &lt;= 100:\n    result = result * i\n    # forgot to increment i\n\n\n\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In[38], line 6\n      3 result = 1\n      4 i = 1\n----&gt; 6 while i &lt;= 100:\n      7     result = result * i\n\nKeyboardInterrupt: \n\n\n\n\n\nCode\n# INFINITE LOOP - INTERRUPT THIS CELL\n\nresult = 1\ni = 1\n\nwhile i &gt; 0 : # wrong condition\n    result *= i\n    i += 1\n\n\n\n\n4.2.3 break- und continue-Anweisungen\nSie können die break-Anweisung im Hauptteil der Schleife verwenden, um die Ausführung sofort zu stoppen und die Schleife zu break zu verlassen (auch wenn die für while angegebene Bedingung immer noch wahr ist).\n\n\nCode\ni = 1\nresult = 1\n\nwhile i &lt;= 100:\n    result *= i\n    if i == 42:\n        print('Magic number 42 reached! Stopping execution..')\n        break\n    i += 1\n    \nprint('i:', i)\nprint('result:', result)\n\n\nMagic number 42 reached! Stopping execution..\ni: 42\nresult: 1405006117752879898543142606244511569936384000000000\n\n\nWie Sie oben sehen können, beträgt der Wert von i am Ende der Ausführung 42. Dieses Beispiel zeigt auch, wie Sie eine if-Anweisung innerhalb einer while-Schleife verwenden können.\nManchmal möchten Sie vielleicht nicht die gesamte Schleife beenden, sondern einfach die verbleibenden Anweisungen in der Schleife überspringen und weiter zur nächsten Schleife gehen. Dies können Sie mit der continue-Anweisung erreichen.\n\n\nCode\ni = 1\nresult = 1\n\nwhile i &lt; 20:\n    i += 1\n    if i % 2 == 0:\n        print('Skipping {}'.format(i))\n        continue\n    print('Multiplying with {}'.format(i))\n    result = result * i\n    \nprint('i:', i)\nprint('result:', result)\n\n\nSkipping 2\nMultiplying with 3\nSkipping 4\nMultiplying with 5\nSkipping 6\nMultiplying with 7\nSkipping 8\nMultiplying with 9\nSkipping 10\nMultiplying with 11\nSkipping 12\nMultiplying with 13\nSkipping 14\nMultiplying with 15\nSkipping 16\nMultiplying with 17\nSkipping 18\nMultiplying with 19\nSkipping 20\ni: 20\nresult: 654729075\n\n\nIm obigen Beispiel wird die letzte Anweisung der Schleife result = result * i übersprungen, wenn i gerade ist, wie durch die während der Ausführung ausgegebenen Meldungen angezeigt.\n\nLogging: Der Vorgang des Hinzufügens von print-Anweisungen an verschiedenen Punkten im Code (oft innerhalb von Schleifen und bedingten Anweisungen) zur Überprüfung der Werte von Variablen in verschiedenen Ausführungsstadien wird als Logging bezeichnet. Da unsere Programme mit zunehmender Komplexität naturgemäß anfällig für menschliche Fehler werden, kann Logging dabei helfen, zu überprüfen, ob das Programm wie erwartet funktioniert. In vielen Fällen werden print-Anweisungen hinzugefügt, während Code geschrieben und getestet wird, und am Ende wieder entfernt.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verzweigungen mit bedingten Anweisungen und Schleifen in Python</span>"
    ]
  },
  {
    "objectID": "kapitel3.html#iteration-mit-for-schleifen",
    "href": "kapitel3.html#iteration-mit-for-schleifen",
    "title": "4  Verzweigungen mit bedingten Anweisungen und Schleifen in Python",
    "section": "4.3 Iteration mit for Schleifen",
    "text": "4.3 Iteration mit for Schleifen\n\n4.3.1 Grundlagen\nEin for-Loop wird zum Iterieren oder Schleifen über Sequenzen verwendet, d.h. Listen, Tupel, Wörterbücher, Strings und Ranges. For-Schleifen haben die folgende Syntax:\nfor value in sequence:\n    statement(s)\nDie Anweisungen innerhalb der Schleife werden einmal für jedes Element in Sequenz ausgeführt. Hier ist ein Beispiel, das alle Elemente einer Liste ausgibt.\n\n\nCode\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\nfor day in days:\n    print(day)\n\n\nMonday\nTuesday\nWednesday\nThursday\nFriday\n\n\nVersuchen wir, for Schleifen mit einigen anderen Datentypen zu verwenden.\n\n\nCode\n# Looping over a string\nfor char in 'Monday':\n    print(char)\n\n\nM\no\nn\nd\na\ny\n\n\n\n\nCode\n# Looping over a tuple\nfor fruit in ['Apple', 'Banana', 'Guava']:\n    print(\"Here's a fruit:\", fruit)\n\n\nHere's a fruit: Apple\nHere's a fruit: Banana\nHere's a fruit: Guava\n\n\n\n\nCode\n# Looping over a dictionary\nperson = {\n    'name': 'John Doe',\n    'sex': 'Male',\n    'age': 32,\n    'married': True\n}\n\nfor key in person:\n    print(\"Key:\", key, \",\", \"Value:\", person[key])\n\n\nKey: name , Value: John Doe\nKey: sex , Value: Male\nKey: age , Value: 32\nKey: married , Value: True\n\n\nBeachten Sie, dass bei der Verwendung eines Dictionaries mit einer for-Schleife die Iteration über Schlüssel(keys) im Dictionary erfolgt. Der Schlüssel kann innerhalb der Schleife verwendet werden, um auf den Wert zuzugreifen. Sie können auch direkt über die Werte mit der .values Methode des Dictionaries iterieren, oder über Schlüssel-Wert-Paare mit der .items Methode.\n\n\nCode\nfor value in person.values():\n    print(value)\n\n\nJohn Doe\nMale\n32\nTrue\n\n\n\n\nCode\nfor key_value_pair in person.items():\n    print(key_value_pair)\n\n\n('name', 'John Doe')\n('sex', 'Male')\n('age', 32)\n('married', True)\n\n\nDa es sich bei einem Schlüssel-Wert-Paar um ein Tupel handelt, können wir Schlüssel und Wert auch in separate Variablen extrahieren.\n\n\nCode\nfor key, value in person.items():\n    print(\"Key:\", key, \",\", \"Value:\", value)\n\n\nKey: name , Value: John Doe\nKey: sex , Value: Male\nKey: age , Value: 32\nKey: married , Value: True\n\n\n\n\n4.3.2 Iterieren mit range und enumerate.\nDie range Funktion wird verwendet, um eine Sequenz von Zahlen zu erzeugen, über die mit einer for-Schleife iteriert werden kann. Sie kann auf 3 Arten verwendet werden:\n\nrange(n) - Erstellt eine Sequenz von Zahlen von 0 bis n-1\nrange(a, b) - Erstellt eine Sequenz von Zahlen von a bis b-1\nrange(a, b, step) - Erstellt eine Sequenz von Zahlen von a bis b-1 mit Schritten von step\n\nLassen Sie es uns ausprobieren.\n\n\nCode\nfor i in range(7):\n    print(i)\n\n\n0\n1\n2\n3\n4\n5\n6\n\n\n\n\nCode\nfor i in range(3, 10):\n    print(i)\n\n\n3\n4\n5\n6\n7\n8\n9\n\n\nUm Inkremente einer bestimmten Länge durchzuführen, verwenden Sie das dritte Argument in range(), z. B. range(3, 14, 4). Dies führt zu einer Schleife von 3 bis 13 in Schritten von 4\n\n\nCode\nfor i in range(3, 14, 4): \n    print(i)\n\n\n3\n7\n11\n\n\nBereiche werden für die Iteration über Listen verwendet, wenn Sie während der Iteration den Index von Elementen verfolgen müssen.\n\n\nCode\na_list = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\nfor i in range(len(a_list)):\n    print('The value at position {} is {}.'.format(i, a_list[i]))\n\n\nThe value at position 0 is Monday.\nThe value at position 1 is Tuesday.\nThe value at position 2 is Wednesday.\nThe value at position 3 is Thursday.\nThe value at position 4 is Friday.\n\n\nEine andere Möglichkeit, das gleiche Ergebnis wie oben zu erzielen, ist die Verwendung der Funktion enumerate mit a_list als Eingabe, die ein Tupel zurückgibt, das den Index und das entsprechende Element enthält.\n\n\nCode\nfor i, val in enumerate(a_list):\n    print('The value at position {} is {}.'.format(i, val))\n\n\nThe value at position 0 is Monday.\nThe value at position 1 is Tuesday.\nThe value at position 2 is Wednesday.\nThe value at position 3 is Thursday.\nThe value at position 4 is Friday.\n\n\n\n\n4.3.3 break-, continue- und pass-Anweisungen\nÄhnlich wie while-Schleifen unterstützen for-Schleifen auch die Anweisung break, um aus der Schleife auszubrechen, und continue, um zur nächsten Iteration zu springen.\n\n\nCode\nweekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n\n\n\nCode\nfor day in weekdays:\n    print('Today is {}'.format(day))\n    if (day == 'Wednesday'):\n        print(\"I don't work beyond Wednesday!\")\n        break\n\n\nToday is Monday\nToday is Tuesday\nToday is Wednesday\nI don't work beyond Wednesday!\n\n\n\n\nCode\nfor day in weekdays:\n    if (day == 'Wednesday'):\n        print(\"I don't work on Wednesday!\")\n        continue\n    print('Today is {}'.format(day))\n\n\nToday is Monday\nToday is Tuesday\nI don't work on Wednesday!\nToday is Thursday\nToday is Friday\n\n\nÄhnlich wie if-Anweisungen dürfen for-Schleifen nicht leer sein. Sie können also eine pass-Anweisung verwenden, falls Sie keine Anweisungen innerhalb der Schleife ausführen möchten.\n\n\nCode\nfor day in weekdays:\n    pass\n\n\n\n\n4.3.4 Verschachtelte for- und while-Schleifen\nÄhnlich wie bedingte Anweisungen können Schleifen in anderen Schleifen verschachtelt werden. Dies ist nützlich, um jedes Element in einer Liste von Listen, einer Liste von Wörterbüchern usw. zu durchlaufen.\n\n\nCode\npersons = [{'name': 'John', 'sex': 'Male'}, {'name': 'Jane', 'sex': 'Female'}]\n\nfor person in persons:\n    for key in person:\n        print(key, \":\", person[key])\n    print(\" \")\n\n\nname : John\nsex : Male\n \nname : Jane\nsex : Female\n \n\n\n\n\nCode\ndays = ['Monday', 'Tuesday', 'Wednesday']\nfruits = ['apple', 'banana', 'guava']\n\nfor day in days:\n    for fruit in fruits:\n        print(day, fruit)\n\n\nMonday apple\nMonday banana\nMonday guava\nTuesday apple\nTuesday banana\nTuesday guava\nWednesday apple\nWednesday banana\nWednesday guava",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verzweigungen mit bedingten Anweisungen und Schleifen in Python</span>"
    ]
  },
  {
    "objectID": "kapitel3.html#weiterführende-literatur-und-referenzen",
    "href": "kapitel3.html#weiterführende-literatur-und-referenzen",
    "title": "4  Verzweigungen mit bedingten Anweisungen und Schleifen in Python",
    "section": "4.4 Weiterführende Literatur und Referenzen",
    "text": "4.4 Weiterführende Literatur und Referenzen\nIm Folgenden finden Sie einige Ressourcen, um mehr über bedingte Anweisungen und Schleifen in Python zu erfahren:\n\nPython-Tutorial bei W3Schools\nPraktische Python-Programmierung\nOffizielle Python-Dokumentation",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verzweigungen mit bedingten Anweisungen und Schleifen in Python</span>"
    ]
  },
  {
    "objectID": "kapitel4.html",
    "href": "kapitel4.html",
    "title": "5  Schreiben von wiederverwendbarem Code mithilfe von Funktionen",
    "section": "",
    "text": "5.1 Funktionen erstellen und verwenden\nDieses Tutorial ist das vierte in einer Reihe zur Einführung in die Programmierung und Datenanalyse mit der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\nDie folgenden Themen werden in diesem Tutorial behandelt:",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Schreiben von wiederverwendbarem Code mithilfe von Funktionen</span>"
    ]
  },
  {
    "objectID": "kapitel4.html#funktionen-erstellen-und-verwenden",
    "href": "kapitel4.html#funktionen-erstellen-und-verwenden",
    "title": "5  Schreiben von wiederverwendbarem Code mithilfe von Funktionen",
    "section": "",
    "text": "5.1.1 Grundlagen\nEine Funktion ist ein wiederverwendbarer Satz von Anweisungen. Eine Funktion nimmt eine oder mehrere Eingaben entgegen, führt bestimmte Operationen aus und gibt häufig eine Ausgabe zurück. Python bietet viele integrierte Funktionen wie print und ermöglicht Ihnen auch die Definition eigener Funktionen.\n\n\nCode\ntoday = \"Saturday\"\nprint(\"Today is\", today)\n\n\nToday is Saturday\n\n\nSie können eine neue Funktion mit dem Keyword def definieren.\n\n\nCode\ndef say_hello():\n    print('Hello there!')\n    print('How are you?')\n\n\nBeachten Sie die runden Klammern oder Parenthesen () und den Doppelpunkt : nach dem Namen der Funktion. Beide sind wesentliche Teile der Syntax zur Definition einer Funktion. Der Körper der Funktion kann eine oder mehrere Anweisungen enthalten, die ausgeführt werden sollen, wenn die Funktion aufgerufen wird. Ähnlich wie bei bedingten Anweisungen und Schleifen, müssen die Anweisungen durch 4 Leerzeichen eingerückt werden.\nDie Anweisungen im Körper einer Funktion werden nicht ausgeführt, wenn eine Funktion definiert wird. Um die Anweisungen auszuführen, müssen wir die Funktion aufrufen oder aktivieren.\n\n\nCode\nsay_hello()\n\n\nHello there!\nHow are you?\n\n\n\n\n5.1.2 Funktionsargumente\nFunktionen können auch einen oder mehrere Werte als Eingaben akzeptieren (auch bekannt als Argumente oder Parameter). Argumente helfen uns, flexible Funktionen zu schreiben, die dieselbe Operation für verschiedene Werte ausführen können. Darüber hinaus können Funktionen mit dem Keyword return auch einen Wert als Ergebnis zurückgeben, der in einer Variablen gespeichert oder in anderen Ausdrücken verwendet werden kann.\nHier ist eine Funktion, die die geraden Zahlen aus einer Liste herausfiltert.\n\n\nCode\ndef filter_even(number_list):\n    result_list = []\n    for number in number_list:\n        if number % 2 == 0:\n            result_list.append(number)\n    return result_list\n\n\nKönnen Sie anhand des Codes verstehen, was die Funktion bewirkt? Wenn nicht, versuchen Sie, jede Zeile der Funktion innerhalb einer Codezelle mit einer Liste von Zahlen als number_list auszuführen.\n\n\nCode\neven_list = filter_even([1, 2, 3, 4, 5, 6, 7])\n\n\n\n\nCode\neven_list\n\n\n[2, 4, 6]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Schreiben von wiederverwendbarem Code mithilfe von Funktionen</span>"
    ]
  },
  {
    "objectID": "kapitel4.html#erstellen-von-funktionen-in-python",
    "href": "kapitel4.html#erstellen-von-funktionen-in-python",
    "title": "5  Schreiben von wiederverwendbarem Code mithilfe von Funktionen",
    "section": "5.2 Erstellen von Funktionen in Python",
    "text": "5.2 Erstellen von Funktionen in Python\nAls Programmierer verbringen Sie den Großteil Ihrer Zeit mit dem Schreiben und Verwenden von Funktionen, und Python bietet viele Funktionen, um Ihre Funktionen leistungsstark und flexibel zu gestalten. Lassen Sie uns einige davon untersuchen, indem wir ein Problem lösen:\n\nRadha plant den Kauf eines Hauses, das 1.260.000 Dollar kostet. Sie erwägt zwei Optionen zur Finanzierung ihres Kaufs:\n\nOption 1: Sofortige Anzahlung von 300.000 Dollar und einen 8-jährigen Kredit mit einem Zinssatz von 10% pro Jahr (monatlich zusammengesetzt) für den verbleibenden Betrag.\nOption 2: Ein 10-jähriger Kredit mit einem Zinssatz von 8% (monatlich zusammengesetzt) für den gesamten Betrag.\n\nBeide Kredite müssen in gleichen monatlichen Raten (EMIs) zurückgezahlt werden. Welcher Kredit hat unter den beiden die niedrigere EMI?\n\nDa wir die EMIs für zwei Kreditoptionen vergleichen müssen, könnte es hilfreich sein, eine Funktion zu definieren, die die EMI für einen Kredit berechnet, unter Berücksichtigung von Eingaben wie den Kosten des Hauses, der Anzahlung, der Dauer des Kredits, dem Zinssatz usw. Wir werden diese Funktion Schritt für Schritt aufbauen.\nBeginnen wir mit einer einfachen Funktion, die die EMI für die gesamten Kosten des Hauses berechnet, unter der Annahme, dass der Kredit innerhalb eines Jahres zurückgezahlt werden muss und es keine Zinsen oder Anzahlung gibt.\n\n\nCode\ndef loan_emi(amount):\n    emi = amount / 12\n    print('The EMI is ${}'.format(emi))\n\n\n\n\nCode\nloan_emi(1260000)\n\n\nThe EMI is $105000.0\n\n\n\n5.2.1 Lokale Variablen und “Scope”\nFügen wir ein zweites Argument hinzu, um die Laufzeit des Darlehens in Monaten zu berücksichtigen.\n\n\nCode\ndef loan_emi(amount, duration):\n    emi = amount / duration\n    print('The EMI is ${}'.format(emi))\n\n\nBeachten Sie, dass die innerhalb der Funktion definierte Variable emi außerhalb der Funktion nicht zugänglich ist. Das Gleiche gilt für die Parameter amount und duration. Dies sind alles lokale Variablen, die innerhalb des Geltungsbereichs der Funktion liegen.\n\nScope: Der Geltungsbereich bezieht sich auf den Bereich innerhalb des Codes, in dem eine bestimmte Variable sichtbar ist. Jede Funktion (oder Klassendefinition) definiert einen Geltungsbereich innerhalb von Python. Variablen, die in diesem Bereich definiert sind, werden als lokale Variablen bezeichnet. Variablen, die überall verfügbar sind, werden als globale Variablen bezeichnet. Die Regeln des Geltungsbereichs ermöglichen es Ihnen, die gleichen Variablennamen in verschiedenen Funktionen zu verwenden, ohne Werte von einer zur anderen zu teilen.\n\n\n\nCode\nemi\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 emi\n\nNameError: name 'emi' is not defined\n\n\n\n\n\nCode\namount\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[36], line 1\n----&gt; 1 amount\n\nNameError: name 'amount' is not defined\n\n\n\n\n\nCode\nduration\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[37], line 1\n----&gt; 1 duration\n\nNameError: name 'duration' is not defined\n\n\n\nWir können nun einen Kredit mit einer Laufzeit von 6 Jahren mit einem Kredit mit einer Laufzeit von 10 Jahren vergleichen (unter der Annahme, dass keine Anzahlung oder Zinsen erfolgt).\n\n\nCode\nloan_emi(1260000, 8*12)\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[38], line 1\n----&gt; 1 loan_emi(1260000, 8*12)\n\nTypeError: loan_emi() missing 1 required positional argument: 'rate'\n\n\n\n\n\nCode\nloan_emi(1260000, 10*12)\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[39], line 1\n----&gt; 1 loan_emi(1260000, 10*12)\n\nTypeError: loan_emi() missing 1 required positional argument: 'rate'\n\n\n\n\n\n5.2.2 Rückgabewerte\nWie zu erwarten ist, ist der EMI für den 6-Jahres-Kredit höher als für den 10-Jahres-Kredit. Im Moment geben wir das Ergebnis aus, aber es wäre besser, es zurückzugeben und die Ergebnisse zum einfacheren Vergleich in Variablen zu speichern. Wir können dies mit der return-Anweisung tun\n\n\nCode\ndef loan_emi(amount, duration):\n    emi = amount / duration\n    return emi\n\n\n\n\nCode\nemi1 = loan_emi(1260000, 8*12)\n\n\n\n\nCode\nemi2 = loan_emi(1260000, 10*12)\n\n\n\n\nCode\nemi1\n\n\n13125.0\n\n\n\n\nCode\nemi2\n\n\n10500.0\n\n\n\n\n5.2.3 Optionale Argumente\nFügen wir nun ein weiteres Argument hinzu, um die sofortige Anzahlung zu berücksichtigen. Wir machen dies zu einem optionalen Argument mit dem Standardwert 0.\n\n\nCode\ndef loan_emi(amount, duration, down_payment=0):\n    loan_amount = amount - down_payment\n    emi = loan_amount / duration\n    return emi\n\n\n\n\nCode\nemi1 = loan_emi(1260000, 8*12, 3e5)\n\n\n\n\nCode\nemi1\n\n\n10000.0\n\n\n\n\nCode\nemi2 = loan_emi(1260000, 10*12)\n\n\n\n\nCode\nemi2\n\n\n10500.0\n\n\nAls nächstes fügen wir die Zinsberechnung in die Funktion ein. Hier ist die Formel zur Berechnung des EMI für einen Kredit:\n\n\nP ist der Darlehensbetrag (Eng: principal)\nn ist die Anzahl der Monate\nr ist der Zinssatz pro Monat\n\nDie Ableitung dieser Formel würde den Rahmen dieses Tutorials sprengen.\n\n\nCode\ndef loan_emi(amount, duration, rate, down_payment=0):\n    loan_amount = amount - down_payment\n    emi = loan_amount * rate * ((1+rate)**duration) / (((1+rate)**duration)-1)\n    return emi\n\n\nBeachten Sie, dass beim Definieren der Funktion erforderliche Argumente wie cost, duration und rate vor optionalen Argumenten wie down_payment stehen müssen.\nBerechnen wir den EMI für Option 1\n\n\nCode\nloan_emi(1260000, 8*12, 0.1/12, 3e5)\n\n\n14567.19753389219\n\n\nBei der Berechnung des EMI für Option 2 müssen wir das Argument down_payment nicht einbeziehen.\n\n\nCode\nloan_emi(1260000, 10*12, 0.08/12)\n\n\n15287.276888775077\n\n\n\n\n5.2.4 Named arguments\nDer Aufruf einer Funktion mit vielen Argumenten kann oft verwirrend sein und ist anfällig für menschliche Fehler. Zur besseren Übersichtlichkeit bietet Python die Möglichkeit, Funktionen mit named arguments aufzurufen. Der Funktionsaufruf kann auch in mehrere Zeilen aufgeteilt werden.\n\n\nCode\nemi1 = loan_emi(\n    amount=1260000, \n    duration=8*12, \n    rate=0.1/12, \n    down_payment=3e5\n)\n\n\n\n\nCode\nemi1\n\n\n14567.19753389219\n\n\n\n\nCode\nemi2 = loan_emi(amount=1260000, duration=10*12, rate=0.08/12)\n\n\n\n\nCode\nemi2\n\n\n15287.276888775077\n\n\n\n\n5.2.5 Module und Bibliotheksfunktionen\nWir können bereits erkennen, dass die EMI für Option 1 niedriger zu sein scheint als die EMI für Option 2. Es wäre jedoch schön, den Betrag auf volle Dollar aufzurunden, anstatt Ziffern nach dem Dezimalpunkt einzubeziehen. Um dies zu erreichen, könnten wir eine Funktion schreiben, die eine Zahl nehmen und auf die nächste ganze Zahl aufrunden kann (z.B. wird 1,2 auf 2 aufgerundet). Das wäre eine gute Übung zum Ausprobieren!\nDa das Aufrunden von Zahlen jedoch eine ziemlich häufige Operation ist, stellt Python dafür eine Funktion bereit (zusammen mit Tausenden von anderen Funktionen) als Teil der Python-Standardbibliothek. Funktionen sind in Module organisiert, die importiert werden müssen, um die Funktionen, die sie enthalten, zu nutzen.\n\nModule: Module sind Dateien, die Python-Code enthalten (Variablen, Funktionen, Klassen usw.). Sie bieten eine Möglichkeit, den Code für große Python-Projekte in Dateien und Ordnern zu organisieren. Ein Modul oder eine spezifische Funktion/Klasse/Variable aus einem Modul muss importiert werden, bevor es in einem Python-Skript oder Notebook verwendet werden kann. Dies bietet Kapselung (encapsulation) und vermeidet Namenskonflikte zwischen Ihrem Code und einem Modul oder zwischen Modulen.\n\nUm unsere EMI-Beträge aufzurunden, können wir die Funktion ceil (kurz für ceiling) aus dem math Modul verwenden. Lassen Sie uns das Modul importieren und es verwenden, um die Zahl 1,2 aufzurunden.\n\n\nCode\nimport math\n\n\n\n\nCode\nhelp(math.ceil)\n\n\nHelp on built-in function ceil in module math:\n\nceil(x, /)\n    Return the ceiling of x as an Integral.\n    \n    This is the smallest integer &gt;= x.\n\n\n\n\n\nCode\nmath.ceil(1.2)\n\n\n2\n\n\nLassen Sie uns nun die Funktion math.ceil innerhalb der Funktion home_loan_emi verwenden, um den EMI-Betrag aufzurunden.\n\nDie Verwendung von Funktionen zum Erstellen anderer Funktionen ist eine großartige Möglichkeit, Code wiederverzuwenden und komplexe Geschäftslogik zu implementieren, während der Code klein, verständlich und überschaubar bleibt. Idealerweise sollte eine Funktion nur eine Sache machen, und nur eine. Wenn Sie feststellen, dass Sie innerhalb einer einzigen Funktion zu viele Dinge tun, sollten Sie in Erwägung ziehen, sie in 2 oder mehr kleinere, unabhängige Funktionen aufzuteilen. Als Faustregel gilt, dass Sie versuchen sollten, Ihre Funktionen auf 10 Zeilen Code oder weniger zu beschränken. Gute Programmierer schreiben immer kleine, einfache und lesbare Funktionen.\n\n\n\nCode\ndef loan_emi(amount, duration, rate, down_payment=0):\n    loan_amount = amount - down_payment\n    emi = loan_amount * rate * ((1+rate)**duration) / (((1+rate)**duration)-1)\n    emi = math.ceil(emi)\n    return emi\n\n\n\n\nCode\nemi1 = loan_emi(\n    amount=1260000, \n    duration=8*12, \n    rate=0.1/12, \n    down_payment=3e5\n)\n\n\n\n\nCode\nemi1\n\n\n14568\n\n\n\n\nCode\nemi2 = loan_emi(amount=1260000, duration=10*12, rate=0.08/12)\n\n\n\n\nCode\nemi2\n\n\n15288\n\n\nVergleichen wir die EMIs und zeigen Sie eine Meldung für die Option mit dem niedrigeren EMI an.\n\n\nCode\nif emi1 &lt; emi2:\n    print(\"Option 1 has the lower EMI: ${}\".format(emi1))\nelse:\n    print(\"Option 2 has the lower EMI: ${}\".format(emi2))\n\n\nOption 1 has the lower EMI: $14568\n\n\n\n\n5.2.6 Funktionen wiederverwenden und verbessern\nJetzt wissen wir mit Sicherheit, dass Option 1 von den beiden Optionen die niedrigere EMI aufweist. Was aber noch besser ist, ist, dass wir jetzt eine praktische Funktion loan_emi haben, mit der sich viele andere ähnliche Probleme mit nur wenigen Codezeilen lösen lassen. Versuchen wir es mit ein paar weiteren Problemen.\n\nF: Shaun zahlt derzeit einen Wohnungsbaukredit für ein Haus zurück, das er vor einigen Jahren gekauft hat. Die Kosten für das Haus betrugen $800,000. Shaun leistete eine Anzahlung von 25% der Kosten und finanzierte den verbleibenden Betrag mit einem 6-Jahres-Darlehen mit einem Zinssatz von 7% pro Jahr (monatlich verzinst). Shaun kauft jetzt ein Auto im Wert von $60,000, das er plant, mit einem 1-jährigen Darlehen mit einem Zinssatz von 12% pro Jahr zu finanzieren. Beide Kredite werden in EMIs zurückgezahlt. Wie hoch ist die gesamte monatliche Zahlung, die Shaun zur Kreditrückzahlung leistet?\n\nDiese Frage ist nun mit der von uns bereits definierten Funktion loan_emi einfach zu lösen.\n\n\nCode\ncost_of_house = 800000\nhome_loan_duration = 6*12 # months\nhome_loan_rate = 0.07/12 # monthly\nhome_down_payment = .25 * 800000\n\nemi_house = loan_emi(amount=cost_of_house,\n                     duration=home_loan_duration,\n                     rate=home_loan_rate, \n                     down_payment=home_down_payment)\n\nemi_house\n\n\n10230\n\n\n\n\nCode\ncost_of_car = 60000\ncar_loan_duration = 1*12 # months\ncar_loan_rate = .12/12 # monthly\n\nemi_car = loan_emi(amount=cost_of_car, \n                   duration=car_loan_duration, \n                   rate=car_loan_rate)\n\nemi_car\n\n\n5331\n\n\n\n\nCode\nprint(\"Shaun makes a total monthly payment of ${} towards loan repayments.\".format(emi_house+emi_car))\n\n\nShaun makes a total monthly payment of $15561 towards loan repayments.\n\n\n\n\n5.2.7 Exceptions und try-except\n\nF: Wenn Sie sich 100.000 US-Dollar mit einem 10-jährigen Darlehen mit einem Zinssatz von 9 % pro Jahr leihen, wie hoch ist dann der Gesamtbetrag, den Sie am Ende als Zinsen zahlen?\n\nEine Möglichkeit, dieses Problem zu lösen, besteht darin, die EMIs für zwei Kredite zu vergleichen: einen mit dem angegebenen Zinssatz und einen mit einem Zinssatz von 0 %. Der gezahlte Gesamtzins ist dann einfach die Summe der monatlichen Differenzen über die Laufzeit des Darlehens.\n\n\nCode\nemi_with_interest = loan_emi(amount=100000, duration=10*12, rate=0.09/12)\nemi_with_interest\n\n\n1267\n\n\n\n\nCode\nemi_without_interest = loan_emi(amount=100000, duration=10*12, rate=0./12)\nemi_without_interest\n\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[70], line 1\n----&gt; 1 emi_without_interest = loan_emi(amount=100000, duration=10*12, rate=0./12)\n      2 emi_without_interest\n\nCell In[60], line 3, in loan_emi(amount, duration, rate, down_payment)\n      1 def loan_emi(amount, duration, rate, down_payment=0):\n      2     loan_amount = amount - down_payment\n----&gt; 3     emi = loan_amount * rate * ((1+rate)**duration) / (((1+rate)**duration)-1)\n      4     emi = math.ceil(emi)\n      5     return emi\n\nZeroDivisionError: float division by zero\n\n\n\nEtwas scheint schief gelaufen zu sein! Wenn man sich die Fehlermeldung oben genau ansieht, sagt Python uns genau, was falsch gelaufen ist. Python wirft einen ZeroDivisionError mit einer Nachricht, die anzeigt, dass wir versuchen, eine Zahl durch Null zu teilen. Dies ist eine Exception, die die weitere Ausführung des Programms stoppt.\n\nException: Auch wenn eine Anweisung oder ein Ausdruck syntaktisch korrekt ist, kann er einen Fehler verursachen, wenn versucht wird, ihn auszuführen. Während der Ausführung erkannte Fehler werden Ausnahmen (exceptions) genannt. Exceptions stoppen typischerweise die weitere Ausführung des Programms, es sei denn, sie werden im Programm mit try-except Anweisungen behandelt.\n\nPython bietet viele built-in Exceptions, die geworfen werden, wenn eingebaute Operatoren, Funktionen oder Methoden auf eine falsche Weise verwendet werden (Link). Sie können auch Ihre eigene benutzerdefinierte Exception definieren, indem Sie die Exception-Klasse erweitern (dazu später mehr).\nMit den Anweisungen try und except können Sie eine Ausnahme behandeln. Hier ist ein Beispiel:\n\n\nCode\ntry:\n    print(\"Now computing the result..\")\n    result = 5 / 0\n    print(\"Computation was completed successfully\")\nexcept ZeroDivisionError:\n    print(\"Failed to compute result because you were trying to divide by zero\")\n    result = None\n\nprint(result)\n\n\nNow computing the result..\nFailed to compute result because you were trying to divide by zero\nNone\n\n\nWenn eine Ausnahme in dem Code innerhalb eines try Blocks auftritt, werden die restlichen Anweisungen in dem Block übersprungen und die except Anweisung wird ausgeführt. Wenn die Art der geworfenen Ausnahme mit der Art der Ausnahme übereinstimmt, die durch die except Anweisung behandelt wird, dann wird der Code innerhalb des except Blocks ausgeführt und die Programmausführung kehrt dann zum normalen Ablauf zurück.\nSie können auch mehr als einen Typ von Ausnahme mit mehreren except Anweisungen behandeln. Erfahren Sie hier mehr über Ausnahmen.\nLassen Sie uns die loan_emi Funktion erweitern, um try-except zu verwenden, um das Szenario zu behandeln, in dem der Zinssatz 0% beträgt. Es ist üblich, Änderungen/Erweiterungen an Funktionen im Laufe der Zeit vorzunehmen, wenn neue Szenarien und Anwendungsfälle auftreten. Es macht Funktionen flexibler & leistungsfähiger.\n\n\nCode\ndef loan_emi(amount, duration, rate, down_payment=0):\n    loan_amount = amount - down_payment\n    try:\n        emi = loan_amount * rate * ((1+rate)**duration) / (((1+rate)**duration)-1)\n    except ZeroDivisionError:\n        emi = loan_amount / duration\n    emi = math.ceil(emi)\n    return emi\n\n\nWir können die aktualisierte Funktion loan_emi verwenden, um unser Problem zu lösen.\n\nF: Wenn Sie sich 100.000 US-Dollar mit einem 10-jährigen Darlehen mit einem Zinssatz von 9 % pro Jahr leihen, wie hoch ist dann der Gesamtbetrag, den Sie am Ende als Zinsen zahlen?\n\n\n\nCode\nemi_with_interest = loan_emi(amount=100000, duration=10*12, rate=0.09/12)\nemi_with_interest\n\n\n1267\n\n\n\n\nCode\nemi_without_interest = loan_emi(amount=100000, duration=10*12, rate=0)\nemi_without_interest\n\n\n834\n\n\n\n\nCode\ntotal_interest = (emi_with_interest - emi_without_interest) * 10*12\n\n\n\n\nCode\nprint(\"The total interest paid is ${}.\".format(total_interest))\n\n\nThe total interest paid is $51960.\n\n\n\n\n5.2.8 Funktionen mit Docstrings dokumentieren\nMit einem Docstring können wir unserer Funktion Dokumentation hinzufügen. Ein Docstring ist einfach ein String, der als erste Anweisung im Funktionskörper erscheint und von der Funktion help verwendet wird. Ein guter Docstring beschreibt, was die Funktion tut, und bietet einige Erklärungen zu den Argumenten.\n\n\nCode\ndef loan_emi(amount, duration, rate, down_payment=0):\n    \"\"\"Calculates the equal montly installment (EMI) for a loan.\n    \n    Arguments:\n        amount - Total amount to be spent (loan + down payment)\n        duration - Duration of the loan (in months)\n        rate - Rate of interest (monthly)\n        down_payment (optional) - Optional intial payment (deducted from amount)\n    \"\"\"\n    loan_amount = amount - down_payment\n    try:\n        emi = loan_amount * rate * ((1+rate)**duration) / (((1+rate)**duration)-1)\n    except ZeroDivisionError:\n        emi = loan_amount / duration\n    emi = math.ceil(emi)\n    return emi\n\n\nIm obigen docstring haben wir einige zusätzliche Informationen bereitgestellt, dass sowohl die duration als auch die rate in Monaten gemessen werden. Sie könnten sogar erwägen, die Argumente duration_months und rate_monthly zu benennen, um jegliche Verwirrung zu vermeiden. Können Sie sich andere Möglichkeiten vorstellen, wie die Funktion verbessert werden kann?\n\n\nCode\nhelp(loan_emi)\n\n\nHelp on function loan_emi in module __main__:\n\nloan_emi(amount, duration, rate, down_payment=0)\n    Calculates the equal montly installment (EMI) for a loan.\n    \n    Arguments:\n        amount - Total amount to be spent (loan + down payment)\n        duration - Duration of the loan (in months)\n        rate - Rate of interest (monthly)\n        down_payment (optional) - Optional intial payment (deducted from amount)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Schreiben von wiederverwendbarem Code mithilfe von Funktionen</span>"
    ]
  },
  {
    "objectID": "kapitel4.html#übung---datenanalyse-für-die-urlaubsplanung",
    "href": "kapitel4.html#übung---datenanalyse-für-die-urlaubsplanung",
    "title": "5  Schreiben von wiederverwendbarem Code mithilfe von Funktionen",
    "section": "5.3 Übung - Datenanalyse für die Urlaubsplanung",
    "text": "5.3 Übung - Datenanalyse für die Urlaubsplanung\nSie planen eine Freizeitreise (Urlaub) und müssen entscheiden, welche Stadt Sie besuchen möchten. Sie haben 4 Städte in die engere Auswahl genommen und die Kosten für den Rückflug, die täglichen Hotelkosten und die wöchentlichen Mietwagenkosten ermittelt (ein Auto muss für ganze Wochen gemietet werden, auch wenn Sie das Auto vor Ende einer Woche zurückgeben).\n\n\n\n\n\n\n\n\n\nStadt\nRückflug ($)\nHotel pro Tag ($)\nWöchentliche Autovermietung ($)\n\n\n\n\nParis\n200\n20\n200\n\n\nLondon\n250\n30\n120\n\n\nDubai\n370\n15\n80\n\n\nMumbai\n450\n10\n70\n\n\n\nBeantworten Sie die folgenden Fragen anhand der oben genannten Daten:\n\nWenn Sie eine 1-wöchige Reise planen, welche Stadt sollten Sie besuchen, um das wenigste Geld auszugeben?\nWie ändert sich die Antwort auf die vorherige Frage, wenn Sie die Dauer der Reise auf 4 Tage, 10 Tage oder 2 Wochen ändern?\nWenn Ihr Gesamtbudget für die Reise $1000 beträgt, welche Stadt sollten Sie besuchen, um die Dauer Ihrer Reise zu maximieren? Welche Stadt sollten Sie besuchen, wenn Sie die Dauer minimieren möchten?\nWie ändert sich die Antwort auf die vorherige Frage, wenn Ihr Budget $600, $2000 oder $1500 beträgt?\n\nHinweis: Um diese Fragen zu beantworten, könnte es hilfreich sein, eine Funktion cost_of_trip mit relevanten Eingaben wie Flugkosten, Hotelpreis, Mietwagenpreis und Dauer der Reise zu definieren. Die Funktion math.ceil könnte nützlich sein, um die Gesamtkosten der Autovermietung zu berechnen.\n\n\nCode\n# Verwenden Sie diese Zellen, um die Frage zu beantworten – bauen Sie die Funktion Schritt für Schritt auf",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Schreiben von wiederverwendbarem Code mithilfe von Funktionen</span>"
    ]
  },
  {
    "objectID": "kapitel4.html#weiterführende-literatur-und-referenzen",
    "href": "kapitel4.html#weiterführende-literatur-und-referenzen",
    "title": "5  Schreiben von wiederverwendbarem Code mithilfe von Funktionen",
    "section": "5.4 Weiterführende Literatur und Referenzen",
    "text": "5.4 Weiterführende Literatur und Referenzen\nHier sind noch einige weitere Themen, die Sie lernen könnten:\n\nFunktionen mit einer beliebigen Anzahl von Argumenten (*args und **kwargs)\nDefinition von Funktionen innerhalb von Funktionen (und Closures)\nEine Funktion, die sich selbst aufruft (Rekursion)\nFunktionen, die andere Funktionen als Argumente akzeptieren oder andere Funktionen zurückgeben\nFunktionen, die andere Funktionen verbessern (Dekorateure)\n\nIm Folgenden finden Sie einige Ressourcen, um mehr über Funktionen in Python zu erfahren:\n\nPython Tutorial bei W3Schools\nPraktische Python Programmierung\nPython offizielle Dokumentation",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Schreiben von wiederverwendbarem Code mithilfe von Funktionen</span>"
    ]
  },
  {
    "objectID": "kapitel5.html",
    "href": "kapitel5.html",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "",
    "text": "6.1 Arbeiten mit numerischen Daten\nDieses Tutorial ist das fünfte in einer Reihe zur Einführung in die Programmierung und Datenanalyse mithilfe der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\nDie folgenden Themen werden in diesem Tutorial behandelt:\nDie “Daten” in der Datenanalyse beziehen sich in der Regel auf numerische Daten, wie z. B. Aktienkurse, Verkaufszahlen, Sensormessungen, Sportergebnisse, Datenbanktabellen usw. Die Numpy-Bibliothek bietet spezialisierte Datenstrukturen, Funktionen und andere Tools für numerische Berechnungen in Python. Lassen Sie uns ein Beispiel durchgehen, um zu sehen, warum und wie Numpy für die Arbeit mit numerischen Daten verwendet wird.\nWir drücken den Ertrag an Äpfeln als gewichtete Summe der Temperatur, des Niederschlags und der Luftfeuchtigkeit aus. Offensichtlich ist dies eine Annäherung, da die tatsächliche Beziehung nicht unbedingt linear sein muss. Aber ein einfaches lineares Modell wie dieses funktioniert oft gut in der Praxis.\nAuf der Grundlage einiger statistischer Analysen historischer Daten könnten wir in der Lage sein, vernünftige Werte für die Gewichte w1, w2 und w3 zu ermitteln. Hier ist ein Beispiel für einen Satz von Werten:\nCode\nw1, w2, w3 = 0.3, 0.2, 0.5\nAnhand einiger Klimadaten für eine Region können wir nun vorhersagen, wie der Apfelertrag in der Region aussehen könnte. Hier sind einige Beispieldaten:\nZunächst können wir einige Variablen definieren, um die Klimadaten für eine Region aufzuzeichnen.\nCode\nkanto_temp = 73\nkanto_rainfall = 67\nkanto_humidity = 43\nDiese Variablen können wir nun in die lineare Gleichung einsetzen, um den Apfelertrag in dieser Region vorherzusagen.\nCode\nkanto_yield_apples = kanto_temp * w1 + kanto_rainfall * w2 + kanto_humidity * w3\nkanto_yield_apples\n\n\n56.8\nCode\nprint(\"The expected yield of apples in Kanto region is {} tons per hectare.\".format(kanto_yield_apples))\n\n\nThe expected yield of apples in Kanto region is 56.8 tons per hectare.\nUm die Durchführung der obigen Berechnung für mehrere Regionen etwas zu vereinfachen, können wir die Klimadaten für jede Region als Vektor, also als Zahlenliste, darstellen.\nCode\nkanto = [73, 67, 43]\njohto = [91, 88, 64]\nhoenn = [87, 134, 58]\nsinnoh = [102, 43, 37]\nunova = [69, 96, 70]\nDie drei Zahlen in jedem Vektor repräsentieren jeweils die Temperatur-, Niederschlags- und Luftfeuchtigkeitsdaten. Der im Forum zu verwendende Gewichtungssatz kann auch als Vektor dargestellt werden.\nCode\nweights = [w1, w2, w3]\nWir können jetzt eine Funktion crop_yield schreiben, um den Ertrag von Äpfeln (oder einer anderen Ernte) unter Berücksichtigung der Klimadaten und der jeweiligen Gewichte zu berechnen.\nCode\nkanto\n\n\n[73, 67, 43]\nCode\nweights\n\n\n[0.3, 0.2, 0.5]\nCode\nfor item in zip(kanto, weights):\n  print(item)\n\n\n(73, 0.3)\n(67, 0.2)\n(43, 0.5)\nCode\nresult = 0\nfor x, w in zip(kanto, weights):\n  print(x * w)\n  result += x * w\nprint(result) \n\n\n21.9\n13.4\n21.5\n56.8\nCode\ndef crop_yield(region, weights):\n    result = 0\n    for x, w in zip(region, weights):\n        result += x * w\n    return result\nCode\ncrop_yield(kanto, weights)\n\n\n56.8\nCode\ncrop_yield(johto, weights)\n\n\n76.9\nCode\ncrop_yield(unova, weights)\n\n\n74.9",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel5.html#arbeiten-mit-numerischen-daten",
    "href": "kapitel5.html#arbeiten-mit-numerischen-daten",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "",
    "text": "Nehmen wir an, wir möchten Klimadaten wie die Temperatur, den Niederschlag und die Luftfeuchtigkeit in einer Region nutzen, um festzustellen, ob die Region gut geeignet ist, um Äpfel anzubauen. Ein wirklich einfacher Ansatz dafür wäre, die Beziehung zwischen dem jährlichen Apfelertrag (Tonnen pro Hektar) und den klimatischen Bedingungen wie der Durchschnittstemperatur (in Grad Fahrenheit), dem Niederschlag (in Millimetern) und der durchschnittlichen relativen Luftfeuchtigkeit (in Prozent) als lineare Gleichung zu formulieren.\napfelertrag = w1 * temperatur + w2 * niederschlag + w3 * luftfeuchtigkeit",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel5.html#von-python-listen-zu-numpy-arrays-wechseln",
    "href": "kapitel5.html#von-python-listen-zu-numpy-arrays-wechseln",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "6.2 Von Python-Listen zu Numpy-Arrays wechseln",
    "text": "6.2 Von Python-Listen zu Numpy-Arrays wechseln\nDie durch crop_yield (elementweise Multiplikation zweier Vektoren und Bildung einer Summe der Ergebnisse) durchgeführte Berechnung wird auch als Skalarprodukt der beiden Vektoren bezeichnet.\nDie Numpy-Bibliothek bietet eine integrierte Funktion zum Berechnen des Skalarprodukts zweier Vektoren. Allerdings müssen die Listen zunächst in Numpy-Arrays konvertiert werden, bevor wir die Operation ausführen können. Zunächst importieren wir das Modul numpy. Es ist üblich, Numpy mit dem Alias np zu importieren.\nBevor die Numpy-Bibliothek nutzen können, müssen wir sie mit Hilfe des Python Paketverwaltungsprogramm pip installieren, da es ich beim Numpy um keine built-in Standardbibliothek handelt.\n\n\nCode\n!pip install numpy\n\n\nRequirement already satisfied: numpy in /Users/christianjulianebert/anaconda3/lib/python3.10/site-packages (1.23.5)\n\n\n\n\nCode\nimport numpy as np\n\n\nNumpy-Arrays können mit der Funktion np.array erstellt werden.\n\n\nCode\nkanto = np.array([73, 67, 43])\n\n\n\n\nCode\nkanto\n\n\narray([73, 67, 43])\n\n\n\n\nCode\nweights = np.array([w1, w2, w3])\n\n\n\n\nCode\nweights\n\n\narray([0.3, 0.2, 0.5])\n\n\n\n\nCode\ntype(kanto)\n\n\nnumpy.ndarray\n\n\n\n\nCode\ntype(weights)\n\n\nnumpy.ndarray\n\n\nGenau wie Listen unterstützen Numpy-Arrays die Indexierungsnotation [].\n\n\nCode\nweights[0]\n\n\n0.3\n\n\n\n\nCode\nkanto[2]\n\n\n43",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel5.html#umgang-mit-numpy-arrays",
    "href": "kapitel5.html#umgang-mit-numpy-arrays",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "6.3 Umgang mit Numpy-Arrays",
    "text": "6.3 Umgang mit Numpy-Arrays\nWir können nun das Skalarprodukt der beiden Vektoren mit der Funktion np.dot berechnen\n\n\nCode\nnp.dot(kanto, weights)\n\n\n56.8\n\n\nDas gleiche Ergebnis können wir mit Operationen auf niedrigerer Ebene erzielen, die von Numpy-Arrays unterstützt werden: Durchführen einer elementweisen Multiplikation und Berechnen der Summe der resultierenden Zahlen.\n\n\nCode\n(kanto * weights).sum()\n\n\n56.8\n\n\nDer *-Operator führt eine elementweise Multiplikation zweier Arrays durch (vorausgesetzt, sie haben die gleiche Größe), und die sum Methode berechnet die Summe der Zahlen in einem Array.\n\n\nCode\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\n\n\n\n\nCode\narr1 * arr2\n\n\narray([ 4, 10, 18])\n\n\n\n\nCode\narr2.sum()\n\n\n15",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel5.html#vorteile-der-verwendung-von-numpy-arrays",
    "href": "kapitel5.html#vorteile-der-verwendung-von-numpy-arrays",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "6.4 Vorteile der Verwendung von Numpy-Arrays",
    "text": "6.4 Vorteile der Verwendung von Numpy-Arrays\nEs gibt ein paar wichtige Vorteile bei der Verwendung von Numpy-Arrays anstelle von Python-Listen zur Bearbeitung von numerischen Daten:\n\nBenutzerfreundlichkeit: Sie können kleine, prägnante und intuitive mathematische Ausdrücke wie (kanto * weights).sum() schreiben, anstatt Schleifen und benutzerdefinierte Funktionen wie crop_yield zu verwenden.\nLeistung: Numpy-Operationen und -Funktionen sind intern in C++ implementiert, was sie viel schneller macht als Python-Anweisungen und -Schleifen, die zur Laufzeit interpretiert werden\n\nHier ist ein schneller Vergleich von Skalarprodukten, die mit Vektoren mit jeweils einer Million Elementen durchgeführt werden, und zwar mit Python-Schleifen im Vergleich zu Numpy-Arrays.\n\n\nCode\n# Python lists\narr1 = list(range(1000000))\narr2 = list(range(1000000, 2000000))\n\n# Numpy arrays\narr1_np = np.array(arr1)\narr2_np = np.array(arr2)\n\n\n\n\nCode\n%%time\nresult = 0\nfor x1, x2 in zip(arr1, arr2):\n    result += x1*x2\nprint(result)\n\n\n833332333333500000\nCPU times: user 94.6 ms, sys: 1.57 ms, total: 96.2 ms\nWall time: 95 ms\n\n\n\n\nCode\n%%time\nnp.dot(arr1_np, arr2_np)\n\n\nCPU times: user 1.29 ms, sys: 1.09 ms, total: 2.38 ms\nWall time: 1.08 ms\n\n\n833332333333500000\n\n\nWie Sie sehen, ist die Verwendung von np.dot 100-mal schneller als die Verwendung einer for-Schleife. Dies macht Numpy besonders nützlich, wenn mit wirklich großen Datensätzen mit Zehntausenden oder Millionen Datenpunkten gearbeitet wird.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel5.html#mehrdimensionale-numpy-arrays",
    "href": "kapitel5.html#mehrdimensionale-numpy-arrays",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "6.5 Mehrdimensionale Numpy-Arrays",
    "text": "6.5 Mehrdimensionale Numpy-Arrays\nWir können nun noch einen Schritt weiter gehen und die Klimadaten für alle Regionen gemeinsam in einem einzigen zweidimensionalen Numpy-Array darstellen.\n\n\nCode\nclimate_data = np.array([[73, 67, 43],\n                         [91, 88, 64],\n                         [87, 134, 58],\n                         [102, 43, 37],\n                         [69, 96, 70]])\n\n\n\n\nCode\nclimate_data\n\n\narray([[ 73,  67,  43],\n       [ 91,  88,  64],\n       [ 87, 134,  58],\n       [102,  43,  37],\n       [ 69,  96,  70]])\n\n\nWenn Sie in der High School einen Kurs über lineare Algebra besucht haben, erkennen Sie das obige zweidimensionale Array vielleicht als eine Matrix mit 5 Zeilen (eine für jede Region) und 3 Spalten (die Werte für Temperatur und Niederschlag enthalten). und Luftfeuchtigkeit).\n\nNumpy-Arrays können beliebig viele Dimensionen und unterschiedliche Längen entlang jeder Dimension haben. Mit der Eigenschaft .shape eines Arrays können wir die Länge entlang jeder Dimension überprüfen.\n\n\nCode\nclimate_data\n\n\narray([[ 73,  67,  43],\n       [ 91,  88,  64],\n       [ 87, 134,  58],\n       [102,  43,  37],\n       [ 69,  96,  70]])\n\n\n\n\nCode\n# 2D array (matrix)\nclimate_data.shape\n\n\n(5, 3)\n\n\n\n\nCode\nweights\n\n\narray([0.3, 0.2, 0.5])\n\n\n\n\nCode\n# 1D array (vector)\nweights.shape\n\n\n(3,)\n\n\n\n\nCode\n# 3D array \narr3 = np.array([\n                 [[11, 12, 13], \n                  [13, 14, 15]], \n\n                 [[15, 16, 17], \n                  [17, 18, 19.5]]\n                                 ])\n\n\n\n\nCode\narr3.shape\n\n\n(2, 2, 3)\n\n\nAlle Elemente in einem Numpy-Array haben denselben Datentyp. Sie können den Datentyp eines Arrays mithilfe der Eigenschaft .dtype überprüfen\n\n\nCode\nweights.dtype\n\n\ndtype('float64')\n\n\n\n\nCode\nclimate_data.dtype\n\n\ndtype('int64')\n\n\nWenn ein Array auch nur eine einzelne Gleitkommazahl enthält, werden alle anderen Elemente ebenfalls in Gleitkommazahlen umgewandelt.\n\n\nCode\narr3.dtype\n\n\ndtype('float64')\n\n\n\n\nCode\nclimate_data\n\n\narray([[ 73,  67,  43],\n       [ 91,  88,  64],\n       [ 87, 134,  58],\n       [102,  43,  37],\n       [ 69,  96,  70]])\n\n\nWir können nun die vorhergesagten Apfelerträge in allen Regionen berechnen, indem wir eine einzelne Matrixmultiplikation zwischen climate_data (einer 5x3-Matrix) und weights (einem Vektor der Länge 3) verwenden. So sieht es optisch aus:\n\nWir können die Funktion np.matmul von Numpy verwenden oder einfach den Operator @ verwenden, um eine Matrixmultiplikation durchzuführen.\n\n\nCode\nclimate_data\n\n\narray([[ 73,  67,  43],\n       [ 91,  88,  64],\n       [ 87, 134,  58],\n       [102,  43,  37],\n       [ 69,  96,  70]])\n\n\n\n\nCode\nweights\n\n\narray([0.3, 0.2, 0.5])\n\n\n\n\nCode\nnp.matmul(climate_data, weights)\n\n\narray([56.8, 76.9, 81.9, 57.7, 74.9])\n\n\n\n\nCode\nclimate_data @ weights\n\n\narray([56.8, 76.9, 81.9, 57.7, 74.9])",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel5.html#arbeiten-mit-csv-dateien",
    "href": "kapitel5.html#arbeiten-mit-csv-dateien",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "6.6 Arbeiten mit CSV-Dateien",
    "text": "6.6 Arbeiten mit CSV-Dateien\nNumpy bietet auch Hilfsfunktionen zum Lesen von und Schreiben in Dateien an. Lassen Sie uns eine Datei climate.txt herunterladen, die 10.000 Klimadaten (Temperatur, Niederschlag & Luftfeuchtigkeit) im folgenden Format enthält:\nTemperatur,Niederschlag,Luftfeuchtigkeit\n25,00,76,00,99,00\n39,00,65,00,70,00\n59,00,45,00,77,00\n84,00,63,00,38,00\n66,00,50,00,52,00\n41,00,94,00,77,00\n91,00,57,00,96,00\n49,00,96,00,99,00\n67,00,20,00,28,00\n...\nDiese Art der Datenspeicherung ist bekannt als Comma Separated Values oder CSV.\n\nCSVs: Eine Datei mit durch Kommas getrennten Werten (CSV) ist eine Textdatei, die ein Komma zur Trennung von Werten verwendet. Jede Zeile der Datei ist ein Datensatz. Jeder Datensatz besteht aus einem oder mehreren Feldern, die durch Kommas getrennt sind. Eine CSV-Datei speichert typischerweise tabellarische Daten (Zahlen und Text) im Klartext, in diesem Fall hat jede Zeile die gleiche Anzahl von Feldern. (Wikipedia)\n\nUm diese Datei in ein Numpy-Array zu lesen, können wir die Funktion genfromtxt verwenden.\n\n\nCode\nclimate_data = np.genfromtxt('data/climate.txt', delimiter=',', skip_header=1)\n\n\n\n\nCode\nclimate_data\n\n\narray([[25., 76., 99.],\n       [39., 65., 70.],\n       [59., 45., 77.],\n       ...,\n       [99., 62., 58.],\n       [70., 71., 91.],\n       [92., 39., 76.]])\n\n\n\n\nCode\nclimate_data.shape\n\n\n(10000, 3)\n\n\nWir können jetzt einen Matrix-Mulplikationsoperator @ verwenden, um den Apfelertrag für den gesamten Datensatz unter Verwendung eines gegebenen Satzes von Gewichten vorherzusagen.\n\n\nCode\nweights = np.array([0.3, 0.2, 0.5])\n\n\n\n\nCode\nyields = climate_data @ weights\n\n\n\n\nCode\nyields\n\n\narray([72.2, 59.7, 65.2, ..., 71.1, 80.7, 73.4])\n\n\n\n\nCode\nyields.shape\n\n\n(10000,)\n\n\nMit der Funktion np.concatenate können wir nun die yields als vierte Spalte wieder zu climate_data hinzufügen .\n\n\nCode\nclimate_results = np.concatenate((climate_data, yields.reshape(10000, 1)), axis=1)\n\n\n\n\nCode\nclimate_results\n\n\narray([[25. , 76. , 99. , 72.2],\n       [39. , 65. , 70. , 59.7],\n       [59. , 45. , 77. , 65.2],\n       ...,\n       [99. , 62. , 58. , 71.1],\n       [70. , 71. , 91. , 80.7],\n       [92. , 39. , 76. , 73.4]])\n\n\nEs gibt hier ein paar Feinheiten:\n\nWir müssen das Argument axis für np.concatenate bereitstellen, um die Dimension zu spezifizieren, entlang der die Konkatenation ausgeführt werden soll.\nDie zu konkatenierenden Arrays sollten die gleiche Anzahl von Dimensionen und die gleiche Länge entlang jeder Dimension haben, außer derjenigen, entlang der die Konkatenation durchgeführt wird. Wir verwenden hier die Funktion np.reshape, um die Form von yields von (10000,) auf (10000,1) zu ändern.\n\nHier ist eine visuelle Erklärung von np.concatenate entlang axis=1 (können Sie erraten, was axis=0 ergibt?):\n\nDer beste Weg, um zu verstehen, was eine Numpy-Funktion tut, besteht darin, mit ihr zu experimentieren und die Dokumentation mit der Funktion help zu lesen, um mehr über ihre Argumente und Rückgabewerte zu erfahren. Nutzen Sie die folgenden Zellen, um mit np.concatenate und np.reshape zu experimentieren.\n\n\nCode\n# Tragen Sie hier Ihren Code ein!\n\n\nSchreiben wir die Endergebnisse unserer obigen Berechnung mit der Funktion np.savetxt zurück in eine Datei, die sich im data Ordner befinden soll.\n\n\nCode\nclimate_results\n\n\narray([[25. , 76. , 99. , 72.2],\n       [39. , 65. , 70. , 59.7],\n       [59. , 45. , 77. , 65.2],\n       ...,\n       [99. , 62. , 58. , 71.1],\n       [70. , 71. , 91. , 80.7],\n       [92. , 39. , 76. , 73.4]])\n\n\n\n\nCode\nnp.savetxt('data/climate_results.txt', \n           climate_results, \n           fmt='%.2f', \n           header='temperature,rainfall,humidity,yeild_apples', \n           comments='')\n\n\n\n\nCode\nnp.savetxt('data/climate_results_nocomments.txt', \n           climate_results, \n           fmt='%.2f', \n           header='temperature,rainfall,humidity,yeild_apples')\n\n\nDie Ergebnisse werden im CSV-Format in die Datei climate_results.txt zurückgeschrieben.\nTemperatur,Niederschlag,Luftfeuchtigkeit\n25.00 76.00 99.00 72.20\n39.00 65.00 70.00 59.70\n59.00 45.00 77.00 65.20\n84.00 63.00 38.00 56.80\n66.00 50.00 52.00 55.80\n41.00 94.00 77.00 69.60\n91.00 57.00 96.00 86.70\n49.00 96.00 99.00 83.40\n67.00 20.00 28.00 38.10\n...\nNumpy bietet Hunderte von Funktionen zum Ausführen von Operationen an Arrays. Hier sind einige allgemeine Funktionen:\nMathematik: np.sum, np.exp, np.round, arithemtische Operatoren Array-Manipulation: np.reshape, np.stack, np.concatenate, np.split Lineare Algebra: np.matmul, np.dot, np.transpose, np.eigvals Statistiken: np.mean, np.median, np.std, np.max\n\nWie finden Sie die Funktion, die Sie benötigen? Da Numpy Hunderte von Funktionen zum Bearbeiten von Arrays bietet, kann es manchmal schwierig sein, genau das zu finden, was Sie benötigen. Der einfachste Weg, die richtige Funktion zu finden, ist eine Websuche, z. B. Die Suche nach „So verknüpfen Sie Numpy-Arrays“ führt zu diesem Tutorial zur Array-Verkettung.\n\nEine vollständige Liste der Array-Funktionen finden Sie hier.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel5.html#arithmetische-operationen-und-broadcasting",
    "href": "kapitel5.html#arithmetische-operationen-und-broadcasting",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "6.7 Arithmetische Operationen und Broadcasting",
    "text": "6.7 Arithmetische Operationen und Broadcasting\nNumpy-Arrays unterstützen arithmetische Operatoren wie +, -, * usw. Sie können eine arithmetische Operation mit einer einzelnen Zahl (auch Skalar genannt) oder mit einem anderen Array derselben Form ausführen. Dadurch ist es wirklich einfach, mathematische Ausdrücke mit mehrdimensionalen Arrays zu schreiben.\n\n\nCode\narr2 = np.array([[1, 2, 3, 4], \n                 [5, 6, 7, 8], \n                 [9, 1, 2, 3]])\n\n\n\n\nCode\narr3 = np.array([[11, 12, 13, 14], \n                 [15, 16, 17, 18], \n                 [19, 11, 12, 13]])\n\n\n\n\nCode\narr2 + arr3\n\n\narray([[12, 14, 16, 18],\n       [20, 22, 24, 26],\n       [28, 12, 14, 16]])\n\n\n\n\nCode\n# Adding a scalar\narr2 + 3\n\n\narray([[ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12,  4,  5,  6]])\n\n\n\n\nCode\n# Element-wise subtraction\narr3 - arr2\n\n\narray([[10, 10, 10, 10],\n       [10, 10, 10, 10],\n       [10, 10, 10, 10]])\n\n\n\n\nCode\n# Division by scalar\narr2 / 2\n\n\narray([[0.5, 1. , 1.5, 2. ],\n       [2.5, 3. , 3.5, 4. ],\n       [4.5, 0.5, 1. , 1.5]])\n\n\n\n\nCode\n# Element-wise multiplication\narr2 * arr3\n\n\narray([[ 11,  24,  39,  56],\n       [ 75,  96, 119, 144],\n       [171,  11,  24,  39]])\n\n\n\n\nCode\n# Modulus with scalar or find the reminder\narr2 % 4\n\n\narray([[1, 2, 3, 0],\n       [1, 2, 3, 0],\n       [1, 1, 2, 3]])\n\n\nNumpy-Arrays unterstützen auch Broadcasting, was arithmetische Operationen zwischen zwei Arrays mit unterschiedlicher Anzahl an Dimensionen, aber kompatiblen Formen ermöglicht. Schauen wir uns ein Beispiel an, um zu sehen, wie es funktioniert.\n\n\nCode\narr2 = np.array([[1, 2, 3, 4], \n                 [5, 6, 7, 8], \n                 [9, 1, 2, 3]])\n\n\n\n\nCode\narr2.shape\n\n\n(3, 4)\n\n\n\n\nCode\narr4 = np.array([4, 5, 6, 7])\n\n\n\n\nCode\narr4_replicate = np.array([[4, 5, 6, 7],\n                           [4, 5, 6, 7],\n                           [4, 5, 6, 7]])\n\n\n\n\nCode\narr4_replicate.shape\n\n\n(3, 4)\n\n\n\n\nCode\narr4.shape\n\n\n(4,)\n\n\n\n\nCode\narr2 + arr4\n\n\narray([[ 5,  7,  9, 11],\n       [ 9, 11, 13, 15],\n       [13,  6,  8, 10]])\n\n\n\n\nCode\narr2 + arr4_replicate\n\n\narray([[ 5,  7,  9, 11],\n       [ 9, 11, 13, 15],\n       [13,  6,  8, 10]])\n\n\nWenn der Ausdruck arr2 + arr4 ausgewertet wird, wird arr4 (das die Form (4,) hat) dreimal repliziert, um der Form (3, 4) von arr2 zu entsprechen. Dies ist sehr nützlich, da Numpy die Replikation durchführt, ohne tatsächlich drei Kopien des Arrays mit der kleineren Dimension zu erstellen.\n\nBroadcasting funktioniert nur, wenn eines der Arrays so repliziert werden kann, dass es genau der Form des anderen Arrays entspricht.\n\n\nCode\narr5 = np.array([7, 8])\n\n\n\n\nCode\narr5.shape\n\n\n(2,)\n\n\n\n\nCode\narr5_replicated = np.array([[7, 8],\n                            [7, 8],\n                            [7, 8]])\n\n\n\n\nCode\narr2 + arr5\n\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[80], line 1\n----&gt; 1 arr2 + arr5\n\nValueError: operands could not be broadcast together with shapes (3,4) (2,) \n\n\n\nSelbst wenn arr5 im obigen Beispiel dreimal repliziert wird, stimmt es nicht mit der Form von arr2 überein, daher kann arr2 + arr5 nicht erfolgreich ausgewertet werden. Erfahren Sie hier mehr über Broadcasting.\nNumpy-Arrays unterstützen auch Vergleichsoperationen wie ==, !=, &gt; usw. Das Ergebnis ist ein Array von booleschen Werten.\n\n\nCode\narr1 = np.array([[1, 2, 3], [3, 4, 5]])\narr2 = np.array([[2, 2, 3], [1, 2, 5]])\n\n\n\n\nCode\narr1 == arr2\n\n\narray([[False,  True,  True],\n       [False, False,  True]])\n\n\n\n\nCode\n(arr1 == arr2).dtype\n\n\ndtype('bool')\n\n\n\n\nCode\narr1 != arr2\n\n\narray([[ True, False, False],\n       [ True,  True, False]])\n\n\n\n\nCode\narr1 &gt;= arr2\n\n\narray([[False,  True,  True],\n       [ True,  True,  True]])\n\n\n\n\nCode\narr1 &lt; arr2\n\n\narray([[ True, False, False],\n       [False, False, False]])\n\n\nEin häufiger Anwendungsfall hierfür ist das Zählen der Anzahl gleicher Elemente in zwei Arrays mithilfe der sum-Methode. Denken Sie daran, dass True den Wert 1 und False den Wert 0 ergibt, wenn boolesche Werte in arithmetischen Operationen verwendet werden.\n\n\nCode\n(arr1 == arr2).sum()\n\n\n3",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel5.html#array-indizierung-und-slicing",
    "href": "kapitel5.html#array-indizierung-und-slicing",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "6.8 Array-Indizierung und Slicing",
    "text": "6.8 Array-Indizierung und Slicing\nNumpy erweitert die Listenindizierungsnotation von Python mithilfe von [] auf ziemlich intuitive Weise auf mehrere Dimensionen. Sie können eine durch Kommas getrennte Liste von Indizes oder Bereichen bereitstellen, um ein bestimmtes Element oder ein Subarray (auch Slice genannt) aus einem Numpy-Array auszuwählen.\n\n\nCode\narr3 = np.array([\n    [[11, 12, 13, 14], \n     [13, 14, 15, 19]], \n    \n    [[15, 16, 17, 21], \n     [63, 92, 36, 18]], \n    \n    [[98, 32, 81, 23],      \n     [17, 18, 19.5, 43]]])\n\n\n\n\nCode\narr3.shape\n\n\n(3, 2, 4)\n\n\n\n\nCode\n# Single element\narr3[1, 1, 2]\n\n\n36.0\n\n\n\n\nCode\narr3[1, 1, 2]\n\n\n36.0\n\n\n\n\nCode\narr3\n\n\narray([[[11. , 12. , 13. , 14. ],\n        [13. , 14. , 15. , 19. ]],\n\n       [[15. , 16. , 17. , 21. ],\n        [63. , 92. , 36. , 18. ]],\n\n       [[98. , 32. , 81. , 23. ],\n        [17. , 18. , 19.5, 43. ]]])\n\n\n\n\nCode\narr3[1:]    \n\n\narray([[[15. , 16. , 17. , 21. ],\n        [63. , 92. , 36. , 18. ]],\n\n       [[98. , 32. , 81. , 23. ],\n        [17. , 18. , 19.5, 43. ]]])\n\n\n\n\nCode\narr3[1:, 0:1]\n\n\narray([[[15., 16., 17., 21.]],\n\n       [[98., 32., 81., 23.]]])\n\n\n\n\nCode\n# Subarray using ranges\narr3[1:, 0:1, :2]\n\n\narray([[[15., 16.]],\n\n       [[98., 32.]]])\n\n\n\n\nCode\narr3\n\n\narray([[[11. , 12. , 13. , 14. ],\n        [13. , 14. , 15. , 19. ]],\n\n       [[15. , 16. , 17. , 21. ],\n        [63. , 92. , 36. , 18. ]],\n\n       [[98. , 32. , 81. , 23. ],\n        [17. , 18. , 19.5, 43. ]]])\n\n\n\n\nCode\narr3[1:]\n\n\narray([[[15. , 16. , 17. , 21. ],\n        [63. , 92. , 36. , 18. ]],\n\n       [[98. , 32. , 81. , 23. ],\n        [17. , 18. , 19.5, 43. ]]])\n\n\n\n\nCode\narr3[1:, 1]\n\n\narray([[63. , 92. , 36. , 18. ],\n       [17. , 18. , 19.5, 43. ]])\n\n\n\n\nCode\n# Mixing indices and ranges\narr3[1:, 1, 3]\n\n\narray([18., 43.])\n\n\n\n\nCode\n# Mixing indices and ranges\narr3[1:, 1, :3]\n\n\narray([[63. , 92. , 36. ],\n       [17. , 18. , 19.5]])\n\n\n\n\nCode\n# Using fewer indices\narr3[1]\n\n\narray([[15., 16., 17., 21.],\n       [63., 92., 36., 18.]])\n\n\n\n\nCode\n# Using fewer indices\narr3[:2, 1]\n\n\narray([[13., 14., 15., 19.],\n       [63., 92., 36., 18.]])\n\n\n\n\nCode\n# Using too many indices\narr3[1,3,2,1]\n\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[103], line 2\n      1 # Using too many indices\n----&gt; 2 arr3[1,3,2,1]\n\nIndexError: too many indices for array: array is 3-dimensional, but 4 were indexed\n\n\n\nDie Notation und die Ergebnisse können zunächst verwirrend sein. Nehmen Sie sich also Zeit zum Experimentieren und machen Sie sich damit vertraut. Verwenden Sie die folgenden Zellen, um einige Beispiele für die Indexierung und Aufteilung von Arrays mit verschiedenen Kombinationen von Indizes und Bereichen auszuprobieren. Hier sind einige weitere Beispiele, die visuell veranschaulicht werden:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel5.html#andere-möglichkeiten-zum-erstellen-von-numpy-arrays",
    "href": "kapitel5.html#andere-möglichkeiten-zum-erstellen-von-numpy-arrays",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "6.9 Andere Möglichkeiten zum Erstellen von Numpy-Arrays",
    "text": "6.9 Andere Möglichkeiten zum Erstellen von Numpy-Arrays\nNumpy bietet außerdem einige praktische Funktionen zum Erstellen von Arrays einer gewünschten Form mit festen oder zufälligen Werten. Schauen Sie sich die offizielle Dokumentation an oder nutzen Sie die help-Funktion, um mehr über die folgenden Funktionen zu erfahren.\n\n\nCode\n# All zeros\nnp.zeros((3, 2))\n\n\narray([[0., 0.],\n       [0., 0.],\n       [0., 0.]])\n\n\n\n\nCode\n# All ones\nnp.ones([2, 2, 3])\n\n\narray([[[1., 1., 1.],\n        [1., 1., 1.]],\n\n       [[1., 1., 1.],\n        [1., 1., 1.]]])\n\n\n\n\nCode\n# Identity matrix\nnp.eye(3)\n\n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\n\n\nCode\n# Random vector\nnp.random.rand(5)\n\n\narray([0.57946642, 0.1520226 , 0.26882721, 0.59721361, 0.77004381])\n\n\n\n\nCode\n# Random matrix\nnp.random.randn(2, 3) # rand vs. randn - what's the difference?\n\n\narray([[ 0.22724674, -0.15781586,  0.22040568],\n       [-0.69069408, -0.89697522, -0.86484168]])\n\n\n\n\nCode\n# Fixed value\nnp.full([2, 3], 42)\n\n\narray([[42, 42, 42],\n       [42, 42, 42]])\n\n\n\n\nCode\n# Range with start, end and step\nnp.arange(10, 90, 3)\n\n\narray([10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58,\n       61, 64, 67, 70, 73, 76, 79, 82, 85, 88])\n\n\n\n\nCode\nnp.arange(10, 90, 3).shape\n\n\n(27,)\n\n\n\n\nCode\nnp.arange(10, 90, 3).reshape(3,3,-1)\n\n\narray([[[10, 13, 16],\n        [19, 22, 25],\n        [28, 31, 34]],\n\n       [[37, 40, 43],\n        [46, 49, 52],\n        [55, 58, 61]],\n\n       [[64, 67, 70],\n        [73, 76, 79],\n        [82, 85, 88]]])\n\n\n\n\nCode\n# Equally spaced numbers in a range\nnp.linspace(3, 27, 9)\n\n\narray([ 3.,  6.,  9., 12., 15., 18., 21., 24., 27.])",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel5.html#weiterführende-literatur",
    "href": "kapitel5.html#weiterführende-literatur",
    "title": "6  Numerisches Rechnen mit Python und Numpy",
    "section": "6.10 Weiterführende Literatur",
    "text": "6.10 Weiterführende Literatur\n\nOffizielles Tutorial\nNumpy-Tutorial auf W3Schools\nAdvanced Numpy (Erkundung der Interna)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Numerisches Rechnen mit Python und Numpy</span>"
    ]
  },
  {
    "objectID": "kapitel6.html",
    "href": "kapitel6.html",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "",
    "text": "7.1 Eine CSV-Datei mit Pandas einlesen\nDieses Tutorial ist das sechste in einer Reihe zur Einführung in die Programmierung und Datenanalyse mithilfe der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\nDie folgenden Themen werden in diesem Tutorial behandelt:\nPandas wird in der Regel verwendet, um mit tabellarischen Daten zu arbeiten (ähnlich wie die Daten, die in einer Tabelle gespeichert sind). Pandas bietet Hilfsfunktionen zum Einlesen von Daten aus verschiedenen Dateiformaten wie CSV, Excel-Tabellen, HTML-Tabellen, JSON, SQL und mehr. Lassen Sie uns die Datei italy-covid-daywise.txt herunterladen, die tageweise Covid-19-Daten für Italien im folgenden Format enthält:\nDiese Art der Datenspeicherung wird als comma separated values oder CSV bezeichnet.\nUm die Datei zu lesen, können wir die Methode read_csv von Pandas verwenden. Lassen Sie uns die Pandas-Bibliothek importieren. Es wird normalerweise mit dem Alias pd importiert.\nCode\nimport pandas as pd\nCode\ncovid_df = pd.read_csv('data/italy-covid-daywise.csv')\nDaten aus der Datei werden gelesen und in einem DataFrame-Objekt gespeichert – einer der Kerndatenstrukturen in Pandas zum Speichern und Arbeiten mit Tabellendaten. Normalerweise verwenden wir das Suffix _df in den Variablennamen für Data Frame.\nCode\ntype(covid_df)\n\n\npandas.core.frame.DataFrame\nCode\ncovid_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n\n\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n\n\n\n\n248 rows × 4 columns\nFolgendes können wir anhand des Data Frames erkennen:\nBeachten Sie, dass es sich hierbei um offiziell gemeldete Zahlen handelt und die tatsächliche Zahl der Fälle und Todesfälle höher sein kann, da nicht alle Fälle diagnostiziert werden.\nMit der Methode .info können wir einige grundlegende Informationen zum Data Frame anzeigen.\nCode\ncovid_df.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 248 entries, 0 to 247\nData columns (total 4 columns):\n #   Column      Non-Null Count  Dtype  \n---  ------      --------------  -----  \n 0   date        248 non-null    object \n 1   new_cases   248 non-null    float64\n 2   new_deaths  248 non-null    float64\n 3   new_tests   135 non-null    float64\ndtypes: float64(3), object(1)\nmemory usage: 7.9+ KB\nEs scheint, dass jede Spalte Werte eines bestimmten Datentyps enthält. Für die numerischen Spalten können Sie mit der Methode .describe einige statistische Informationen wie Mittelwert, Standardabweichung, Minimal-/Maximalwerte und Anzahl nicht leerer Werte anzeigen.\nCode\ncovid_df.describe()\n\n\n\n\n\n\n\n\n\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\ncount\n248.000000\n248.000000\n135.000000\n\n\nmean\n1094.818548\n143.133065\n31699.674074\n\n\nstd\n1554.508002\n227.105538\n11622.209757\n\n\nmin\n-148.000000\n-31.000000\n7841.000000\n\n\n25%\n123.000000\n3.000000\n25259.000000\n\n\n50%\n342.000000\n17.000000\n29545.000000\n\n\n75%\n1371.750000\n175.250000\n37711.000000\n\n\nmax\n6557.000000\n971.000000\n95273.000000\nDie Eigenschaft columns enthält die Liste der Spalten innerhalb des Data Frames.\nCode\ncovid_df.columns\n\n\nIndex(['date', 'new_cases', 'new_deaths', 'new_tests'], dtype='object')\nSie können die Anzahl der Zeilen und Spalten im Data Frame auch mit der Methode .shape abrufen\nCode\ncovid_df.shape\n\n\n(248, 4)\nHier ist eine Zusammenfassung der Funktionen und Methoden, die wir uns bisher angesehen haben:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel6.html#eine-csv-datei-mit-pandas-einlesen",
    "href": "kapitel6.html#eine-csv-datei-mit-pandas-einlesen",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "",
    "text": "date,new_cases,new_deaths,new_tests\n2020-04-21,2256.0,454.0,28095.0\n2020-04-22,2729.0,534.0,44248.0\n2020-04-23,3370.0,437.0,37083.0\n2020-04-24,2646.0,464.0,95273.0\n2020-04-25,3021.0,420.0,38676.0\n2020-04-26,2357.0,415.0,24113.0\n2020-04-27,2324.0,260.0,26678.0\n2020-04-28,1739.0,333.0,37554.0\n...\n\n\nCSVs: Eine durch Kommas getrennte Werte (CSV) Datei ist eine Textdatei, die ein Komma zur Trennung von Werten verwendet. Jede Zeile der Datei ist ein Datensatz. Jeder Datensatz besteht aus einem oder mehreren Feldern, die durch Kommas getrennt sind. Eine CSV-Datei speichert in der Regel tabellarische Daten (Zahlen und Text) im Klartext, in welchem Fall jede Zeile die gleiche Anzahl an Feldern haben wird.\n\n\n\n\n\n\n\n\n\nDie Datei enthält vier Tageszählungen für Covid-19 in Italien\nBei den gemeldeten Kennzahlen handelt es sich um neue Fälle, neue Todesfälle und neue Tests\nDie Daten werden für 248 Tage bereitgestellt: vom 12. Dezember 2019 bis zum 3. September 2020\n\n\n\n\n\n\n\n\n\n\n\n\npd.read_csv – Liest Daten aus einer CSV-Datei in ein Pandas-DataFrame-Objekt\n.info() – Grundlegende Informationen zu Zeilen, Spalten und Datentypen anzeigen\n.describe() – Statistische Informationen zu numerischen Spalten anzeigen\n.columns – Ruft die Liste der Spaltennamen ab\n.shape – Ermitteln Sie die Anzahl der Zeilen und Spalten als Tupel",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel6.html#abrufen-von-daten-aus-einem-data-frame",
    "href": "kapitel6.html#abrufen-von-daten-aus-einem-data-frame",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "7.2 Abrufen von Daten aus einem Data Frame",
    "text": "7.2 Abrufen von Daten aus einem Data Frame\nDas erste, was Sie möglicherweise tun möchten, ist, Daten aus diesem Data Frame abzurufen, z. B. die Zählungen eines bestimmten Tages oder der Liste der Werte in einer bestimmten Spalte. Hierzu kann es hilfreich sein, die interne Darstellung von Daten in einem Data Frame zu verstehen. Konzeptionell können Sie sich einen Data Frame als ein Dictionary mit Listen vorstellen: Die Schlüssel sind Spaltennamen und die Werte sind Listen/Arrays, die Daten für die jeweiligen Spalten enthalten.\n\n\nCode\n# Pandas format is simliar to this\ncovid_data_dict = {\n    'date':       ['2020-08-30', '2020-08-31', '2020-09-01', '2020-09-02', '2020-09-03'],\n    'new_cases':  [1444, 1365, 996, 975, 1326],\n    'new_deaths': [1, 4, 6, 8, 6],\n    'new_tests': [53541, 42583, 54395, None, None]\n}\n\n\nDie Darstellung von Daten im oben genannten Format hat einige Vorteile:\n\nAlle Werte in einer Spalte haben normalerweise denselben Werttyp, daher ist es effizienter, sie in einem einzelnen Array zu speichern.\nUm die Werte für eine bestimmte Zeile abzurufen, müssen lediglich die Elemente an einem bestimmten Index aus jedem der Spaltenarrays extrahiert werden.\nDie Darstellung ist kompakter (Spaltennamen werden nur einmal aufgezeichnet) im Vergleich zu anderen Formaten, bei denen Sie möglicherweise ein Dictionary für jede Datenzeile verwenden (siehe Beispiel unten).\n\n\n\nCode\n# Pandas format is not similar to this\ncovid_data_list = [\n    {'date': '2020-08-30', 'new_cases': 1444, 'new_deaths': 1, 'new_tests': 53541},\n    {'date': '2020-08-31', 'new_cases': 1365, 'new_deaths': 4, 'new_tests': 42583},\n    {'date': '2020-09-01', 'new_cases': 996, 'new_deaths': 6, 'new_tests': 54395},\n    {'date': '2020-09-02', 'new_cases': 975, 'new_deaths': 8 },\n    {'date': '2020-09-03', 'new_cases': 1326, 'new_deaths': 6},\n]\n\n\nUnter Berücksichtigung der Dictionary-Listen-Analogie können wir nun erraten, wie wir möglicherweise Daten aus einem Data Frame abrufen können. Beispielsweise können wir mithilfe der Indexierungsnotation [] eine Liste von Werten aus einer bestimmten Spalte abrufen.\n\n\nCode\ncovid_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n\n\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n\n\n\n\n248 rows × 4 columns\n\n\n\n\n\nCode\ncovid_data_dict['new_cases']\n\n\n[1444, 1365, 996, 975, 1326]\n\n\n\n\nCode\ncovid_df['new_cases']\n\n\n0         0.0\n1         0.0\n2         0.0\n3         0.0\n4         0.0\n        ...  \n243    1444.0\n244    1365.0\n245     996.0\n246     975.0\n247    1326.0\nName: new_cases, Length: 248, dtype: float64\n\n\nJede Spalte wird durch eine Datenstruktur namens Series dargestellt, die im Wesentlichen ein Numpy-Array mit einigen zusätzlichen Methoden und Eigenschaften ist.\n\n\nCode\ntype(covid_df['new_cases'])\n\n\npandas.core.series.Series\n\n\nGenau wie bei Arrays können Sie einen bestimmten Wert mit einer Reihe abrufen, indem Sie die Indexierungsnotation [] verwenden.\n\n\nCode\ncovid_df['new_cases'][246]\n\n\n975.0\n\n\n\n\nCode\ncovid_df['new_tests'][243]\n\n\n53541.0\n\n\nPandas bietet auch die Methode .at, um direkt eine bestimmte Zeile und Spalte abzurufen.\n\n\nCode\ncovid_df.at[246, 'new_cases']\n\n\n975.0\n\n\n\n\nCode\ncovid_df.at[240, 'new_tests']\n\n\n57640.0\n\n\nAnstatt die Indexierungsnotation [] zu verwenden, ermöglicht Pandas auch den Zugriff auf Spalten als Eigenschaften des Data Frames mithilfe der .-Notation. Diese Methode funktioniert jedoch nur für Spalten, deren Namen keine Leerzeichen oder Sonderzeichen enthalten.\n\n\nCode\n# Same as covid_df['new_cases']\ncovid_df.new_cases\n\n\n0         0.0\n1         0.0\n2         0.0\n3         0.0\n4         0.0\n        ...  \n243    1444.0\n244    1365.0\n245     996.0\n246     975.0\n247    1326.0\nName: new_cases, Length: 248, dtype: float64\n\n\nDarüber hinaus können Sie auch eine Liste von Spalten innerhalb der Indexierungsnotation [] übergeben, um nur mit den angegebenen Spalten auf eine Teilmenge des Data Frames zuzugreifen.\n\n\nCode\n# Note the double bracket, the first bracket is the indexing notation\ncases_df = covid_df[['date', 'new_cases']]\ncases_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\n\n\n\n\n0\n2019-12-31\n0.0\n\n\n1\n2020-01-01\n0.0\n\n\n2\n2020-01-02\n0.0\n\n\n3\n2020-01-03\n0.0\n\n\n4\n2020-01-04\n0.0\n\n\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n\n\n244\n2020-08-31\n1365.0\n\n\n245\n2020-09-01\n996.0\n\n\n246\n2020-09-02\n975.0\n\n\n247\n2020-09-03\n1326.0\n\n\n\n\n248 rows × 2 columns\n\n\n\nBeachten Sie jedoch, dass das neue Dataframe cases_df einfach eine “Ansicht” des ursprünglichen Dataframes covid_df ist, d.h. sie verweisen beide auf die gleichen Daten im Arbeitsspeicher des Computers, und das Ändern von Werten in einem von ihnen ändert auch die entsprechenden Werte im anderen. Das Teilen von Daten zwischen Dataframes macht die Datenmanipulation in Pandas blitzschnell, und Sie müssen sich keine Sorgen über den Overhead des Kopierens von Tausenden oder Millionen von Zeilen machen, jedes Mal wenn Sie ein neues Dataframe erstellen möchten, indem Sie auf einem bestehenden operieren.\nManchmal benötigen Sie eine vollständige Kopie des Dataframes, in diesem Fall können Sie die copy Methode verwenden.\n\n\nCode\ncovid_df_copy = covid_df.copy()\n\n\nDie Daten in covid_df_copy sind vollständig von covid_df getrennt und eine Änderung der Werte in einem von ihnen hat keine Auswirkungen auf das andere.\nUm auf eine bestimmte Datenzeile zuzugreifen, stellt Pandas die Methode .loc zur Verfügung.\n\n\nCode\ncovid_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n\n\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n\n\n\n\n248 rows × 4 columns\n\n\n\n\n\nCode\ncovid_df.loc[243]\n\n\ndate          2020-08-30\nnew_cases         1444.0\nnew_deaths           1.0\nnew_tests        53541.0\nName: 243, dtype: object\n\n\nJede abgerufene Zeile ist auch ein Series-Objekt.\n\n\nCode\ntype(covid_df.loc[243])\n\n\npandas.core.series.Series\n\n\nUm die ersten oder letzten Datenzeilen anzuzeigen, können wir die Methoden .head und .tail verwenden.\n\n\nCode\ncovid_df.head(5)\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n\n\n\n\n\n\n\n\n\nCode\ncovid_df.tail(4)\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n\n\n\n\n\n\n\nBeachten Sie oben, dass die ersten Werte in den Spalten new_cases und new_deaths zwar 0 sind, die entsprechenden Werte in der Spalte new_tests jedoch NaN sind. Das liegt daran, dass die CSV-Datei für bestimmte Daten keine Daten für die Spalte new_tests enthält (Sie können dies überprüfen, indem Sie in die Datei schauen). Es ist möglich, dass diese Werte fehlen oder unbekannt sind.\n\n\nCode\ncovid_df.at[0, 'new_tests']\n\n\nnan\n\n\n\n\nCode\ntype(covid_df.at[0, 'new_tests'])\n\n\nnumpy.float64\n\n\nDer Unterschied zwischen 0 und NaN ist subtil, aber wichtig. In diesem Datensatz wird dargestellt, dass an bestimmten Daten keine täglichen Testzahlen gemeldet wurden. Tatsächlich begann Italien am 19. April 2020 mit der Meldung täglicher Tests. Zu diesem Zeitpunkt waren bereits 935.310 Tests durchgeführt worden.\nMit der Methode first_valid_index einer Reihe können wir den ersten Index finden, der keinen NaN-Wert enthält.\n\n\nCode\ncovid_df.new_tests.first_valid_index()\n\n\n111\n\n\nSchauen wir uns einige Zeilen vor und nach diesem Index an, um zu überprüfen, ob sich die Werte tatsächlich von NaN in tatsächliche Zahlen ändern. Wir können dies tun, indem wir einen Bereich an loc übergeben.\n\n\nCode\ncovid_df.loc[108:113]\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n108\n2020-04-17\n3786.0\n525.0\nNaN\n\n\n109\n2020-04-18\n3493.0\n575.0\nNaN\n\n\n110\n2020-04-19\n3491.0\n480.0\nNaN\n\n\n111\n2020-04-20\n3047.0\n433.0\n7841.0\n\n\n112\n2020-04-21\n2256.0\n454.0\n28095.0\n\n\n113\n2020-04-22\n2729.0\n534.0\n44248.0\n\n\n\n\n\n\n\nDie Methode .sample kann verwendet werden, um eine zufällige Stichprobe von Zeilen aus dem Data Frame abzurufen.\n\n\nCode\ncovid_df.sample(10)\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n95\n2020-04-04\n4585.0\n764.0\nNaN\n\n\n137\n2020-05-16\n789.0\n242.0\n40657.0\n\n\n155\n2020-06-03\n318.0\n55.0\n20035.0\n\n\n42\n2020-02-11\n0.0\n0.0\nNaN\n\n\n32\n2020-02-01\n0.0\n0.0\nNaN\n\n\n60\n2020-02-29\n238.0\n4.0\nNaN\n\n\n39\n2020-02-08\n0.0\n0.0\nNaN\n\n\n215\n2020-08-02\n295.0\n5.0\n24496.0\n\n\n59\n2020-02-28\n250.0\n5.0\nNaN\n\n\n99\n2020-04-08\n3039.0\n604.0\nNaN\n\n\n\n\n\n\n\nBeachten Sie, dass der ursprüngliche Index jeder Zeile erhalten geblieben ist, obwohl wir eine Zufallsstichprobe genommen haben. Dies ist eine wichtige und nützliche Eigenschaft von einem Data Frame – jeder Datenzeile ist ein Index zugeordnet.\nHier ist eine Zusammenfassung der Funktionen und Methoden, die wir in diesem Abschnitt betrachtet haben:\n\ncovid_df['new_cases'] - Abrufen von Spalten als Serie mit einem Spaltennamen\nnew_cases[243] - Abrufen von Werten aus einer Serie mit einem Index\ncovid_df.at[243, 'new_cases'] - Einzelnen Wert aus einem DataFrame abrufen\ncovid_df.copy() - Erstellen einer tiefen Kopie eines DataFrames\ncovid_df.loc[243] - Abrufen einer Reihe oder eines Bereichs von Reihen von Daten aus dem DataFrame\nhead, tail und sample - Abrufen mehrerer Zeilen von Daten aus dem Data Frame\ncovid_df.new_tests.first_valid_index - Finden des ersten nicht-leeren Index in einer Serie",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel6.html#analysieren-von-daten-aus-dem-data-frame",
    "href": "kapitel6.html#analysieren-von-daten-aus-dem-data-frame",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "7.3 Analysieren von Daten aus dem Data Frame",
    "text": "7.3 Analysieren von Daten aus dem Data Frame\nVersuchen wir, einige Fragen zu unseren Daten zu beantworten.\nF: Wie hoch ist die Gesamtzahl der gemeldeten Fälle und Todesfälle im Zusammenhang mit Covid-19 in Italien?\nÄhnlich wie Numpy-Arrays unterstützt eine Pandas-Serie die sum-Methode zur Beantwortung dieser Fragen.\n\n\nCode\ntotal_cases = covid_df.new_cases.sum()\ntotal_deaths = covid_df.new_deaths.sum()\n\n\n\n\nCode\nprint('The number of reported cases is {} and the number of reported deaths is {}.'.format(int(total_cases), int(total_deaths)))\n\n\nThe number of reported cases is 271515 and the number of reported deaths is 35497.\n\n\nF: Wie hoch ist die Gesamtsterblichkeitsrate (Verhältnis der gemeldeten Todesfälle zu den gemeldeten Fällen)?\n\n\nCode\ndeath_rate = covid_df.new_deaths.sum() / covid_df.new_cases.sum()\n\n\n\n\nCode\nprint(\"The overall reported death rate in Italy is {:.2f} %.\".format(death_rate*100))\n\n\nThe overall reported death rate in Italy is 13.07 %.\n\n\nF: Wie viele Tests wurden insgesamt durchgeführt? Insgesamt wurden 935.310 Tests durchgeführt, bevor die täglichen Testzahlen gemeldet wurden.\nWir können den ersten Nicht-NaN-Index mit first_valid_index überprüfen\n\n\nCode\ninitial_tests = 935310\ntotal_tests = initial_tests + covid_df.new_tests.sum()\n\n\n\n\nCode\ntotal_tests\n\n\n5214766.0\n\n\nF: Welcher Teil des Tests ergab ein positives Ergebnis?\n\n\nCode\npositive_rate = total_cases / total_tests\n\n\n\n\nCode\nprint('{:.2f}% of tests in Italy led to a positive diagnosis.'.format(positive_rate*100))\n\n\n5.21% of tests in Italy led to a positive diagnosis.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel6.html#zeilen-abfragen-und-sortieren",
    "href": "kapitel6.html#zeilen-abfragen-und-sortieren",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "7.4 Zeilen abfragen und sortieren",
    "text": "7.4 Zeilen abfragen und sortieren\n\n7.4.1 Grundlagen\nNehmen wir an, wir wollen uns nur die Tage ansehen, an denen mehr als 1000 Fälle gemeldet wurden. Wir können einen booleschen Ausdruck verwenden, um zu überprüfen, welche Zeilen dieses Kriterium erfüllen.\n\n\nCode\nhigh_new_cases = covid_df.new_cases &gt; 1000\n\n\n\n\nCode\nhigh_new_cases\n\n\n0      False\n1      False\n2      False\n3      False\n4      False\n       ...  \n243     True\n244     True\n245    False\n246    False\n247     True\nName: new_cases, Length: 248, dtype: bool\n\n\nDer boolesche Ausdruck gibt eine Reihe mit booleschen Werten True und False zurück. Diese Reihe kann verwendet werden, um nur die Zeilen herauszufiltern, in denen der Wert in der Reihe True ist. Das Ergebnis ist ein Data Frame mit einer Teilmenge der Zeilen des Originals.\n\n\nCode\ncovid_df[high_new_cases]\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n68\n2020-03-08\n1247.0\n36.0\nNaN\n\n\n69\n2020-03-09\n1492.0\n133.0\nNaN\n\n\n70\n2020-03-10\n1797.0\n98.0\nNaN\n\n\n72\n2020-03-12\n2313.0\n196.0\nNaN\n\n\n73\n2020-03-13\n2651.0\n189.0\nNaN\n\n\n...\n...\n...\n...\n...\n\n\n241\n2020-08-28\n1409.0\n5.0\n65135.0\n\n\n242\n2020-08-29\n1460.0\n9.0\n64294.0\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n\n\n\n\n72 rows × 4 columns\n\n\n\nWir können dies prägnant in eine einzelne Zeile schreiben, indem wir den booleschen Ausdruck als Index an das Data Frame übergeben.\n\n\nCode\nhigh_cases_df = covid_df[covid_df.new_cases &gt; 1000]\n\n\n\n\nCode\nhigh_cases_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n68\n2020-03-08\n1247.0\n36.0\nNaN\n\n\n69\n2020-03-09\n1492.0\n133.0\nNaN\n\n\n70\n2020-03-10\n1797.0\n98.0\nNaN\n\n\n72\n2020-03-12\n2313.0\n196.0\nNaN\n\n\n73\n2020-03-13\n2651.0\n189.0\nNaN\n\n\n...\n...\n...\n...\n...\n\n\n241\n2020-08-28\n1409.0\n5.0\n65135.0\n\n\n242\n2020-08-29\n1460.0\n9.0\n64294.0\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n\n\n\n\n72 rows × 4 columns\n\n\n\nDas Data Frame enthält 72 Zeilen, aber der Kürze halber werden bei Jupyter standardmäßig nur die ersten 5 und die letzten 5 Zeilen angezeigt. Um alle Zeilen anzuzeigen, können wir einige Anzeigeoptionen ändern.\n\n\nCode\nfrom IPython.display import display\nwith pd.option_context('display.max_rows', 100):\n    display(covid_df[covid_df.new_cases &gt; 1000])\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n68\n2020-03-08\n1247.0\n36.0\nNaN\n\n\n69\n2020-03-09\n1492.0\n133.0\nNaN\n\n\n70\n2020-03-10\n1797.0\n98.0\nNaN\n\n\n72\n2020-03-12\n2313.0\n196.0\nNaN\n\n\n73\n2020-03-13\n2651.0\n189.0\nNaN\n\n\n74\n2020-03-14\n2547.0\n252.0\nNaN\n\n\n75\n2020-03-15\n3497.0\n173.0\nNaN\n\n\n76\n2020-03-16\n2823.0\n370.0\nNaN\n\n\n77\n2020-03-17\n4000.0\n347.0\nNaN\n\n\n78\n2020-03-18\n3526.0\n347.0\nNaN\n\n\n79\n2020-03-19\n4207.0\n473.0\nNaN\n\n\n80\n2020-03-20\n5322.0\n429.0\nNaN\n\n\n81\n2020-03-21\n5986.0\n625.0\nNaN\n\n\n82\n2020-03-22\n6557.0\n795.0\nNaN\n\n\n83\n2020-03-23\n5560.0\n649.0\nNaN\n\n\n84\n2020-03-24\n4789.0\n601.0\nNaN\n\n\n85\n2020-03-25\n5249.0\n743.0\nNaN\n\n\n86\n2020-03-26\n5210.0\n685.0\nNaN\n\n\n87\n2020-03-27\n6153.0\n660.0\nNaN\n\n\n88\n2020-03-28\n5959.0\n971.0\nNaN\n\n\n89\n2020-03-29\n5974.0\n887.0\nNaN\n\n\n90\n2020-03-30\n5217.0\n758.0\nNaN\n\n\n91\n2020-03-31\n4050.0\n810.0\nNaN\n\n\n92\n2020-04-01\n4053.0\n839.0\nNaN\n\n\n93\n2020-04-02\n4782.0\n727.0\nNaN\n\n\n94\n2020-04-03\n4668.0\n760.0\nNaN\n\n\n95\n2020-04-04\n4585.0\n764.0\nNaN\n\n\n96\n2020-04-05\n4805.0\n681.0\nNaN\n\n\n97\n2020-04-06\n4316.0\n527.0\nNaN\n\n\n98\n2020-04-07\n3599.0\n636.0\nNaN\n\n\n99\n2020-04-08\n3039.0\n604.0\nNaN\n\n\n100\n2020-04-09\n3836.0\n540.0\nNaN\n\n\n101\n2020-04-10\n4204.0\n612.0\nNaN\n\n\n102\n2020-04-11\n3951.0\n570.0\nNaN\n\n\n103\n2020-04-12\n4694.0\n619.0\nNaN\n\n\n104\n2020-04-13\n4092.0\n431.0\nNaN\n\n\n105\n2020-04-14\n3153.0\n564.0\nNaN\n\n\n106\n2020-04-15\n2972.0\n604.0\nNaN\n\n\n107\n2020-04-16\n2667.0\n578.0\nNaN\n\n\n108\n2020-04-17\n3786.0\n525.0\nNaN\n\n\n109\n2020-04-18\n3493.0\n575.0\nNaN\n\n\n110\n2020-04-19\n3491.0\n480.0\nNaN\n\n\n111\n2020-04-20\n3047.0\n433.0\n7841.0\n\n\n112\n2020-04-21\n2256.0\n454.0\n28095.0\n\n\n113\n2020-04-22\n2729.0\n534.0\n44248.0\n\n\n114\n2020-04-23\n3370.0\n437.0\n37083.0\n\n\n115\n2020-04-24\n2646.0\n464.0\n95273.0\n\n\n116\n2020-04-25\n3021.0\n420.0\n38676.0\n\n\n117\n2020-04-26\n2357.0\n415.0\n24113.0\n\n\n118\n2020-04-27\n2324.0\n260.0\n26678.0\n\n\n119\n2020-04-28\n1739.0\n333.0\n37554.0\n\n\n120\n2020-04-29\n2091.0\n382.0\n38589.0\n\n\n121\n2020-04-30\n2086.0\n323.0\n41441.0\n\n\n122\n2020-05-01\n1872.0\n285.0\n43732.0\n\n\n123\n2020-05-02\n1965.0\n269.0\n31231.0\n\n\n124\n2020-05-03\n1900.0\n474.0\n27047.0\n\n\n125\n2020-05-04\n1389.0\n174.0\n22999.0\n\n\n126\n2020-05-05\n1221.0\n195.0\n32211.0\n\n\n127\n2020-05-06\n1075.0\n236.0\n37771.0\n\n\n128\n2020-05-07\n1444.0\n369.0\n13665.0\n\n\n129\n2020-05-08\n1401.0\n274.0\n45428.0\n\n\n130\n2020-05-09\n1327.0\n243.0\n36091.0\n\n\n131\n2020-05-10\n1083.0\n194.0\n31384.0\n\n\n134\n2020-05-13\n1402.0\n172.0\n37049.0\n\n\n236\n2020-08-23\n1071.0\n3.0\n47463.0\n\n\n237\n2020-08-24\n1209.0\n7.0\n33358.0\n\n\n240\n2020-08-27\n1366.0\n13.0\n57640.0\n\n\n241\n2020-08-28\n1409.0\n5.0\n65135.0\n\n\n242\n2020-08-29\n1460.0\n9.0\n64294.0\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n\n\n\n\n\n\n\nWir können auch komplexere Abfragen formulieren, die mehrere Spalten umfassen. Versuchen wir beispielsweise, die Tage zu ermitteln, an denen das Verhältnis der gemeldeten Fälle zu den durchgeführten Tests höher ist als die Gesamt-positive_rate.\n\n\nCode\npositive_rate\n\n\n0.05206657403227681\n\n\n\n\nCode\nhigh_ratio_df = covid_df[covid_df.new_cases / covid_df.new_tests &gt; positive_rate]\n\n\n\n\nCode\nhigh_ratio_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n111\n2020-04-20\n3047.0\n433.0\n7841.0\n\n\n112\n2020-04-21\n2256.0\n454.0\n28095.0\n\n\n113\n2020-04-22\n2729.0\n534.0\n44248.0\n\n\n114\n2020-04-23\n3370.0\n437.0\n37083.0\n\n\n116\n2020-04-25\n3021.0\n420.0\n38676.0\n\n\n117\n2020-04-26\n2357.0\n415.0\n24113.0\n\n\n118\n2020-04-27\n2324.0\n260.0\n26678.0\n\n\n120\n2020-04-29\n2091.0\n382.0\n38589.0\n\n\n123\n2020-05-02\n1965.0\n269.0\n31231.0\n\n\n124\n2020-05-03\n1900.0\n474.0\n27047.0\n\n\n125\n2020-05-04\n1389.0\n174.0\n22999.0\n\n\n128\n2020-05-07\n1444.0\n369.0\n13665.0\n\n\n\n\n\n\n\nDas Ausführen von Operationen an mehreren Spalten führt zu einer neuen Serie.\n\n\nCode\ncovid_df.new_cases / covid_df.new_tests\n\n\n0           NaN\n1           NaN\n2           NaN\n3           NaN\n4           NaN\n         ...   \n243    0.026970\n244    0.032055\n245    0.018311\n246         NaN\n247         NaN\nLength: 248, dtype: float64\n\n\nDarüber hinaus können wir diese Series verwenden, um dem Data Frame eine neue Spalte hinzuzufügen.\n\n\nCode\ncovid_df['positive_rate'] = covid_df.new_cases / covid_df.new_tests\n\n\n\n\nCode\ncovid_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\npositive_rate\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\nNaN\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\nNaN\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\nNaN\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\nNaN\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n0.026970\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n0.032055\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n0.018311\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\nNaN\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\nNaN\n\n\n\n\n248 rows × 5 columns\n\n\n\nBeachten Sie jedoch, dass es manchmal einige Tage dauert, bis die Ergebnisse eines Tests vorliegen, sodass wir die Anzahl neuer Fälle nicht wirklich mit der Anzahl der am selben Tag durchgeführten Tests vergleichen können. Jede Schlussfolgerung, die auf dieser Spalte positive_rate basiert, ist wahrscheinlich falsch. Es ist wichtig, auf subtile Beziehungen wie diese zu achten, die oft nicht in der CSV-Datei vermittelt werden und einen externen Kontext erfordern. Es ist immer eine gute Idee, die mit dem Datensatz gelieferte Dokumentation durchzulesen oder weitere Informationen anzufordern.\nEntfernen wir zunächst die Spalte positive_rate mit der drop-Methode.\n\n\nCode\ncovid_df.drop(columns=['positive_rate'], inplace=True)\n\n\nKönnen Sie herausfinden, wofür das inplace-Argument verwendet wird?\n\n\nCode\ncovid_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n\n\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n\n\n\n\n248 rows × 4 columns\n\n\n\n\n\n7.4.2 Zeilen anhand von Spaltenwerten sortieren\nDie Zeilen können mit .sort_values auch nach einer bestimmten Spalte sortiert werden. Sortieren wir, um die Tage mit der höchsten Anzahl an Fällen zu identifizieren, und verketten wir sie dann mit der head-Methode, um die 10 Tage mit den meisten Fällen zu erhalten.\n\n\nCode\ncovid_df.sort_values('new_cases', ascending=False).head(10)\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n82\n2020-03-22\n6557.0\n795.0\nNaN\n\n\n87\n2020-03-27\n6153.0\n660.0\nNaN\n\n\n81\n2020-03-21\n5986.0\n625.0\nNaN\n\n\n89\n2020-03-29\n5974.0\n887.0\nNaN\n\n\n88\n2020-03-28\n5959.0\n971.0\nNaN\n\n\n83\n2020-03-23\n5560.0\n649.0\nNaN\n\n\n80\n2020-03-20\n5322.0\n429.0\nNaN\n\n\n85\n2020-03-25\n5249.0\n743.0\nNaN\n\n\n90\n2020-03-30\n5217.0\n758.0\nNaN\n\n\n86\n2020-03-26\n5210.0\n685.0\nNaN\n\n\n\n\n\n\n\nEs sieht so aus, als ob die letzten beiden Märzwochen die höchste Anzahl täglicher Fälle verzeichneten. Vergleichen wir dies mit den Tagen, an denen die meisten Todesfälle verzeichnet wurden.\n\n\nCode\ncovid_df.sort_values('new_deaths', ascending=False).head(10)\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n88\n2020-03-28\n5959.0\n971.0\nNaN\n\n\n89\n2020-03-29\n5974.0\n887.0\nNaN\n\n\n92\n2020-04-01\n4053.0\n839.0\nNaN\n\n\n91\n2020-03-31\n4050.0\n810.0\nNaN\n\n\n82\n2020-03-22\n6557.0\n795.0\nNaN\n\n\n95\n2020-04-04\n4585.0\n764.0\nNaN\n\n\n94\n2020-04-03\n4668.0\n760.0\nNaN\n\n\n90\n2020-03-30\n5217.0\n758.0\nNaN\n\n\n85\n2020-03-25\n5249.0\n743.0\nNaN\n\n\n93\n2020-04-02\n4782.0\n727.0\nNaN\n\n\n\n\n\n\n\nEs scheint, dass die täglichen Todesfälle etwa eine Woche nach dem Höhepunkt der täglichen Neuerkrankungen ihren Höhepunkt erreichen.\nSchauen wir uns auch die Tage mit den wenigsten Fällen an. Wir können davon ausgehen, dass wir in dieser Liste die ersten Tage des Jahres sehen werden.\n\n\nCode\ncovid_df.sort_values('new_cases').head(10)\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n172\n2020-06-20\n-148.0\n47.0\n29875.0\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n\n\n29\n2020-01-29\n0.0\n0.0\nNaN\n\n\n30\n2020-01-30\n0.0\n0.0\nNaN\n\n\n32\n2020-02-01\n0.0\n0.0\nNaN\n\n\n33\n2020-02-02\n0.0\n0.0\nNaN\n\n\n34\n2020-02-03\n0.0\n0.0\nNaN\n\n\n36\n2020-02-05\n0.0\n0.0\nNaN\n\n\n37\n2020-02-06\n0.0\n0.0\nNaN\n\n\n38\n2020-02-07\n0.0\n0.0\nNaN\n\n\n\n\n\n\n\nScheint, als ob die Zahl der neuen Fälle am 20. Juni bei -148 lag, eine negative Zahl! Das hätten wir vielleicht nicht erwartet, aber das liegt in der Natur von Daten aus der realen Welt. Es könnte sich einfach um einen Dateneingabefehler handeln, oder es ist möglich, dass die Regierung eine Korrektur vorgenommen hat, um Fehlzählungen in der Vergangenheit zu berücksichtigen. Können Sie Nachrichtenartikel online durchforsten und herausfinden, warum die Zahl negativ war?\nSchauen wir uns einige Tage vor und nach dem 20. Juni an.\n\n\nCode\ncovid_df.loc[169:175]\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n169\n2020-06-17\n210.0\n34.0\n33957.0\n\n\n170\n2020-06-18\n328.0\n43.0\n32921.0\n\n\n171\n2020-06-19\n331.0\n66.0\n28570.0\n\n\n172\n2020-06-20\n-148.0\n47.0\n29875.0\n\n\n173\n2020-06-21\n264.0\n49.0\n24581.0\n\n\n174\n2020-06-22\n224.0\n24.0\n16152.0\n\n\n175\n2020-06-23\n221.0\n23.0\n23225.0\n\n\n\n\n\n\n\nWenn es sich tatsächlich um einen Dateneingabefehler handelte, können wir einen der folgenden Ansätze verwenden, um mit dem fehlenden oder fehlerhaften Wert umzugehen: 1. Ersetzen Sie es durch 0. 2. Ersetzen Sie ihn durch den Durchschnitt der gesamten Spalte 3. Ersetzen Sie es durch den Durchschnitt der Werte am vorherigen und nächsten Datum 4. Verwerfen Sie die Zeile vollständig\nFür welchen Ansatz Sie sich entscheiden, erfordert einen gewissen Kontext zu den Daten und dem Problem. Da es sich in diesem Fall um nach Datum geordnete Daten handelt, können wir Ansatz 3 wählen.\nDie Methode .at kann verwendet werden, um einen bestimmten Wert innerhalb des Data Frames zu ändern.\n\n\nCode\ncovid_df.at[172, 'new_cases'] = (covid_df.at[171, 'new_cases'] + covid_df.at[173, 'new_cases'])/2\n\n\n\n\nCode\ncovid_df.loc[169:175]\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n169\n2020-06-17\n210.0\n34.0\n33957.0\n\n\n170\n2020-06-18\n328.0\n43.0\n32921.0\n\n\n171\n2020-06-19\n331.0\n66.0\n28570.0\n\n\n172\n2020-06-20\n297.5\n47.0\n29875.0\n\n\n173\n2020-06-21\n264.0\n49.0\n24581.0\n\n\n174\n2020-06-22\n224.0\n24.0\n16152.0\n\n\n175\n2020-06-23\n221.0\n23.0\n23225.0\n\n\n\n\n\n\n\nHier ist eine Zusammenfassung der Funktionen und Methoden, die wir in diesem Abschnitt betrachtet haben:\n\ncovid_df.new_cases.sum() - die Summe der Werte in einer Spalte oder Serie finden\ncovid_df[covid_df.new_cases &gt; 1000] - Abfrage einer Teilmenge von Zeilen, die die gewählten Kriterien erfüllen, mit Hilfe von booleschen Ausdrücken\ndf['pos_rate'] = df.new_cases/df.new_tests - Hinzufügen neuer Spalten durch Kombination von Daten aus bestehenden Spalten\ncovid_df.drop('positive_rate') - Entfernen einer oder mehrerer Spalten aus dem DataFrame\nsort_values - Sortieren der Zeilen eines DataFrame nach Spaltenwerten\ncovid_df.at[172, 'new_cases'] = ... - Ersetzen eines Wertes innerhalb des DataFrame",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel6.html#mit-datumsangaben-arbeiten",
    "href": "kapitel6.html#mit-datumsangaben-arbeiten",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "7.5 Mit Datumsangaben arbeiten",
    "text": "7.5 Mit Datumsangaben arbeiten\nWährend wir uns die Gesamtzahlen für Fälle, Tests, Positivraten usw. angesehen haben, wäre es auch nützlich, diese Zahlen auf monatlicher Basis zu untersuchen. Die Spalte date könnte hier nützlich sein, da Pandas viele Dienstprogramme zum Arbeiten mit Datumsangaben bereitstellt.\n\n\nCode\ncovid_df.date\n\n\n0      2019-12-31\n1      2020-01-01\n2      2020-01-02\n3      2020-01-03\n4      2020-01-04\n          ...    \n243    2020-08-30\n244    2020-08-31\n245    2020-09-01\n246    2020-09-02\n247    2020-09-03\nName: date, Length: 248, dtype: object\n\n\nDer Datentyp des Datums ist derzeit object, sodass Pandas nicht weiß, dass es sich bei dieser Spalte um ein Datum handelt. Wir können es mit der Methode pd.to_datetime in eine datetime-Spalte konvertieren.\n\n\nCode\ncovid_df['date'] = pd.to_datetime(covid_df.date)\n\n\n\n\nCode\ncovid_df['date']\n\n\n0     2019-12-31\n1     2020-01-01\n2     2020-01-02\n3     2020-01-03\n4     2020-01-04\n         ...    \n243   2020-08-30\n244   2020-08-31\n245   2020-09-01\n246   2020-09-02\n247   2020-09-03\nName: date, Length: 248, dtype: datetime64[ns]\n\n\nSie können sehen, dass es jetzt den Datentyp datetime64 hat. Mit der Klasse DatetimeIndex (Link) können wir jetzt verschiedene Teile der Daten in separate Spalten extrahieren.\n\n\nCode\ncovid_df['year'] = pd.DatetimeIndex(covid_df.date).year\ncovid_df['month'] = pd.DatetimeIndex(covid_df.date).month\ncovid_df['day'] = pd.DatetimeIndex(covid_df.date).day\ncovid_df['weekday'] = pd.DatetimeIndex(covid_df.date).weekday\n\n\n\n\nCode\ncovid_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\nyear\nmonth\nday\nweekday\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n2019\n12\n31\n1\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n2020\n1\n1\n2\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n2020\n1\n2\n3\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n2020\n1\n3\n4\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n2020\n1\n4\n5\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n2020\n8\n30\n6\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n2020\n8\n31\n0\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n2020\n9\n1\n1\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n2020\n9\n2\n2\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n2020\n9\n3\n3\n\n\n\n\n248 rows × 8 columns\n\n\n\nSehen wir uns die Gesamtkennzahlen für den Monat Mai an. Wir können die Zeilen für Mai abfragen, eine Teilmenge der Spalten auswählen, die wir aggregieren möchten, und die sum-Methode des Data Frames verwenden, um die Summe der Werte in jeder ausgewählten Spalte zu erhalten.\n\n\nCode\n# Query the rows for May\ncovid_df_may = covid_df[covid_df.month == 5]\ncovid_df_may\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\nyear\nmonth\nday\nweekday\n\n\n\n\n122\n2020-05-01\n1872.0\n285.0\n43732.0\n2020\n5\n1\n4\n\n\n123\n2020-05-02\n1965.0\n269.0\n31231.0\n2020\n5\n2\n5\n\n\n124\n2020-05-03\n1900.0\n474.0\n27047.0\n2020\n5\n3\n6\n\n\n125\n2020-05-04\n1389.0\n174.0\n22999.0\n2020\n5\n4\n0\n\n\n126\n2020-05-05\n1221.0\n195.0\n32211.0\n2020\n5\n5\n1\n\n\n127\n2020-05-06\n1075.0\n236.0\n37771.0\n2020\n5\n6\n2\n\n\n128\n2020-05-07\n1444.0\n369.0\n13665.0\n2020\n5\n7\n3\n\n\n129\n2020-05-08\n1401.0\n274.0\n45428.0\n2020\n5\n8\n4\n\n\n130\n2020-05-09\n1327.0\n243.0\n36091.0\n2020\n5\n9\n5\n\n\n131\n2020-05-10\n1083.0\n194.0\n31384.0\n2020\n5\n10\n6\n\n\n132\n2020-05-11\n802.0\n165.0\n25823.0\n2020\n5\n11\n0\n\n\n133\n2020-05-12\n744.0\n179.0\n39620.0\n2020\n5\n12\n1\n\n\n134\n2020-05-13\n1402.0\n172.0\n37049.0\n2020\n5\n13\n2\n\n\n135\n2020-05-14\n888.0\n195.0\n41131.0\n2020\n5\n14\n3\n\n\n136\n2020-05-15\n992.0\n262.0\n39027.0\n2020\n5\n15\n4\n\n\n137\n2020-05-16\n789.0\n242.0\n40657.0\n2020\n5\n16\n5\n\n\n138\n2020-05-17\n875.0\n153.0\n33505.0\n2020\n5\n17\n6\n\n\n139\n2020-05-18\n675.0\n145.0\n26101.0\n2020\n5\n18\n0\n\n\n140\n2020-05-19\n451.0\n99.0\n40226.0\n2020\n5\n19\n1\n\n\n141\n2020-05-20\n813.0\n162.0\n38617.0\n2020\n5\n20\n2\n\n\n142\n2020-05-21\n665.0\n161.0\n40644.0\n2020\n5\n21\n3\n\n\n143\n2020-05-22\n642.0\n156.0\n42987.0\n2020\n5\n22\n4\n\n\n144\n2020-05-23\n652.0\n130.0\n42579.0\n2020\n5\n23\n5\n\n\n145\n2020-05-24\n669.0\n119.0\n34206.0\n2020\n5\n24\n6\n\n\n146\n2020-05-25\n531.0\n50.0\n20676.0\n2020\n5\n25\n0\n\n\n147\n2020-05-26\n300.0\n92.0\n33944.0\n2020\n5\n26\n1\n\n\n148\n2020-05-27\n397.0\n78.0\n37299.0\n2020\n5\n27\n2\n\n\n149\n2020-05-28\n584.0\n117.0\n39838.0\n2020\n5\n28\n3\n\n\n150\n2020-05-29\n593.0\n70.0\n38233.0\n2020\n5\n29\n4\n\n\n151\n2020-05-30\n516.0\n87.0\n36051.0\n2020\n5\n30\n5\n\n\n152\n2020-05-31\n416.0\n111.0\n28948.0\n2020\n5\n31\n6\n\n\n\n\n\n\n\n\n\nCode\n# Extract the subset of columns to be aggregated\ncovid_df_may_metrics = covid_df_may[['new_cases', 'new_deaths', 'new_tests']]\ncovid_df_may_metrics\n\n\n\n\n\n\n\n\n\nnew_cases\nnew_deaths\nnew_tests\n\n\n\n\n122\n1872.0\n285.0\n43732.0\n\n\n123\n1965.0\n269.0\n31231.0\n\n\n124\n1900.0\n474.0\n27047.0\n\n\n125\n1389.0\n174.0\n22999.0\n\n\n126\n1221.0\n195.0\n32211.0\n\n\n127\n1075.0\n236.0\n37771.0\n\n\n128\n1444.0\n369.0\n13665.0\n\n\n129\n1401.0\n274.0\n45428.0\n\n\n130\n1327.0\n243.0\n36091.0\n\n\n131\n1083.0\n194.0\n31384.0\n\n\n132\n802.0\n165.0\n25823.0\n\n\n133\n744.0\n179.0\n39620.0\n\n\n134\n1402.0\n172.0\n37049.0\n\n\n135\n888.0\n195.0\n41131.0\n\n\n136\n992.0\n262.0\n39027.0\n\n\n137\n789.0\n242.0\n40657.0\n\n\n138\n875.0\n153.0\n33505.0\n\n\n139\n675.0\n145.0\n26101.0\n\n\n140\n451.0\n99.0\n40226.0\n\n\n141\n813.0\n162.0\n38617.0\n\n\n142\n665.0\n161.0\n40644.0\n\n\n143\n642.0\n156.0\n42987.0\n\n\n144\n652.0\n130.0\n42579.0\n\n\n145\n669.0\n119.0\n34206.0\n\n\n146\n531.0\n50.0\n20676.0\n\n\n147\n300.0\n92.0\n33944.0\n\n\n148\n397.0\n78.0\n37299.0\n\n\n149\n584.0\n117.0\n39838.0\n\n\n150\n593.0\n70.0\n38233.0\n\n\n151\n516.0\n87.0\n36051.0\n\n\n152\n416.0\n111.0\n28948.0\n\n\n\n\n\n\n\n\n\nCode\n# Get the column-wise sum\ncovid_may_totals = covid_df_may_metrics.sum()\ncovid_may_totals\n\n\nnew_cases       29073.0\nnew_deaths       5658.0\nnew_tests     1078720.0\ndtype: float64\n\n\n\n\nCode\n# Query the rows for May\ncovid_df_may = covid_df[covid_df.month == 5]\n\n# Extract the subset of columns to be aggregated\ncovid_df_may_metrics = covid_df_may[['new_cases', 'new_deaths', 'new_tests']]\n\n# Get the column-wise sum\ncovid_may_totals = covid_df_may_metrics.sum()\n\n\n\n\nCode\ncovid_may_totals\n\n\nnew_cases       29073.0\nnew_deaths       5658.0\nnew_tests     1078720.0\ndtype: float64\n\n\n\n\nCode\ntype(covid_may_totals)\n\n\npandas.core.series.Series\n\n\nDie oben genannten Operationen können auch in einer einzigen Anweisung kombiniert werden.\n\n\nCode\ncovid_df[covid_df.month == 5][['new_cases', 'new_deaths', 'new_tests']].sum()\n\n\nnew_cases       29073.0\nnew_deaths       5658.0\nnew_tests     1078720.0\ndtype: float64\n\n\nHier ist ein weiteres Beispiel: Lassen Sie uns prüfen, ob die Anzahl der sonntags gemeldeten Fälle höher ist als die durchschnittliche Anzahl der täglich gemeldeten Fälle. Dieses Mal möchten wir mit der Methode .mean aggregieren.\n\n\nCode\n# Overall average\ncovid_df.new_cases.mean()\n\n\n1096.6149193548388\n\n\n\n\nCode\n# Average for Sundays\ncovid_df[covid_df.weekday == 6].new_cases.mean()\n\n\n1247.2571428571428\n\n\nEs scheint, dass an Sonntagen mehr Fälle gemeldet wurden als an anderen Tagen.\nVersuchen Sie, mithilfe der folgenden Zellen weitere datumsbezogene Fragen zu den Daten zu stellen und zu beantworten.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel6.html#gruppierung-und-aggregation",
    "href": "kapitel6.html#gruppierung-und-aggregation",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "7.6 Gruppierung und Aggregation",
    "text": "7.6 Gruppierung und Aggregation\nAls nächsten Schritt möchten wir die Tagesdaten zusammenfassen und ein neues Data Frame mit Monatsdaten erstellen. Hier ist die groupby-Funktion nützlich. Zusammen mit einer Gruppierung müssen wir eine Option angeben, die Daten für jede Gruppe zu aggregieren.\n\n\nCode\ncovid_month_df = covid_df.groupby('month')[['new_cases', 'new_deaths', 'new_tests']].sum()\n\n\n\n\nCode\ncovid_month_df\n\n\n\n\n\n\n\n\n\nnew_cases\nnew_deaths\nnew_tests\n\n\nmonth\n\n\n\n\n\n\n\n1\n3.0\n0.0\n0.0\n\n\n2\n885.0\n21.0\n0.0\n\n\n3\n100851.0\n11570.0\n0.0\n\n\n4\n101852.0\n16091.0\n419591.0\n\n\n5\n29073.0\n5658.0\n1078720.0\n\n\n6\n8217.5\n1404.0\n830354.0\n\n\n7\n6722.0\n388.0\n797692.0\n\n\n8\n21060.0\n345.0\n1098704.0\n\n\n9\n3297.0\n20.0\n54395.0\n\n\n12\n0.0\n0.0\n0.0\n\n\n\n\n\n\n\nDas Ergebnis ist ein neues Data Frame, das eindeutige Werte aus der an groupby übergebenen Spalte als Index verwendet. Gruppierung und Aggregation sind eine wirklich leistungsstarke Methode, um Daten schrittweise in kleineren Data Frames zusammenzufassen.\nAnstatt nach der Summe zu aggregieren, können Sie auch nach anderen Kennzahlen wie dem Mittelwert aggregieren\n\n\nCode\ncovid_month_mean_df = covid_df.groupby('month')[['new_cases', 'new_deaths', 'new_tests']].mean()\n\n\n\n\nCode\ncovid_month_mean_df\n\n\n\n\n\n\n\n\n\nnew_cases\nnew_deaths\nnew_tests\n\n\nmonth\n\n\n\n\n\n\n\n1\n0.096774\n0.000000\nNaN\n\n\n2\n30.517241\n0.724138\nNaN\n\n\n3\n3253.258065\n373.225806\nNaN\n\n\n4\n3395.066667\n536.366667\n38144.636364\n\n\n5\n937.838710\n182.516129\n34797.419355\n\n\n6\n273.916667\n46.800000\n27678.466667\n\n\n7\n216.838710\n12.516129\n25732.000000\n\n\n8\n679.354839\n11.129032\n35442.064516\n\n\n9\n1099.000000\n6.666667\n54395.000000\n\n\n12\n0.000000\n0.000000\nNaN\n\n\n\n\n\n\n\nNeben der Gruppierung besteht eine weitere Form der Aggregation darin, für jede Zeile die laufende oder kumulative Summe der Fälle, Tests oder Todesfälle bis zum aktuellen Datum zu berechnen. Dies kann mit der cumsum-Methode erfolgen. Fügen wir drei neue Spalten hinzu: total_cases, total_deaths und total_tests.\n\n\nCode\ncovid_df['total_cases'] = covid_df.new_cases.cumsum()\n\n\n\n\nCode\ncovid_df['total_deaths'] = covid_df.new_deaths.cumsum()\n\n\n\n\nCode\ncovid_df['total_tests'] = covid_df.new_tests.cumsum() + initial_tests\n\n\nWir haben auch die anfängliche Testanzahl in total_test aufgenommen, um Tests zu berücksichtigen, die vor Beginn der täglichen Berichterstattung durchgeführt wurden.\n\n\nCode\ncovid_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\nyear\nmonth\nday\nweekday\ntotal_cases\ntotal_deaths\ntotal_tests\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n2019\n12\n31\n1\n0.0\n0.0\nNaN\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n2020\n1\n1\n2\n0.0\n0.0\nNaN\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n2020\n1\n2\n3\n0.0\n0.0\nNaN\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n2020\n1\n3\n4\n0.0\n0.0\nNaN\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n2020\n1\n4\n5\n0.0\n0.0\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n2020\n8\n30\n6\n267298.5\n35473.0\n5117788.0\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n2020\n8\n31\n0\n268663.5\n35477.0\n5160371.0\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n2020\n9\n1\n1\n269659.5\n35483.0\n5214766.0\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n2020\n9\n2\n2\n270634.5\n35491.0\nNaN\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n2020\n9\n3\n3\n271960.5\n35497.0\nNaN\n\n\n\n\n248 rows × 11 columns\n\n\n\nBeachten Sie, dass die NaN-Werte in der Spalte total_tests davon unberührt bleiben.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel6.html#daten-aus-mehreren-quellen-zusammenführen",
    "href": "kapitel6.html#daten-aus-mehreren-quellen-zusammenführen",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "7.7 Daten aus mehreren Quellen zusammenführen",
    "text": "7.7 Daten aus mehreren Quellen zusammenführen\nUm andere Kennzahlen wie Tests pro Million, Fälle pro Million usw. zu ermitteln, benötigen wir weitere Informationen über das Land, nämlich. seine Bevölkerung. Laden wir eine weitere Datei locations.csv herunter, die gesundheitsbezogene Informationen für verschiedene Länder auf der ganzen Welt, einschließlich Italien, enthält.\n\n\nCode\nlocations_df = pd.read_csv('data/locations.csv')\n\n\n\n\nCode\nlocations_df\n\n\n\n\n\n\n\n\n\nlocation\ncontinent\npopulation\nlife_expectancy\nhospital_beds_per_thousand\ngdp_per_capita\n\n\n\n\n0\nAfghanistan\nAsia\n3.892834e+07\n64.83\n0.500\n1803.987\n\n\n1\nAlbania\nEurope\n2.877800e+06\n78.57\n2.890\n11803.431\n\n\n2\nAlgeria\nAfrica\n4.385104e+07\n76.88\n1.900\n13913.839\n\n\n3\nAndorra\nEurope\n7.726500e+04\n83.73\nNaN\nNaN\n\n\n4\nAngola\nAfrica\n3.286627e+07\n61.15\nNaN\n5819.495\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n207\nYemen\nAsia\n2.982597e+07\n66.12\n0.700\n1479.147\n\n\n208\nZambia\nAfrica\n1.838396e+07\n63.89\n2.000\n3689.251\n\n\n209\nZimbabwe\nAfrica\n1.486293e+07\n61.49\n1.700\n1899.775\n\n\n210\nWorld\nNaN\n7.794799e+09\n72.58\n2.705\n15469.207\n\n\n211\nInternational\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n212 rows × 6 columns\n\n\n\n\n\nCode\nlocations_df[locations_df.location == \"Italy\"]\n\n\n\n\n\n\n\n\n\nlocation\ncontinent\npopulation\nlife_expectancy\nhospital_beds_per_thousand\ngdp_per_capita\n\n\n\n\n97\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n\n\n\n\n\nWir können diese Daten in unser bestehendes Data Frame einbinden, indem wir weitere Spalten hinzufügen. Um jedoch zwei Data Frames zusammenzuführen, benötigen wir mindestens eine gemeinsame Spalte. Fügen wir also eine Spalte location in das Data Frame covid_df ein, wobei alle Werte auf \"Italy\" eingestellt sind.\n\n\nCode\ncovid_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\nyear\nmonth\nday\nweekday\ntotal_cases\ntotal_deaths\ntotal_tests\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n2019\n12\n31\n1\n0.0\n0.0\nNaN\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n2020\n1\n1\n2\n0.0\n0.0\nNaN\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n2020\n1\n2\n3\n0.0\n0.0\nNaN\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n2020\n1\n3\n4\n0.0\n0.0\nNaN\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n2020\n1\n4\n5\n0.0\n0.0\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n2020\n8\n30\n6\n267298.5\n35473.0\n5117788.0\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n2020\n8\n31\n0\n268663.5\n35477.0\n5160371.0\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n2020\n9\n1\n1\n269659.5\n35483.0\n5214766.0\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n2020\n9\n2\n2\n270634.5\n35491.0\nNaN\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n2020\n9\n3\n3\n271960.5\n35497.0\nNaN\n\n\n\n\n248 rows × 11 columns\n\n\n\n\n\nCode\ncovid_df['location'] = \"Italy\"\n\n\n\n\nCode\ncovid_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\nyear\nmonth\nday\nweekday\ntotal_cases\ntotal_deaths\ntotal_tests\nlocation\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n2019\n12\n31\n1\n0.0\n0.0\nNaN\nItaly\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n2020\n1\n1\n2\n0.0\n0.0\nNaN\nItaly\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n2020\n1\n2\n3\n0.0\n0.0\nNaN\nItaly\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n2020\n1\n3\n4\n0.0\n0.0\nNaN\nItaly\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n2020\n1\n4\n5\n0.0\n0.0\nNaN\nItaly\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n2020\n8\n30\n6\n267298.5\n35473.0\n5117788.0\nItaly\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n2020\n8\n31\n0\n268663.5\n35477.0\n5160371.0\nItaly\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n2020\n9\n1\n1\n269659.5\n35483.0\n5214766.0\nItaly\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n2020\n9\n2\n2\n270634.5\n35491.0\nNaN\nItaly\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n2020\n9\n3\n3\n271960.5\n35497.0\nNaN\nItaly\n\n\n\n\n248 rows × 12 columns\n\n\n\nWir können jetzt die Spalten von locations_df in covid_df hinzufügen, indem wir die Methode .merge verwenden.\n\n\nCode\nmerged_df = covid_df.merge(locations_df, on=\"location\")\n\n\n\n\nCode\nmerged_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\nyear\nmonth\nday\nweekday\ntotal_cases\ntotal_deaths\ntotal_tests\nlocation\ncontinent\npopulation\nlife_expectancy\nhospital_beds_per_thousand\ngdp_per_capita\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n2019\n12\n31\n1\n0.0\n0.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n2020\n1\n1\n2\n0.0\n0.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n2020\n1\n2\n3\n0.0\n0.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n2020\n1\n3\n4\n0.0\n0.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n2020\n1\n4\n5\n0.0\n0.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n2020\n8\n30\n6\n267298.5\n35473.0\n5117788.0\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n2020\n8\n31\n0\n268663.5\n35477.0\n5160371.0\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n2020\n9\n1\n1\n269659.5\n35483.0\n5214766.0\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n2020\n9\n2\n2\n270634.5\n35491.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n2020\n9\n3\n3\n271960.5\n35497.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n\n\n\n\n248 rows × 17 columns\n\n\n\nDie Standortdaten für Italien werden an jede Zeile in covid_df angehängt. Wenn das Data Frame covid_df Daten für mehrere Standorte enthalten würde, würden die standortersetzten Daten für das jeweilige Land für jede Zeile angehängt.\nWir können jetzt Kennzahlen wie Fälle pro Million, Todesfälle pro Million und Tests pro Million berechnen.\n\n\nCode\nmerged_df['cases_per_million'] = merged_df.total_cases * 1e6 / merged_df.population\n\n\n\n\nCode\nmerged_df['deaths_per_million'] = merged_df.total_deaths * 1e6 / merged_df.population\n\n\n\n\nCode\nmerged_df['tests_per_million'] = merged_df.total_tests * 1e6 / merged_df.population\n\n\n\n\nCode\nmerged_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\nnew_deaths\nnew_tests\nyear\nmonth\nday\nweekday\ntotal_cases\ntotal_deaths\ntotal_tests\nlocation\ncontinent\npopulation\nlife_expectancy\nhospital_beds_per_thousand\ngdp_per_capita\ncases_per_million\ndeaths_per_million\ntests_per_million\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\nNaN\n2019\n12\n31\n1\n0.0\n0.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n0.000000\n0.000000\nNaN\n\n\n1\n2020-01-01\n0.0\n0.0\nNaN\n2020\n1\n1\n2\n0.0\n0.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n0.000000\n0.000000\nNaN\n\n\n2\n2020-01-02\n0.0\n0.0\nNaN\n2020\n1\n2\n3\n0.0\n0.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n0.000000\n0.000000\nNaN\n\n\n3\n2020-01-03\n0.0\n0.0\nNaN\n2020\n1\n3\n4\n0.0\n0.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n0.000000\n0.000000\nNaN\n\n\n4\n2020-01-04\n0.0\n0.0\nNaN\n2020\n1\n4\n5\n0.0\n0.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n0.000000\n0.000000\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n1.0\n53541.0\n2020\n8\n30\n6\n267298.5\n35473.0\n5117788.0\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n4420.946386\n586.700753\n84644.943252\n\n\n244\n2020-08-31\n1365.0\n4.0\n42583.0\n2020\n8\n31\n0\n268663.5\n35477.0\n5160371.0\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n4443.522614\n586.766910\n85349.238862\n\n\n245\n2020-09-01\n996.0\n6.0\n54395.0\n2020\n9\n1\n1\n269659.5\n35483.0\n5214766.0\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n4459.995818\n586.866146\n86248.897403\n\n\n246\n2020-09-02\n975.0\n8.0\nNaN\n2020\n9\n2\n2\n270634.5\n35491.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n4476.121695\n586.998461\nNaN\n\n\n247\n2020-09-03\n1326.0\n6.0\nNaN\n2020\n9\n3\n3\n271960.5\n35497.0\nNaN\nItaly\nEurope\n60461828.0\n83.51\n3.18\n35220.084\n4498.052887\n587.097697\nNaN\n\n\n\n\n248 rows × 20 columns",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel6.html#daten-zurück-in-dateien-schreiben",
    "href": "kapitel6.html#daten-zurück-in-dateien-schreiben",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "7.8 Daten zurück in Dateien schreiben",
    "text": "7.8 Daten zurück in Dateien schreiben\nNachdem Sie einige Analysen durchgeführt und neue Spalten zum Data Frame hinzugefügt haben, wäre es eine gute Idee, die Ergebnisse zurück in eine Datei zu schreiben, da die Daten sonst beim Herunterfahren des Jupyter-Notebooks verloren gehen. Bevor wir in eine Datei schreiben, erstellen wir zunächst ein Data Frame, das den spezifischen Spaltensatz enthält, den wir in die Datei schreiben möchten.\n\n\nCode\nresult_df = merged_df[['date',\n                       'new_cases', \n                       'total_cases', \n                       'new_deaths', \n                       'total_deaths', \n                       'new_tests', \n                       'total_tests', \n                       'cases_per_million', \n                       'deaths_per_million', \n                       'tests_per_million']]\n\n\n\n\nCode\nresult_df\n\n\n\n\n\n\n\n\n\ndate\nnew_cases\ntotal_cases\nnew_deaths\ntotal_deaths\nnew_tests\ntotal_tests\ncases_per_million\ndeaths_per_million\ntests_per_million\n\n\n\n\n0\n2019-12-31\n0.0\n0.0\n0.0\n0.0\nNaN\nNaN\n0.000000\n0.000000\nNaN\n\n\n1\n2020-01-01\n0.0\n0.0\n0.0\n0.0\nNaN\nNaN\n0.000000\n0.000000\nNaN\n\n\n2\n2020-01-02\n0.0\n0.0\n0.0\n0.0\nNaN\nNaN\n0.000000\n0.000000\nNaN\n\n\n3\n2020-01-03\n0.0\n0.0\n0.0\n0.0\nNaN\nNaN\n0.000000\n0.000000\nNaN\n\n\n4\n2020-01-04\n0.0\n0.0\n0.0\n0.0\nNaN\nNaN\n0.000000\n0.000000\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n243\n2020-08-30\n1444.0\n267298.5\n1.0\n35473.0\n53541.0\n5117788.0\n4420.946386\n586.700753\n84644.943252\n\n\n244\n2020-08-31\n1365.0\n268663.5\n4.0\n35477.0\n42583.0\n5160371.0\n4443.522614\n586.766910\n85349.238862\n\n\n245\n2020-09-01\n996.0\n269659.5\n6.0\n35483.0\n54395.0\n5214766.0\n4459.995818\n586.866146\n86248.897403\n\n\n246\n2020-09-02\n975.0\n270634.5\n8.0\n35491.0\nNaN\nNaN\n4476.121695\n586.998461\nNaN\n\n\n247\n2020-09-03\n1326.0\n271960.5\n6.0\n35497.0\nNaN\nNaN\n4498.052887\n587.097697\nNaN\n\n\n\n\n248 rows × 10 columns\n\n\n\nUm die Daten aus dem Data Frame in eine Datei zu schreiben, können wir die Funktion to_csv verwenden.\n\n\nCode\nresult_df.to_csv('data/results.csv', index=None)\n\n\nDie to_csv Funktion beinhaltet standardmäßig auch eine zusätzliche Spalte zum Speichern des Index des DataFrames. Wir geben index=None an, um dieses Verhalten abzuschalten. Du kannst nun überprüfen, dass die results.csv in dem data Ordner erstellt wurde und Daten aus dem DataFrame im CSV-Format enthält:\ndate,new_cases,total_cases,new_deaths,total_deaths,new_tests,total_tests,cases_per_million,deaths_per_million,tests_per_million\n2020-02-27,78.0,400.0,1.0,12.0,,,6.61574439992122,0.1984723319976366,\n2020-02-28,250.0,650.0,5.0,17.0,,,10.750584649871982,0.28116913699665186,\n2020-02-29,238.0,888.0,4.0,21.0,,,14.686952567825108,0.34732658099586405,\n2020-03-01,240.0,1128.0,8.0,29.0,,,18.656399207777838,0.47964146899428844,\n2020-03-02,561.0,1689.0,6.0,35.0,,,27.93498072866735,0.5788776349931067,\n2020-03-03,347.0,2036.0,17.0,52.0,,,33.67413899559901,0.8600467719897585,\n...",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel6.html#bonus-grundlegendes-plotten-mit-pandas",
    "href": "kapitel6.html#bonus-grundlegendes-plotten-mit-pandas",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "7.9 Bonus: Grundlegendes Plotten mit Pandas",
    "text": "7.9 Bonus: Grundlegendes Plotten mit Pandas\nWährend wir normalerweise eine Bibliothek wie matplotlib oder seaborn-Plotdiagramme mit einem Juptyer-Notizbuch verwenden, bieten Pandas-Data Frame und -Serien auch eine praktische .plot-Methode für schnelles und einfaches Plotten.\nLassen Sie uns ein Liniendiagramm zeichnen, das zeigt, wie die Nr. der täglichen Fälle variiert im Laufe der Zeit unter Verwendung der plot-Methode einer Pandas-Serie.\n\n\nCode\nresult_df.new_cases.plot();\n\n\n\n\n\n\n\n\n\nWährend dieses Diagramm den Gesamttrend zeigt, ist es schwer zu sagen, wo der Höhepunkt auftrat, da es auf der X-Achse keine Daten gibt. Wir können die Spalte date als Index für das Data Frame verwenden, um dieses Problem zu beheben.\n\n\nCode\nresult_df.set_index('date', inplace=True)\n\n\n\n\nCode\nresult_df\n\n\n\n\n\n\n\n\n\nnew_cases\ntotal_cases\nnew_deaths\ntotal_deaths\nnew_tests\ntotal_tests\ncases_per_million\ndeaths_per_million\ntests_per_million\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n\n\n\n2019-12-31\n0.0\n0.0\n0.0\n0.0\nNaN\nNaN\n0.000000\n0.000000\nNaN\n\n\n2020-01-01\n0.0\n0.0\n0.0\n0.0\nNaN\nNaN\n0.000000\n0.000000\nNaN\n\n\n2020-01-02\n0.0\n0.0\n0.0\n0.0\nNaN\nNaN\n0.000000\n0.000000\nNaN\n\n\n2020-01-03\n0.0\n0.0\n0.0\n0.0\nNaN\nNaN\n0.000000\n0.000000\nNaN\n\n\n2020-01-04\n0.0\n0.0\n0.0\n0.0\nNaN\nNaN\n0.000000\n0.000000\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2020-08-30\n1444.0\n267298.5\n1.0\n35473.0\n53541.0\n5117788.0\n4420.946386\n586.700753\n84644.943252\n\n\n2020-08-31\n1365.0\n268663.5\n4.0\n35477.0\n42583.0\n5160371.0\n4443.522614\n586.766910\n85349.238862\n\n\n2020-09-01\n996.0\n269659.5\n6.0\n35483.0\n54395.0\n5214766.0\n4459.995818\n586.866146\n86248.897403\n\n\n2020-09-02\n975.0\n270634.5\n8.0\n35491.0\nNaN\nNaN\n4476.121695\n586.998461\nNaN\n\n\n2020-09-03\n1326.0\n271960.5\n6.0\n35497.0\nNaN\nNaN\n4498.052887\n587.097697\nNaN\n\n\n\n\n248 rows × 9 columns\n\n\n\nDas ist richtig, der Index eines Data Frames muss nicht numerisch sein. Durch die Umwandlung des Datums in einen Index können wir auch die Daten für bestimmte Daten mithilfe von .loc abrufen\n\n\nCode\nresult_df.loc['2020-09-01']\n\n\nnew_cases             9.960000e+02\ntotal_cases           2.696595e+05\nnew_deaths            6.000000e+00\ntotal_deaths          3.548300e+04\nnew_tests             5.439500e+04\ntotal_tests           5.214766e+06\ncases_per_million     4.459996e+03\ndeaths_per_million    5.868661e+02\ntests_per_million     8.624890e+04\nName: 2020-09-01 00:00:00, dtype: float64\n\n\n\n\nCode\nresult_df.new_cases\n\n\ndate\n2019-12-31       0.0\n2020-01-01       0.0\n2020-01-02       0.0\n2020-01-03       0.0\n2020-01-04       0.0\n               ...  \n2020-08-30    1444.0\n2020-08-31    1365.0\n2020-09-01     996.0\n2020-09-02     975.0\n2020-09-03    1326.0\nName: new_cases, Length: 248, dtype: float64\n\n\nLassen Sie uns die neuen Fälle und neuen Todesfälle pro Tag als Liniendiagramme darstellen.\n\n\nCode\nresult_df.new_cases.plot()\nresult_df.new_deaths.plot();\n\n\n\n\n\n\n\n\n\nWir können auch die Gesamtzahl der Fälle mit der Gesamtzahl der Todesfälle vergleichen.\n\n\nCode\nresult_df.total_cases.plot()\nresult_df.total_deaths.plot();\n\n\n\n\n\n\n\n\n\nSehen wir uns an, wie sich die Sterblichkeitsrate und die positiven Testraten im Laufe der Zeit ändern.\n\n\nCode\ndeath_rate = result_df.total_deaths / result_df.total_cases\n\n\n\n\nCode\ndeath_rate.plot(title='Death Rate');\n\n\n\n\n\n\n\n\n\n\n\nCode\npositive_rates = result_df.total_cases / result_df.total_tests\npositive_rates.plot(title='Positive Rate');\n\n\n\n\n\n\n\n\n\nLassen Sie uns abschließend einige monatliche Daten mithilfe eines Balkendiagramms darstellen, um den Trend auf einer höheren Ebene zu visualisieren.\n\n\nCode\ncovid_month_df.new_cases.plot(kind='bar');\n\n\n\n\n\n\n\n\n\n\n\nCode\ncovid_month_df.new_tests.plot(kind='bar')",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel6.html#weiterführende-literatur",
    "href": "kapitel6.html#weiterführende-literatur",
    "title": "7  Analyse tabellarischer Daten mit Python und Pandas",
    "section": "7.10 Weiterführende Literatur",
    "text": "7.10 Weiterführende Literatur\nSchauen Sie sich die folgenden Ressourcen an, um mehr über Pandas zu erfahren:\n\nPandas-Übungen\nBenutzerhandbuch für Pandas\nPython for Data Analysis (Buch von Wes McKinney – Entwickler von Pandas)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Analyse tabellarischer Daten mit Python und Pandas</span>"
    ]
  },
  {
    "objectID": "kapitel7.html",
    "href": "kapitel7.html",
    "title": "8  Datenvisualisierung mit Python, Matplotlib und Seaborn",
    "section": "",
    "text": "8.1 Einführung\nDieses Tutorial ist das siebte einer Reihe zur Einführung in die Programmierung und Datenanalyse mithilfe der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\nDie folgenden Themen werden in diesem Tutorial behandelt:\nUnter Datenvisualisierung versteht man die grafische Darstellung von Daten. Dabei geht es um die Erstellung von Bildern, die dem Betrachter Beziehungen zwischen den dargestellten Daten vermitteln. Die Visualisierung von Daten ist ein wesentlicher Bestandteil der Datenanalyse und des maschinellen Lernens. In diesem Tutorial verwenden wir die Python-Bibliotheken Matplotlib und Seaborn, um einige beliebte Datenvisualisierungstechniken zu erlernen und anzuwenden.\nZunächst importieren wir die Bibliotheken. Wir verwenden matplotlib.pyplot für grundlegende Diagramme wie Linien- und Balkendiagramme. Es wird oft mit dem Alias plt importiert. Das Modul seaborn wird für fortgeschrittenere Plots verwendet und mit dem Alias sns importiert.\nCode\n# Uncomment the next line to install the required libraries\n# !pip install matplotlib seaborn --upgrade --quiet\nCode\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nBeachten Sie, dass wir auch den speziellen Befehl %matplotlib inline einschließen, um sicherzustellen, dass Diagramme im Jupyter-Notebook selbst angezeigt und eingebettet werden. Ohne diesen Befehl werden Diagramme manchmal in Popup-Fenstern angezeigt.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung mit Python, Matplotlib und Seaborn</span>"
    ]
  },
  {
    "objectID": "kapitel7.html#liniendiagramm",
    "href": "kapitel7.html#liniendiagramm",
    "title": "8  Datenvisualisierung mit Python, Matplotlib und Seaborn",
    "section": "8.2 Liniendiagramm",
    "text": "8.2 Liniendiagramm\nLiniendiagramme sind eine der einfachsten und am weitesten verbreiteten Techniken zur Datenvisualisierung. Ein Liniendiagramm zeigt Informationen als eine Reihe von Datenpunkten oder Markierungen an, die durch gerade Linien verbunden sind. Für eine bessere visuelle Klarheit können Sie Form, Größe, Farbe und andere ästhetische Elemente der Markierungen und Linien anpassen.\nHier ist eine Python-Liste, die den Apfelertrag (Tonnen pro Hektar) über 6 Jahre in einem imaginären Land namens Kanto zeigt.\n\n\nCode\nyield_apples = [0.895, 0.91, 0.919, 0.926, 0.929, 0.931]\n\n\nMithilfe eines Liniendiagramms können wir visualisieren, wie sich der Ertrag von Äpfeln im Laufe der Zeit verändert. Um ein Liniendiagramm zu zeichnen, können wir die Funktion plt.plot verwenden.\n\n\nCode\nplt.plot(yield_apples)\n\n\n\n\n\n\n\n\n\nDurch Aufrufen der Funktion plt.plot wird das Liniendiagramm wie erwartet gezeichnet und außerdem eine Liste der gezeichneten Diagramme [&lt;matplotlib.lines.Line2D at 0x7ff70aa20760&gt;] zurückgegeben, die in der Ausgabe angezeigt wird. Wir können am Ende der letzten Anweisung in der Zelle ein Semikolon (;) einfügen, um die Ausgabe zu vermeiden und nur das Diagramm anzuzeigen.\n\n\nCode\n# The semicolumn hides the output \n# \"[&lt;matplotlib.lines.Line2D at 0x7fd6609106d8&gt;]\"\nplt.plot(yield_apples);\n\n\n\n\n\n\n\n\n\nLassen Sie uns diese Handlung Schritt für Schritt verbessern, um sie informativer und schöner zu machen.\n\n8.2.1 Anpassen der X-Achse\nDie X-Achse des Diagramms zeigt derzeit die Listenelementindizes 0 bis 5. Das Diagramm wäre aussagekräftiger, wenn wir das Jahr anzeigen könnten, für das die Daten aufgezeichnet werden. Wir können dies durch zwei Argumente plt.plot tun.\n\n\nCode\nyears = [2010, 2011, 2012, 2013, 2014, 2015]\nyield_apples = [0.895, 0.91, 0.919, 0.926, 0.929, 0.931]\n\n\n\n\nCode\nplt.plot(years, yield_apples)\n\n\n\n\n\n\n\n\n\n\n\n8.2.2 Achsenbeschriftungen\nMit den Methoden plt.xlabel und plt.ylabel können wir den Achsen Beschriftungen hinzufügen, um zu zeigen, was jede Achse darstellt.\n\n\nCode\nplt.plot(years, yield_apples)\nplt.xlabel('Year')\nplt.ylabel('Yield (tons per hectare)');\n\n\n\n\n\n\n\n\n\n\n\n8.2.3 Mehrere Linien plotten\nEs ist wirklich einfach, mehrere Linien im selben Diagramm darzustellen. Rufen Sie einfach mehrmals die Funktion plt.plot auf. Vergleichen wir die Erträge von Äpfeln und Orangen in Kanto.\n\n\nCode\nyears = range(2000, 2012)\napples = [0.895, 0.91, 0.919, 0.926, 0.929, 0.931, 0.934, 0.936, 0.937, 0.9375, 0.9372, 0.939]\noranges = [0.962, 0.941, 0.930, 0.923, 0.918, 0.908, 0.907, 0.904, 0.901, 0.898, 0.9, 0.896, ]\n\n\n\n\nCode\nplt.plot(years, apples)\nplt.plot(years, oranges)\nplt.xlabel('Year')\nplt.ylabel('Yield (tons per hectare)');\n\n\n\n\n\n\n\n\n\n\n\n8.2.4 Diagrammtitel und Legende\nUm zwischen mehreren Linien zu unterscheiden, können wir mit der Funktion plt.legend eine Legende in das Diagramm einfügen. Außerdem geben wir dem gesamten Diagramm mit der Funktion plt.title einen Titel.\n\n\nCode\nplt.plot(years, apples)\nplt.plot(years, oranges)\n\nplt.xlabel('Year')\nplt.ylabel('Yield (tons per hectare)')\n\nplt.title(\"Crop Yields in Kanto\")\nplt.legend(['Apples', 'Oranges']);\n\n\n\n\n\n\n\n\n\n\n\n8.2.5 Linienmarkierungen\nWir können auch Markierungen für die Datenpunkte auf jeder Zeile anzeigen, indem wir das Argument marker von plt.plot verwenden. Matplotlib unterstützt viele verschiedene Arten von Markierungen wie Kreis, Kreuz, Quadrat, Raute usw. Die vollständige Liste der Markierungstypen finden Sie hier\n\n\nCode\nplt.plot(years, apples, marker='o')\nplt.plot(years, oranges, marker='x')\n\nplt.xlabel('Year')\nplt.ylabel('Yield (tons per hectare)')\n\nplt.title(\"Crop Yields in Kanto\")\nplt.legend(['Apples', 'Oranges']);\n\n\n\n\n\n\n\n\n\n\n\n8.2.6 Linien und Markierungen gestalten\nDie Funktion plt.plot unterstützt viele Argumente zur Gestaltung von Linien und Markierungen:\n\ncolor oder c: Legt die Farbe der Linie fest (unterstützte Farben)\nlinestyle oder ls: Wahl zwischen einer durchgezogenen oder gestrichelten Linie\nlinewidth oder lw: Legt die Breite einer Linie fest\nmarkersize oder ms: Legt die Größe der Markierungen fest\nmarkeredgecolor oder mec: Legt die Randfarbe für Markierungen fest\nmarkeredgewidth oder mew: Legt die Randbreite für Markierungen fest\nmarkerfacecolor oder mfc: Legt die Füllfarbe für Markierungen fest\nalpha: Deckkraft des Plots\n\nSchau dir die Dokumentation für plt.plot an, um mehr zu erfahren.\n\n\nCode\nplt.plot(years, apples, marker='s', c='b', ls='-', lw=2, ms=8, mew=2, mec='navy')\nplt.plot(years, oranges, marker='o', c='r', ls='--', lw=3, ms=10, alpha=.5)\n\nplt.xlabel('Year')\nplt.ylabel('Yield (tons per hectare)')\n\nplt.title(\"Crop Yields in Kanto\")\nplt.legend(['Apples', 'Oranges']);\n\n\n\n\n\n\n\n\n\nDas Argument fmt bietet eine Abkürzung für die Angabe des Linienstils, der Markierung und der Linienfarbe. Es kann als drittes Argument für plt.plot bereitgestellt werden.\nfmt = '[marker][line][color]'\n\n\nCode\nplt.plot(years, apples, 's-b')\nplt.plot(years, oranges, 'o--r')\n\nplt.xlabel('Year')\nplt.ylabel('Yield (tons per hectare)')\n\nplt.title(\"Crop Yields in Kanto\")\nplt.legend(['Apples', 'Oranges']);\n\n\n\n\n\n\n\n\n\nWenn in fmt kein Linienstil angegeben ist, werden nur Markierungen gezeichnet.\n\n\nCode\nplt.plot(years, oranges, 'or')\nplt.title(\"Yield of Oranges (tons per hectare)\");\n\n\n\n\n\n\n\n\n\n\n\n8.2.7 Ändern der Figurengröße\nMit der Funktion plt.figure können Sie die Größe der Figur ändern.\n\n\nCode\nplt.figure(figsize=(12, 6))\n\nplt.plot(years, oranges, 'or')\nplt.title(\"Yield of Oranges (tons per hectare)\");\n\n\n\n\n\n\n\n\n\n\n\n8.2.8 Verbesserung der Standardstile mit Seaborn\nEine einfache Möglichkeit, Ihren Diagrammen ein ansprechendes Aussehen zu verleihen, besteht darin, einige in der Seaborn-Bibliothek bereitgestellte Standardstile zu verwenden. Diese können global mit der Funktion sns.set_style angewendet werden. Eine vollständige Liste der vordefinierten Stile finden Sie hier.\n\n\nCode\nsns.set_style(\"whitegrid\")\n\n\n\n\nCode\nplt.plot(years, apples, 's-b')\nplt.plot(years, oranges, 'o--r')\n\nplt.xlabel('Year')\nplt.ylabel('Yield (tons per hectare)')\n\nplt.title(\"Crop Yields in Kanto\")\nplt.legend(['Apples', 'Oranges']);\n\n\n\n\n\n\n\n\n\n\n\nCode\nsns.set_style(\"darkgrid\")\n\n\n\n\nCode\nplt.plot(years, apples, 's-b')\nplt.plot(years, oranges, 'o--r')\n\nplt.xlabel('Year')\nplt.ylabel('Yield (tons per hectare)')\n\nplt.title(\"Crop Yields in Kanto\")\nplt.legend(['Apples', 'Oranges']);\n\n\n\n\n\n\n\n\n\n\n\nCode\nplt.plot(years, oranges, 'or')\nplt.title(\"Yield of Oranges (tons per hectare)\");\n\n\n\n\n\n\n\n\n\nSie können Standardstile auch direkt bearbeiten, indem Sie das Wörterbuch matplotlib.rcParams ändern. Erfahren Sie mehr hier.\n\n\nCode\nimport matplotlib\n\n\n\n\nCode\nmatplotlib.rcParams\n\n\nRcParams({'_internal.classic_mode': False,\n          'agg.path.chunksize': 0,\n          'animation.bitrate': -1,\n          'animation.codec': 'h264',\n          'animation.convert_args': ['-layers', 'OptimizePlus'],\n          'animation.convert_path': 'convert',\n          'animation.embed_limit': 20.0,\n          'animation.ffmpeg_args': [],\n          'animation.ffmpeg_path': 'ffmpeg',\n          'animation.frame_format': 'png',\n          'animation.html': 'none',\n          'animation.writer': 'ffmpeg',\n          'axes.autolimit_mode': 'data',\n          'axes.axisbelow': True,\n          'axes.edgecolor': 'white',\n          'axes.facecolor': '#EAEAF2',\n          'axes.formatter.limits': [-5, 6],\n          'axes.formatter.min_exponent': 0,\n          'axes.formatter.offset_threshold': 4,\n          'axes.formatter.use_locale': False,\n          'axes.formatter.use_mathtext': False,\n          'axes.formatter.useoffset': True,\n          'axes.grid': True,\n          'axes.grid.axis': 'both',\n          'axes.grid.which': 'major',\n          'axes.labelcolor': '.15',\n          'axes.labelpad': 4.0,\n          'axes.labelsize': 'medium',\n          'axes.labelweight': 'normal',\n          'axes.linewidth': 0.8,\n          'axes.prop_cycle': cycler('color', ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']),\n          'axes.spines.bottom': True,\n          'axes.spines.left': True,\n          'axes.spines.right': True,\n          'axes.spines.top': True,\n          'axes.titlecolor': 'auto',\n          'axes.titlelocation': 'center',\n          'axes.titlepad': 6.0,\n          'axes.titlesize': 'large',\n          'axes.titleweight': 'normal',\n          'axes.titley': None,\n          'axes.unicode_minus': True,\n          'axes.xmargin': 0.05,\n          'axes.ymargin': 0.05,\n          'axes.zmargin': 0.05,\n          'axes3d.grid': True,\n          'axes3d.xaxis.panecolor': (0.95, 0.95, 0.95, 0.5),\n          'axes3d.yaxis.panecolor': (0.9, 0.9, 0.9, 0.5),\n          'axes3d.zaxis.panecolor': (0.925, 0.925, 0.925, 0.5),\n          'backend': 'module://matplotlib_inline.backend_inline',\n          'backend_fallback': True,\n          'boxplot.bootstrap': None,\n          'boxplot.boxprops.color': 'black',\n          'boxplot.boxprops.linestyle': '-',\n          'boxplot.boxprops.linewidth': 1.0,\n          'boxplot.capprops.color': 'black',\n          'boxplot.capprops.linestyle': '-',\n          'boxplot.capprops.linewidth': 1.0,\n          'boxplot.flierprops.color': 'black',\n          'boxplot.flierprops.linestyle': 'none',\n          'boxplot.flierprops.linewidth': 1.0,\n          'boxplot.flierprops.marker': 'o',\n          'boxplot.flierprops.markeredgecolor': 'black',\n          'boxplot.flierprops.markeredgewidth': 1.0,\n          'boxplot.flierprops.markerfacecolor': 'none',\n          'boxplot.flierprops.markersize': 6.0,\n          'boxplot.meanline': False,\n          'boxplot.meanprops.color': 'C2',\n          'boxplot.meanprops.linestyle': '--',\n          'boxplot.meanprops.linewidth': 1.0,\n          'boxplot.meanprops.marker': '^',\n          'boxplot.meanprops.markeredgecolor': 'C2',\n          'boxplot.meanprops.markerfacecolor': 'C2',\n          'boxplot.meanprops.markersize': 6.0,\n          'boxplot.medianprops.color': 'C1',\n          'boxplot.medianprops.linestyle': '-',\n          'boxplot.medianprops.linewidth': 1.0,\n          'boxplot.notch': False,\n          'boxplot.patchartist': False,\n          'boxplot.showbox': True,\n          'boxplot.showcaps': True,\n          'boxplot.showfliers': True,\n          'boxplot.showmeans': False,\n          'boxplot.vertical': True,\n          'boxplot.whiskerprops.color': 'black',\n          'boxplot.whiskerprops.linestyle': '-',\n          'boxplot.whiskerprops.linewidth': 1.0,\n          'boxplot.whiskers': 1.5,\n          'contour.algorithm': 'mpl2014',\n          'contour.corner_mask': True,\n          'contour.linewidth': None,\n          'contour.negative_linestyle': 'dashed',\n          'date.autoformatter.day': '%Y-%m-%d',\n          'date.autoformatter.hour': '%m-%d %H',\n          'date.autoformatter.microsecond': '%M:%S.%f',\n          'date.autoformatter.minute': '%d %H:%M',\n          'date.autoformatter.month': '%Y-%m',\n          'date.autoformatter.second': '%H:%M:%S',\n          'date.autoformatter.year': '%Y',\n          'date.converter': 'auto',\n          'date.epoch': '1970-01-01T00:00:00',\n          'date.interval_multiples': True,\n          'docstring.hardcopy': False,\n          'errorbar.capsize': 0.0,\n          'figure.autolayout': False,\n          'figure.constrained_layout.h_pad': 0.04167,\n          'figure.constrained_layout.hspace': 0.02,\n          'figure.constrained_layout.use': False,\n          'figure.constrained_layout.w_pad': 0.04167,\n          'figure.constrained_layout.wspace': 0.02,\n          'figure.dpi': 100.0,\n          'figure.edgecolor': 'white',\n          'figure.facecolor': 'white',\n          'figure.figsize': [6.4, 4.8],\n          'figure.frameon': True,\n          'figure.hooks': [],\n          'figure.labelsize': 'large',\n          'figure.labelweight': 'normal',\n          'figure.max_open_warning': 20,\n          'figure.raise_window': True,\n          'figure.subplot.bottom': 0.11,\n          'figure.subplot.hspace': 0.2,\n          'figure.subplot.left': 0.125,\n          'figure.subplot.right': 0.9,\n          'figure.subplot.top': 0.88,\n          'figure.subplot.wspace': 0.2,\n          'figure.titlesize': 'large',\n          'figure.titleweight': 'normal',\n          'font.cursive': ['Apple Chancery',\n                           'Textile',\n                           'Zapf Chancery',\n                           'Sand',\n                           'Script MT',\n                           'Felipa',\n                           'Comic Neue',\n                           'Comic Sans MS',\n                           'cursive'],\n          'font.family': ['sans-serif'],\n          'font.fantasy': ['Chicago',\n                           'Charcoal',\n                           'Impact',\n                           'Western',\n                           'Humor Sans',\n                           'xkcd',\n                           'fantasy'],\n          'font.monospace': ['DejaVu Sans Mono',\n                             'Bitstream Vera Sans Mono',\n                             'Computer Modern Typewriter',\n                             'Andale Mono',\n                             'Nimbus Mono L',\n                             'Courier New',\n                             'Courier',\n                             'Fixed',\n                             'Terminal',\n                             'monospace'],\n          'font.sans-serif': ['Arial',\n                              'DejaVu Sans',\n                              'Liberation Sans',\n                              'Bitstream Vera Sans',\n                              'sans-serif'],\n          'font.serif': ['DejaVu Serif',\n                         'Bitstream Vera Serif',\n                         'Computer Modern Roman',\n                         'New Century Schoolbook',\n                         'Century Schoolbook L',\n                         'Utopia',\n                         'ITC Bookman',\n                         'Bookman',\n                         'Nimbus Roman No9 L',\n                         'Times New Roman',\n                         'Times',\n                         'Palatino',\n                         'Charter',\n                         'serif'],\n          'font.size': 10.0,\n          'font.stretch': 'normal',\n          'font.style': 'normal',\n          'font.variant': 'normal',\n          'font.weight': 'normal',\n          'grid.alpha': 1.0,\n          'grid.color': 'white',\n          'grid.linestyle': '-',\n          'grid.linewidth': 0.8,\n          'hatch.color': 'black',\n          'hatch.linewidth': 1.0,\n          'hist.bins': 10,\n          'image.aspect': 'equal',\n          'image.cmap': 'rocket',\n          'image.composite_image': True,\n          'image.interpolation': 'antialiased',\n          'image.lut': 256,\n          'image.origin': 'upper',\n          'image.resample': True,\n          'interactive': True,\n          'keymap.back': ['left', 'c', 'backspace', 'MouseButton.BACK'],\n          'keymap.copy': ['ctrl+c', 'cmd+c'],\n          'keymap.forward': ['right', 'v', 'MouseButton.FORWARD'],\n          'keymap.fullscreen': ['f', 'ctrl+f'],\n          'keymap.grid': ['g'],\n          'keymap.grid_minor': ['G'],\n          'keymap.help': ['f1'],\n          'keymap.home': ['h', 'r', 'home'],\n          'keymap.pan': ['p'],\n          'keymap.quit': ['ctrl+w', 'cmd+w', 'q'],\n          'keymap.quit_all': [],\n          'keymap.save': ['s', 'ctrl+s'],\n          'keymap.xscale': ['k', 'L'],\n          'keymap.yscale': ['l'],\n          'keymap.zoom': ['o'],\n          'legend.borderaxespad': 0.5,\n          'legend.borderpad': 0.4,\n          'legend.columnspacing': 2.0,\n          'legend.edgecolor': '0.8',\n          'legend.facecolor': 'inherit',\n          'legend.fancybox': True,\n          'legend.fontsize': 'medium',\n          'legend.framealpha': 0.8,\n          'legend.frameon': True,\n          'legend.handleheight': 0.7,\n          'legend.handlelength': 2.0,\n          'legend.handletextpad': 0.8,\n          'legend.labelcolor': 'None',\n          'legend.labelspacing': 0.5,\n          'legend.loc': 'best',\n          'legend.markerscale': 1.0,\n          'legend.numpoints': 1,\n          'legend.scatterpoints': 1,\n          'legend.shadow': False,\n          'legend.title_fontsize': None,\n          'lines.antialiased': True,\n          'lines.color': 'C0',\n          'lines.dash_capstyle': &lt;CapStyle.butt: 'butt'&gt;,\n          'lines.dash_joinstyle': &lt;JoinStyle.round: 'round'&gt;,\n          'lines.dashdot_pattern': [6.4, 1.6, 1.0, 1.6],\n          'lines.dashed_pattern': [3.7, 1.6],\n          'lines.dotted_pattern': [1.0, 1.65],\n          'lines.linestyle': '-',\n          'lines.linewidth': 1.5,\n          'lines.marker': 'None',\n          'lines.markeredgecolor': 'auto',\n          'lines.markeredgewidth': 1.0,\n          'lines.markerfacecolor': 'auto',\n          'lines.markersize': 6.0,\n          'lines.scale_dashes': True,\n          'lines.solid_capstyle': &lt;CapStyle.round: 'round'&gt;,\n          'lines.solid_joinstyle': &lt;JoinStyle.round: 'round'&gt;,\n          'markers.fillstyle': 'full',\n          'mathtext.bf': 'sans:bold',\n          'mathtext.cal': 'cursive',\n          'mathtext.default': 'it',\n          'mathtext.fallback': 'cm',\n          'mathtext.fontset': 'dejavusans',\n          'mathtext.it': 'sans:italic',\n          'mathtext.rm': 'sans',\n          'mathtext.sf': 'sans',\n          'mathtext.tt': 'monospace',\n          'patch.antialiased': True,\n          'patch.edgecolor': 'w',\n          'patch.facecolor': 'C0',\n          'patch.force_edgecolor': True,\n          'patch.linewidth': 1.0,\n          'path.effects': [],\n          'path.simplify': True,\n          'path.simplify_threshold': 0.111111111111,\n          'path.sketch': None,\n          'path.snap': True,\n          'pcolor.shading': 'auto',\n          'pcolormesh.snap': True,\n          'pdf.compression': 6,\n          'pdf.fonttype': 3,\n          'pdf.inheritcolor': False,\n          'pdf.use14corefonts': False,\n          'pgf.preamble': '',\n          'pgf.rcfonts': True,\n          'pgf.texsystem': 'xelatex',\n          'polaraxes.grid': True,\n          'ps.distiller.res': 6000,\n          'ps.fonttype': 3,\n          'ps.papersize': 'letter',\n          'ps.useafm': False,\n          'ps.usedistiller': None,\n          'savefig.bbox': None,\n          'savefig.directory': '~',\n          'savefig.dpi': 'figure',\n          'savefig.edgecolor': 'auto',\n          'savefig.facecolor': 'auto',\n          'savefig.format': 'png',\n          'savefig.orientation': 'portrait',\n          'savefig.pad_inches': 0.1,\n          'savefig.transparent': False,\n          'scatter.edgecolors': 'face',\n          'scatter.marker': 'o',\n          'svg.fonttype': 'path',\n          'svg.hashsalt': None,\n          'svg.image_inline': True,\n          'text.antialiased': True,\n          'text.color': '.15',\n          'text.hinting': 'force_autohint',\n          'text.hinting_factor': 8,\n          'text.kerning_factor': 0,\n          'text.latex.preamble': '',\n          'text.parse_math': True,\n          'text.usetex': False,\n          'timezone': 'UTC',\n          'tk.window_focus': False,\n          'toolbar': 'toolbar2',\n          'webagg.address': '127.0.0.1',\n          'webagg.open_in_browser': True,\n          'webagg.port': 8988,\n          'webagg.port_retries': 50,\n          'xaxis.labellocation': 'center',\n          'xtick.alignment': 'center',\n          'xtick.bottom': False,\n          'xtick.color': '.15',\n          'xtick.direction': 'out',\n          'xtick.labelbottom': True,\n          'xtick.labelcolor': 'inherit',\n          'xtick.labelsize': 'medium',\n          'xtick.labeltop': False,\n          'xtick.major.bottom': True,\n          'xtick.major.pad': 3.5,\n          'xtick.major.size': 3.5,\n          'xtick.major.top': True,\n          'xtick.major.width': 0.8,\n          'xtick.minor.bottom': True,\n          'xtick.minor.pad': 3.4,\n          'xtick.minor.size': 2.0,\n          'xtick.minor.top': True,\n          'xtick.minor.visible': False,\n          'xtick.minor.width': 0.6,\n          'xtick.top': False,\n          'yaxis.labellocation': 'center',\n          'ytick.alignment': 'center_baseline',\n          'ytick.color': '.15',\n          'ytick.direction': 'out',\n          'ytick.labelcolor': 'inherit',\n          'ytick.labelleft': True,\n          'ytick.labelright': False,\n          'ytick.labelsize': 'medium',\n          'ytick.left': False,\n          'ytick.major.left': True,\n          'ytick.major.pad': 3.5,\n          'ytick.major.right': True,\n          'ytick.major.size': 3.5,\n          'ytick.major.width': 0.8,\n          'ytick.minor.left': True,\n          'ytick.minor.pad': 3.4,\n          'ytick.minor.right': True,\n          'ytick.minor.size': 2.0,\n          'ytick.minor.visible': False,\n          'ytick.minor.width': 0.6,\n          'ytick.right': False})\n\n\n\n\nCode\nmatplotlib.rcParams['font.size'] = 14\nmatplotlib.rcParams['figure.figsize'] = (9, 5)\nmatplotlib.rcParams['figure.facecolor'] = '#00000000'",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung mit Python, Matplotlib und Seaborn</span>"
    ]
  },
  {
    "objectID": "kapitel7.html#streudiagramm",
    "href": "kapitel7.html#streudiagramm",
    "title": "8  Datenvisualisierung mit Python, Matplotlib und Seaborn",
    "section": "8.3 Streudiagramm",
    "text": "8.3 Streudiagramm\nIn einem Streudiagramm werden die Werte von zwei Variablen als Punkte in einem zweidimensionalen Gitter dargestellt. Darüber hinaus können Sie auch eine dritte Variable verwenden, um die Größe oder Farbe der Punkte zu bestimmen. Probieren wir es an einem Beispiel aus.\nDer Irisblütendatensatz bietet Beispielmessungen von Kelch- und Blütenblättern für drei Blumenarten. Der Iris-Datensatz ist in der Seaborn-Bibliothek enthalten und kann als Pandas Data Frame geladen werden.\n\n\nCode\n# Load data into a Pandas dataframe\nflowers_df = sns.load_dataset(\"iris\")\n\n\n\n\nCode\nflowers_df\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n...\n...\n...\n...\n...\n...\n\n\n145\n6.7\n3.0\n5.2\n2.3\nvirginica\n\n\n146\n6.3\n2.5\n5.0\n1.9\nvirginica\n\n\n147\n6.5\n3.0\n5.2\n2.0\nvirginica\n\n\n148\n6.2\n3.4\n5.4\n2.3\nvirginica\n\n\n149\n5.9\n3.0\n5.1\n1.8\nvirginica\n\n\n\n\n150 rows × 5 columns\n\n\n\n\n\nCode\nflowers_df.species.unique()\n\n\narray(['setosa', 'versicolor', 'virginica'], dtype=object)\n\n\nVersuchen wir, die Beziehung zwischen Kelchblattlänge und Kelchblattbreite zu veranschaulichen. Unser erster Instinkt könnte sein, mit plt.plot ein Liniendiagramm zu erstellen. Allerdings ist die Ausgabe nicht sehr aussagekräftig, da der Datensatz zu viele Kombinationen der beiden Eigenschaften enthält und es scheinbar keine einfache Beziehung zwischen ihnen gibt.\n\n\nCode\nplt.plot(flowers_df.sepal_length, flowers_df.sepal_width);\n\n\n\n\n\n\n\n\n\nMit der Scatterplot-Funktion von seaborn (importiert als sns) können wir ein Streudiagramm verwenden, um zu visualisieren, wie sich sepal length und sepal width unterscheiden.\n\n\nCode\nsns.scatterplot(x=flowers_df.sepal_length, y=flowers_df.sepal_width);\n\n\n\n\n\n\n\n\n\n\n8.3.1 Farbtöne hinzufügen\nBeachten Sie, dass die Punkte im obigen Diagramm mit einigen Ausreißern unterschiedliche Cluster zu bilden scheinen. Wir können die Punkte einfärben, indem wir die Blumenart als hue verwenden. Wir können die Punkte auch mit dem Argument s vergrößern.\n\n\nCode\nsns.scatterplot(x=flowers_df.sepal_length, y=flowers_df.sepal_width, hue=flowers_df.species, s=100);\n\n\n\n\n\n\n\n\n\nDurch das Hinzufügen von Farbtönen wird die Handlung informativer. Wir können sofort erkennen, dass die Blüten der Setosa-Art eine geringere Kelchlänge, aber eine größere Kelchbreite haben, während bei der Virginica-Art das Gegenteil der Fall ist.\n\n\n8.3.2 Anpassen von Seaborn-Figuren\nDa Seaborn intern die Plotfunktionen von Matplotlib verwendet, können wir Funktionen wie plt.figure und plt.title verwenden, um die Figur zu ändern.\n\n\nCode\nplt.figure(figsize=(12, 6))\nplt.title('Sepal Dimensions')\n\nsns.scatterplot(x=flowers_df.sepal_length, \n                y=flowers_df.sepal_width, \n                hue=flowers_df.species,\n                s=100);\n\n\n\n\n\n\n\n\n\n\n\n8.3.3 Plotten mit Pandas Data Frames\nSeaborn bietet integrierte Unterstützung für Pandas Data Frames. Anstatt jede Spalte als Reihe zu übergeben, können Sie auch Spaltennamen übergeben und das Argument data verwenden, um das Data Frame zu übergeben.\n\n\nCode\nplt.title('Sepal Dimensions')\nsns.scatterplot(x='sepal_length', \n                y='sepal_width', \n                hue='species',\n                s=100,\n                data=flowers_df);",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung mit Python, Matplotlib und Seaborn</span>"
    ]
  },
  {
    "objectID": "kapitel7.html#histogramm",
    "href": "kapitel7.html#histogramm",
    "title": "8  Datenvisualisierung mit Python, Matplotlib und Seaborn",
    "section": "8.4 Histogramm",
    "text": "8.4 Histogramm\nEin Histogramm stellt die Verteilung von Daten dar, indem es Abschnitte entlang des Datenbereichs bildet und dann Balken zeichnet, um die Anzahl der Beobachtungen anzuzeigen, die in jeden Abschnitt fallen.\nLassen Sie uns als Beispiel visualisieren, wie die Werte der Kelchblattbreite im Blumendatensatz verteilt sind. Wir können die Funktion plt.hist verwenden, um ein Histogramm zu erstellen.\n\n\nCode\n# Load data into a Pandas dataframe\nflowers_df = sns.load_dataset(\"iris\")\n\n\n\n\nCode\nflowers_df.sepal_width\n\n\n0      3.5\n1      3.0\n2      3.2\n3      3.1\n4      3.6\n      ... \n145    3.0\n146    2.5\n147    3.0\n148    3.4\n149    3.0\nName: sepal_width, Length: 150, dtype: float64\n\n\n\n\nCode\nflowers_df.describe()\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\n\n\ncount\n150.000000\n150.000000\n150.000000\n150.000000\n\n\nmean\n5.843333\n3.057333\n3.758000\n1.199333\n\n\nstd\n0.828066\n0.435866\n1.765298\n0.762238\n\n\nmin\n4.300000\n2.000000\n1.000000\n0.100000\n\n\n25%\n5.100000\n2.800000\n1.600000\n0.300000\n\n\n50%\n5.800000\n3.000000\n4.350000\n1.300000\n\n\n75%\n6.400000\n3.300000\n5.100000\n1.800000\n\n\nmax\n7.900000\n4.400000\n6.900000\n2.500000\n\n\n\n\n\n\n\n\n\nCode\nplt.title(\"Distribution of Sepal Width\")\nplt.hist(flowers_df.sepal_width);\n\n\n\n\n\n\n\n\n\nWir können sofort erkennen, dass die Werte der Kelchblattbreite im Bereich von 2,0 bis 4,5 liegen und etwa 35 Werte im Bereich von 2,9 bis 3,1 liegen, was der größte Bereich zu sein scheint.\n\n8.4.1 Kontrolle der Größe und Anzahl der Bins\nMit dem Argument bins können wir die Anzahl der Bins oder die Größe jedes Bins steuern.\n\n\nCode\n# Specifying the number of bins\nplt.hist(flowers_df.sepal_width, bins=5);\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport numpy as np\nnp.arange(2, 5, 0.25)\n\n\narray([2.  , 2.25, 2.5 , 2.75, 3.  , 3.25, 3.5 , 3.75, 4.  , 4.25, 4.5 ,\n       4.75])\n\n\n\n\nCode\nimport numpy as np\n\n# Specifying the boundaries of each bin\nplt.hist(flowers_df.sepal_width, bins=np.arange(2, 5, 0.25));\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Bins of unequal sizes\nplt.hist(flowers_df.sepal_width, bins=[1, 3, 4, 4.5]);\n\n\n\n\n\n\n\n\n\n\n\n8.4.2 Mehrere Histogramme\nÄhnlich wie bei Liniendiagrammen können wir mehrere Histogramme in einem einzigen Diagramm zeichnen. Wir können die Deckkraft jedes Histogramms verringern, sodass die Balken eines Histogramms die Balken anderer nicht verbergen.\nLassen Sie uns für jede Blumenart separate Histogramme zeichnen.\n\n\nCode\n# Filter the datasets and put them apart\nsetosa_df = flowers_df[flowers_df.species == 'setosa']\nversicolor_df = flowers_df[flowers_df.species == 'versicolor']\nvirginica_df = flowers_df[flowers_df.species == 'virginica']\n\n\n\n\nCode\nplt.hist(setosa_df.sepal_width, alpha=0.3, bins=np.arange(2, 5, 0.25));\nplt.hist(versicolor_df.sepal_width, alpha=0.4, bins=np.arange(2, 5, 0.25));\n\nplt.legend(['Setosa', 'Versicolor']);\n\n\n\n\n\n\n\n\n\nWir können auch mehrere Histogramme übereinander stapeln.\n\n\nCode\nplt.title('Distribution of Sepal Width')\n\n# Pass on the same argumment the 3 datasets\nplt.hist([setosa_df.sepal_width, versicolor_df.sepal_width, virginica_df.sepal_width], \n         bins=np.arange(2, 5, 0.25), \n         stacked=True);\n\nplt.legend(['Setosa', 'Versicolor', 'Virginica']);",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung mit Python, Matplotlib und Seaborn</span>"
    ]
  },
  {
    "objectID": "kapitel7.html#balkendiagramm",
    "href": "kapitel7.html#balkendiagramm",
    "title": "8  Datenvisualisierung mit Python, Matplotlib und Seaborn",
    "section": "8.5 Balkendiagramm",
    "text": "8.5 Balkendiagramm\n\n8.5.1 Grundlagen\nBalkendiagramme sind Liniendiagrammen sehr ähnlich, d. h. sie zeigen eine Abfolge von Werten, allerdings wird für jeden Wert ein Balken angezeigt und nicht die durch Linien verbundenen Punkte. Wir können die Funktion plt.bar verwenden, um ein Balkendiagramm zu zeichnen.\n\n\nCode\nyears = range(2000, 2006)\napples = [0.35, 0.6, 0.9, 0.8, 0.65, 0.8]\noranges = [0.4, 0.8, 0.9, 0.7, 0.6, 0.8]\n\n\n\n\nCode\nplt.bar(years, oranges);\n\n\n\n\n\n\n\n\n\nWie Histogramme können auch Balken übereinander gestapelt werden. Um dies zu erreichen, verwenden wir das Argument bottom für plt.bar.\n\n\nCode\nplt.bar(years, apples)\nplt.bar(years, oranges, bottom=apples);\n\n\n\n\n\n\n\n\n\n\n\n8.5.2 Balkendiagramme mit Durchschnittswerten\nSchauen wir uns einen weiteren Beispieldatensatz an, der in Seaborn enthalten ist und tips heißt. Der Datensatz enthält Informationen zu Geschlecht, Tageszeit, Gesamtrechnung und Trinkgeldbetrag für Kunden, die über eine Woche hinweg ein Restaurant besuchen.\n\n\nCode\ntips_df = sns.load_dataset(\"tips\");\n\n\n\n\nCode\ntips_df\n\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n\n\n3\n23.68\n3.31\nMale\nNo\nSun\nDinner\n2\n\n\n4\n24.59\n3.61\nFemale\nNo\nSun\nDinner\n4\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n239\n29.03\n5.92\nMale\nNo\nSat\nDinner\n3\n\n\n240\n27.18\n2.00\nFemale\nYes\nSat\nDinner\n2\n\n\n241\n22.67\n2.00\nMale\nYes\nSat\nDinner\n2\n\n\n242\n17.82\n1.75\nMale\nNo\nSat\nDinner\n2\n\n\n243\n18.78\n3.00\nFemale\nNo\nThur\nDinner\n2\n\n\n\n\n244 rows × 7 columns\n\n\n\nMöglicherweise möchten wir ein Balkendiagramm zeichnen, um zu veranschaulichen, wie der durchschnittliche Rechnungsbetrag an verschiedenen Wochentagen variiert. Eine Möglichkeit, dies zu tun, wäre, die Tagesdurchschnitte zu berechnen und dann plt.bar zu verwenden (versuchen Sie es als Übung).\nDa dies jedoch ein sehr häufiger Anwendungsfall ist, bietet die Seaborn-Bibliothek eine Barplot-Funktion, mit der Durchschnittswerte automatisch berechnet werden können.\n\n\nCode\nsns.barplot(x='day', y='total_bill', data=tips_df);\n\n\n\n\n\n\n\n\n\nDie Linien, die jeden Balken schneiden, stellen das Ausmaß der Variation in den Werten dar. So scheint es zum Beispiel so zu sein, dass die Schwankung der Gesamtrechnung freitags recht hoch und am Samstag geringer war.\nWir können auch ein hue-Argument angeben, um Balkendiagramme nebeneinander zu vergleichen, basierend auf einem dritten Merkmal, z. B. Sex.\n\n\nCode\nsns.barplot(x='day', y='total_bill', hue='sex', data=tips_df);\n\n\n\n\n\n\n\n\n\nSie können die Balken einfach durch Vertauschen der Achsen horizontal machen.\n\n\nCode\nsns.barplot(x='total_bill', y='day', hue='sex', data=tips_df);",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung mit Python, Matplotlib und Seaborn</span>"
    ]
  },
  {
    "objectID": "kapitel7.html#heatmap",
    "href": "kapitel7.html#heatmap",
    "title": "8  Datenvisualisierung mit Python, Matplotlib und Seaborn",
    "section": "8.6 Heatmap",
    "text": "8.6 Heatmap\nEine Heatmap wird verwendet, um zweidimensionale Daten wie eine Matrix oder eine Tabelle mithilfe von Farben zu visualisieren. Der beste Weg, es zu verstehen, ist, sich ein Beispiel anzusehen. Wir verwenden einen weiteren Beispieldatensatz von Seaborn mit der Bezeichnung „flights“, um die monatliche Passagierfrequenz an einem Flughafen über einen Zeitraum von 12 Jahren zu visualisieren.\n\n\nCode\nflights_df = sns.load_dataset(\"flights\").pivot(index=\"month\", columns=\"year\", values=\"passengers\")\n\n\n\n\nCode\nflights_df\n\n\n\n\n\n\n\n\nyear\n1949\n1950\n1951\n1952\n1953\n1954\n1955\n1956\n1957\n1958\n1959\n1960\n\n\nmonth\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJan\n112\n115\n145\n171\n196\n204\n242\n284\n315\n340\n360\n417\n\n\nFeb\n118\n126\n150\n180\n196\n188\n233\n277\n301\n318\n342\n391\n\n\nMar\n132\n141\n178\n193\n236\n235\n267\n317\n356\n362\n406\n419\n\n\nApr\n129\n135\n163\n181\n235\n227\n269\n313\n348\n348\n396\n461\n\n\nMay\n121\n125\n172\n183\n229\n234\n270\n318\n355\n363\n420\n472\n\n\nJun\n135\n149\n178\n218\n243\n264\n315\n374\n422\n435\n472\n535\n\n\nJul\n148\n170\n199\n230\n264\n302\n364\n413\n465\n491\n548\n622\n\n\nAug\n148\n170\n199\n242\n272\n293\n347\n405\n467\n505\n559\n606\n\n\nSep\n136\n158\n184\n209\n237\n259\n312\n355\n404\n404\n463\n508\n\n\nOct\n119\n133\n162\n191\n211\n229\n274\n306\n347\n359\n407\n461\n\n\nNov\n104\n114\n146\n172\n180\n203\n237\n271\n305\n310\n362\n390\n\n\nDec\n118\n140\n166\n194\n201\n229\n278\n306\n336\n337\n405\n432\n\n\n\n\n\n\n\nflights_df ist eine Matrix mit einer Zeile für jeden Monat und einer Spalte für jedes Jahr. Die Werte in der Matrix zeigen die Anzahl der Passagiere (in Tausend), die den Flughafen in einem bestimmten Monat eines bestimmten Jahres besuchten. Mit der Funktion sns.heatmap können wir die Passantenfrequenz am Flughafen visualisieren.\n\n\nCode\nplt.title(\"No. of Passengers (1000s)\")\nsns.heatmap(flights_df);\n\n\n\n\n\n\n\n\n\nDie helleren Farben weisen auf eine höhere Passantenfrequenz am Flughafen hin. Wenn wir uns die Grafik ansehen, können wir zwei Dinge ableiten:\n\nDie Besucherfrequenz am Flughafen ist in jedem Jahr im Juli und August am höchsten.\nDie Besucherfrequenz am Flughafen nimmt in jedem Monat von Jahr zu Jahr zu.\n\nWir können auch die tatsächlichen Werte in jedem Block anzeigen, indem wir annot=True angeben und das Argument cmap verwenden, um die Farbpalette zu ändern.\n\n\nCode\nplt.title(\"No. of Passengers (1000s)\")\nsns.heatmap(flights_df, fmt=\"d\", annot=True, cmap='Blues');",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung mit Python, Matplotlib und Seaborn</span>"
    ]
  },
  {
    "objectID": "kapitel7.html#bilder",
    "href": "kapitel7.html#bilder",
    "title": "8  Datenvisualisierung mit Python, Matplotlib und Seaborn",
    "section": "8.7 Bilder",
    "text": "8.7 Bilder\nMatplotlib kann auch zum Anzeigen von Bildern verwendet werden.\nBevor ein Bild angezeigt werden kann, muss es mit dem Modul PIL in den Speicher eingelesen werden. Nutzen wir hierfür das Bild aus dem Data Ordner chart.jpg.\n\n\nCode\nfrom PIL import Image\n\n\n\n\nCode\nimg = Image.open('data/chart.jpg')\n\n\nEin mit PIL geladenes Bild ist einfach ein dreidimensionales Numpy-Array, das Pixelintensitäten für die roten, grünen und blauen (RGB) Kanäle des Bildes enthält. Wir können das Bild mit np.array in ein Array konvertieren.\n\n\nCode\nimg_array = np.array(img)\n\n\n\n\nCode\nimg_array.shape\n\n\n(481, 640, 3)\n\n\nWir können das PIL-Bild mit plt.imshow anzeigen.\n\n\nCode\nplt.imshow(img);\n\n\n\n\n\n\n\n\n\nMit den entsprechenden Funktionen können wir die Achsen und Gitterlinien ausschalten und einen Titel anzeigen.\n\n\nCode\nplt.grid(False)\nplt.title('A data science meme')\nplt.axis('off')\nplt.imshow(img);\n\n\n\n\n\n\n\n\n\nUm einen Teil des Bildes anzuzeigen, können wir einfach ein Segment aus dem Numpy-Array auswählen.\n\n\nCode\nplt.grid(False)\nplt.axis('off')\nplt.imshow(img_array[125:325,105:305]);",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung mit Python, Matplotlib und Seaborn</span>"
    ]
  },
  {
    "objectID": "kapitel7.html#mehrere-diagramme-in-einem-raster-darstellen",
    "href": "kapitel7.html#mehrere-diagramme-in-einem-raster-darstellen",
    "title": "8  Datenvisualisierung mit Python, Matplotlib und Seaborn",
    "section": "8.8 Mehrere Diagramme in einem Raster darstellen",
    "text": "8.8 Mehrere Diagramme in einem Raster darstellen\n\n8.8.1 Grundlagen\nMatplotlib und Seaborn unterstützen auch das Plotten mehrerer Diagramme in einem Raster mithilfe von plt.subplots, das einen Satz von Achsen zurückgibt, die zum Plotten verwendet werden können.\nHier ist ein einzelnes Raster, das die verschiedenen Arten von Diagrammen zeigt, die wir in diesem Tutorial behandelt haben.\n\n\nCode\nfig, axes = plt.subplots(2, 3, figsize=(16, 8))\n\naxes[0, 0].plot(years, apples, 's--b')\naxes[0, 0].plot(years, oranges, 'o--r')\naxes[0, 0].set_xlabel('Year')\naxes[0, 0].set_ylabel('Yield (tons per hectar)')\naxes[0, 0].set_title('Yield or Oranges')\naxes[0, 0].legend(['Apples', 'Oranges'])\n\naxes[0, 1].set_title('Sepal lenght vs Yield')\nsns.scatterplot(x=flowers_df.sepal_length,\n                y=flowers_df.sepal_width,\n                hue=flowers_df.species, \n                s=100, \n                ax=axes[0, 1])\n\nplt.tight_layout(pad=2);\n\n\n\n\n\n\n\n\n\n\n\nCode\naxes\n\n\narray([[&lt;Axes: title={'center': 'Yield or Oranges'}, xlabel='Year', ylabel='Yield (tons per hectar)'&gt;,\n        &lt;Axes: title={'center': 'Sepal lenght vs Yield'}, xlabel='sepal_length', ylabel='sepal_width'&gt;,\n        &lt;Axes: &gt;],\n       [&lt;Axes: &gt;, &lt;Axes: &gt;, &lt;Axes: &gt;]], dtype=object)\n\n\n\n\nCode\naxes.shape\n\n\n(2, 3)\n\n\n\n\nCode\nfig, axes = plt.subplots(2, 3, figsize=(16, 8))\n\n# Use the axes for plotting\naxes[0,0].plot(years, apples, 's-b')\naxes[0,0].plot(years, oranges, 'o--r')\naxes[0,0].set_xlabel('Year')\naxes[0,0].set_ylabel('Yield (tons per hectare)')\naxes[0,0].legend(['Apples', 'Oranges']);\naxes[0,0].set_title('Crop Yields in Kanto')\n\n\n# Pass the axes into seaborn\naxes[0,1].set_title('Sepal Length vs. Sepal Width')\nsns.scatterplot(x=flowers_df.sepal_length, \n                y=flowers_df.sepal_width, \n                hue=flowers_df.species, \n                s=100, \n                ax=axes[0,1]);\n\n# Use the axes for plotting\naxes[0,2].set_title('Distribution of Sepal Width')\naxes[0,2].hist([setosa_df.sepal_width, versicolor_df.sepal_width, virginica_df.sepal_width], \n         bins=np.arange(2, 5, 0.25), \n         stacked=True);\n\naxes[0,2].legend(['Setosa', 'Versicolor', 'Virginica']);\n\n# Pass the axes into seaborn\naxes[1,0].set_title('Restaurant bills')\nsns.barplot(x='day', y='total_bill', hue='sex', data=tips_df, ax=axes[1,0]);\n\n# Pass the axes into seaborn\naxes[1,1].set_title('Flight traffic')\nsns.heatmap(flights_df, cmap='Blues', ax=axes[1,1]);\n\n# Plot an image using the axes\naxes[1,2].set_title('Data Science Meme')\naxes[1,2].imshow(img)\naxes[1,2].grid(False)\naxes[1,2].set_xticks([])\naxes[1,2].set_yticks([])\n\nplt.tight_layout(pad=2);\n\n\n\n\n\n\n\n\n\nEine vollständige Liste der unterstützten Funktionen finden Sie auf dieser Seite.\n\n\n8.8.2 Parzellen mit Seaborn koppeln\nSeaborn bietet außerdem eine Hilfsfunktion sns.pairplot, um automatisch verschiedene Arten von Diagrammen für Merkmalspaare innerhalb eines Data Frames zu zeichnen.\n\n\nCode\nsns.pairplot(flowers_df, hue='species');\n\n\n\n\n\n\n\n\n\n\n\nCode\nsns.pairplot(tips_df, hue='sex');",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung mit Python, Matplotlib und Seaborn</span>"
    ]
  },
  {
    "objectID": "kapitel7.html#weiterführende-literatur",
    "href": "kapitel7.html#weiterführende-literatur",
    "title": "8  Datenvisualisierung mit Python, Matplotlib und Seaborn",
    "section": "8.9 Weiterführende Literatur",
    "text": "8.9 Weiterführende Literatur\nIn diesem Tutorial haben wir einige der grundlegenden Konzepte und beliebten Techniken zur Datenvisualisierung mit Matplotlib und Seaborn behandelt. Datenvisualisierung ist ein weites Feld und wir haben hier kaum an der Oberfläche gekratzt. Schauen Sie sich diese Referenzen an, um mehr zu erfahren und zu entdecken:\n\nSeaborn-Galerie\nMatplotlib-Galerie\nMatplotlib-Tutorial",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung mit Python, Matplotlib und Seaborn</span>"
    ]
  },
  {
    "objectID": "kapitel8.html",
    "href": "kapitel8.html",
    "title": "9  Explorative Datenanalyse mit Python – Eine Fallstudie",
    "section": "",
    "text": "9.1 Einführung\nAnalyse der Antworten aus der jährlichen Entwicklerumfrage 2020 von Stack Overflow\nDieses Tutorial ist das achte (und letzte) in einer Reihe zur Einführung in die Programmierung und Datenanalyse mit der Python-Programmiersprache. Diese Tutorials basieren auf einem praktischen, programmbasierten Ansatz. Der beste Weg, das Material zu erlernen, besteht darin, den Code auszuführen und mit den Beispielen zu experimentieren.\nDie folgenden Themen werden in diesem Tutorial behandelt:\nFür unsere Analyse verwenden wir den StackOverflow-Entwicklerumfragedatensatz. Dies ist eine jährliche Umfrage, die von StackOverflow durchgeführt wird. Die Rohdaten und Ergebnisse finden Sie hier.\nEs gibt mehrere Möglichkeiten, den Datensatz in Jupyter zu importieren:\nWir nutzen die bereits heruntergeladene Datei, die sich im data Ordner befindet.\nCode\nimport os\nCode\nos.listdir('data/stack-overflow-developer-survey-2020')\n\n\n['README_2020.txt',\n 'so_survey_2020.pdf',\n 'survey_results_public.csv',\n 'survey_results_schema.csv']\nSie können die heruntergeladenen Dateien mit der Menüoption Datei &gt; Öffnen in Jupyter durchsuchen. Es scheint, als ob der Datensatz drei Dateien enthält:\nLaden wir die CSV-Dateien mithilfe der Pandas-Bibliothek. Wir verwenden den Namen survey_raw_df für das Data Frame, um anzuzeigen, dass es sich um unverarbeitete Daten handelt, die wir möglicherweise bereinigen, filtern und ändern, um ein Data Frame vorzubereiten, der für die Analyse bereit ist.\nCode\nimport pandas as pd\nCode\nsurvey_raw_df = pd.read_csv('data/stack-overflow-developer-survey-2020/survey_results_public.csv')\nCode\nsurvey_raw_df\n\n\n\n\n\n\n\n\n\nRespondent\nMainBranch\nHobbyist\nAge\nAge1stCode\nCompFreq\nCompTotal\nConvertedComp\nCountry\nCurrencyDesc\n...\nSurveyEase\nSurveyLength\nTrans\nUndergradMajor\nWebframeDesireNextYear\nWebframeWorkedWith\nWelcomeChange\nWorkWeekHrs\nYearsCode\nYearsCodePro\n\n\n\n\n0\n1\nI am a developer by profession\nYes\nNaN\n13\nMonthly\nNaN\nNaN\nGermany\nEuropean Euro\n...\nNeither easy nor difficult\nAppropriate in length\nNo\nComputer science, computer engineering, or sof...\nASP.NET Core\nASP.NET;ASP.NET Core\nJust as welcome now as I felt last year\n50.0\n36\n27\n\n\n1\n2\nI am a developer by profession\nNo\nNaN\n19\nNaN\nNaN\nNaN\nUnited Kingdom\nPound sterling\n...\nNaN\nNaN\nNaN\nComputer science, computer engineering, or sof...\nNaN\nNaN\nSomewhat more welcome now than last year\nNaN\n7\n4\n\n\n2\n3\nI code primarily as a hobby\nYes\nNaN\n15\nNaN\nNaN\nNaN\nRussian Federation\nNaN\n...\nNeither easy nor difficult\nAppropriate in length\nNaN\nNaN\nNaN\nNaN\nSomewhat more welcome now than last year\nNaN\n4\nNaN\n\n\n3\n4\nI am a developer by profession\nYes\n25.0\n18\nNaN\nNaN\nNaN\nAlbania\nAlbanian lek\n...\nNaN\nNaN\nNo\nComputer science, computer engineering, or sof...\nNaN\nNaN\nSomewhat less welcome now than last year\n40.0\n7\n4\n\n\n4\n5\nI used to be a developer by profession, but no...\nYes\n31.0\n16\nNaN\nNaN\nNaN\nUnited States\nNaN\n...\nEasy\nToo short\nNo\nComputer science, computer engineering, or sof...\nDjango;Ruby on Rails\nRuby on Rails\nJust as welcome now as I felt last year\nNaN\n15\n8\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n64456\n64858\nNaN\nYes\nNaN\n16\nNaN\nNaN\nNaN\nUnited States\nNaN\n...\nNaN\nNaN\nNaN\nComputer science, computer engineering, or sof...\nNaN\nNaN\nNaN\nNaN\n10\nLess than 1 year\n\n\n64457\n64867\nNaN\nYes\nNaN\nNaN\nNaN\nNaN\nNaN\nMorocco\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n64458\n64898\nNaN\nYes\nNaN\nNaN\nNaN\nNaN\nNaN\nViet Nam\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n64459\n64925\nNaN\nYes\nNaN\nNaN\nNaN\nNaN\nNaN\nPoland\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nAngular;Angular.js;React.js\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n64460\n65112\nNaN\nYes\nNaN\nNaN\nNaN\nNaN\nNaN\nSpain\nNaN\n...\nNaN\nNaN\nNaN\nComputer science, computer engineering, or sof...\nASP.NET Core;jQuery\nAngular;Angular.js;ASP.NET Core;jQuery\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n64461 rows × 61 columns\nDer Datensatz enthält über 64.000 Antworten auf 60 Fragen (obwohl viele Fragen optional sind). Die Antworten wurden anonymisiert und es stehen uns keine personenbezogenen Daten zur Verfügung – obwohl jedem Befragten eine zufällige Befragten-ID zugewiesen wurde.\nSehen wir uns die Liste der Spalten im Data Frame an.\nCode\nsurvey_raw_df.columns\n\n\nIndex(['Respondent', 'MainBranch', 'Hobbyist', 'Age', 'Age1stCode', 'CompFreq',\n       'CompTotal', 'ConvertedComp', 'Country', 'CurrencyDesc',\n       'CurrencySymbol', 'DatabaseDesireNextYear', 'DatabaseWorkedWith',\n       'DevType', 'EdLevel', 'Employment', 'Ethnicity', 'Gender', 'JobFactors',\n       'JobSat', 'JobSeek', 'LanguageDesireNextYear', 'LanguageWorkedWith',\n       'MiscTechDesireNextYear', 'MiscTechWorkedWith',\n       'NEWCollabToolsDesireNextYear', 'NEWCollabToolsWorkedWith', 'NEWDevOps',\n       'NEWDevOpsImpt', 'NEWEdImpt', 'NEWJobHunt', 'NEWJobHuntResearch',\n       'NEWLearn', 'NEWOffTopic', 'NEWOnboardGood', 'NEWOtherComms',\n       'NEWOvertime', 'NEWPurchaseResearch', 'NEWPurpleLink', 'NEWSOSites',\n       'NEWStuck', 'OpSys', 'OrgSize', 'PlatformDesireNextYear',\n       'PlatformWorkedWith', 'PurchaseWhat', 'Sexuality', 'SOAccount',\n       'SOComm', 'SOPartFreq', 'SOVisitFreq', 'SurveyEase', 'SurveyLength',\n       'Trans', 'UndergradMajor', 'WebframeDesireNextYear',\n       'WebframeWorkedWith', 'WelcomeChange', 'WorkWeekHrs', 'YearsCode',\n       'YearsCodePro'],\n      dtype='object')\nEs scheint, dass Kurzcodes für Fragen als Spaltennamen verwendet werden.\nWir können auf die Schemadatei verweisen, um den vollständigen Text jeder Frage anzuzeigen. Die Schemadatei enthält nur zwei Spalten: Column und QuestionText, sodass wir sie als Pandas-Serie mit Column als Index und QuestionText als Wert laden können.\nCode\nschema_fname = 'data/stack-overflow-developer-survey-2020/survey_results_schema.csv'\nschema_raw = pd.read_csv(schema_fname, index_col='Column').QuestionText\nCode\nschema_raw\n\n\nColumn\nRespondent            Randomized respondent ID number (not in order ...\nMainBranch            Which of the following options best describes ...\nHobbyist                                        Do you code as a hobby?\nAge                   What is your age (in years)? If you prefer not...\nAge1stCode            At what age did you write your first line of c...\n                                            ...                        \nWebframeWorkedWith    Which web frameworks have you done extensive d...\nWelcomeChange         Compared to last year, how welcome do you feel...\nWorkWeekHrs           On average, how many hours per week do you wor...\nYearsCode             Including any education, how many years have y...\nYearsCodePro          NOT including education, how many years have y...\nName: QuestionText, Length: 61, dtype: object\nWir können jetzt schema_raw verwenden, um den vollständigen Fragentext für jede Spalte in survey_raw_df abzurufen.\nCode\nschema_raw['YearsCodePro']\n\n\n'NOT including education, how many years have you coded professionally (as a part of your work)?'\nWir haben den Datensatz nun geladen und können mit dem nächsten Schritt der Vorverarbeitung und Bereinigung der Daten für unsere Analyse fortfahren.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Explorative Datenanalyse mit Python – Eine Fallstudie</span>"
    ]
  },
  {
    "objectID": "kapitel8.html#einführung",
    "href": "kapitel8.html#einführung",
    "title": "9  Explorative Datenanalyse mit Python – Eine Fallstudie",
    "section": "",
    "text": "Laden Sie die CSV-Datei manuell herunter und laden Sie sie über die Jupyter-GUI hoch\nVerwenden Sie die Funktion „urlretrieve“ aus urllib.request, um CSV-Dateien direkt von einer Roh-URL herunterzuladen\n\n\n\n\n\n\nREADME.txt – enthält Informationen zum Datensatz\nsurvey_results_schema.csv – enthält die Liste der Fragen (und Kurzcodes für jede Frage)\nsurvey_results_public.csv – die vollständige Liste der Antworten auf die Fragen",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Explorative Datenanalyse mit Python – Eine Fallstudie</span>"
    ]
  },
  {
    "objectID": "kapitel8.html#datenvorbereitung-und--aufbereitung",
    "href": "kapitel8.html#datenvorbereitung-und--aufbereitung",
    "title": "9  Explorative Datenanalyse mit Python – Eine Fallstudie",
    "section": "9.2 Datenvorbereitung und -aufbereitung",
    "text": "9.2 Datenvorbereitung und -aufbereitung\nObwohl die Umfrageantworten eine Fülle von Informationen enthalten, beschränken wir unsere Analyse auf die folgenden Bereiche:\n\nDemografische Daten der Umfrageteilnehmer und der globalen Programmiergemeinschaft\nVerteilung von Programmierkenntnissen, Erfahrungen und Vorlieben\nBeschäftigungsbezogene Informationen, Vorlieben und Meinungen\n\nWählen wir eine Teilmenge von Spalten mit den relevanten Daten für unsere Analyse aus.\n\n\nCode\nselected_columns = [\n    # Demographics\n    'Country',\n    'Age',\n    'Gender',\n    'EdLevel',\n    'UndergradMajor',\n    # Programming experience\n    'Hobbyist',\n    'Age1stCode',\n    'YearsCode',\n    'YearsCodePro',\n    'LanguageWorkedWith',\n    'LanguageDesireNextYear',\n    'NEWLearn',\n    'NEWStuck',\n    # Employment\n    'Employment',\n    'DevType',\n    'WorkWeekHrs',\n    'JobSat',\n    'JobFactors',\n    'NEWOvertime',\n    'NEWEdImpt'\n]\n\n\n\n\nCode\nlen(selected_columns)\n\n\n20\n\n\nExtrahieren wir eine Kopie der Daten aus diesen Spalten in einem neuen Data Frame survey_df, das wir weiter ändern können, ohne das ursprüngliche Data Frame zu beeinträchtigen.\n\n\nCode\nsurvey_df = survey_raw_df[selected_columns].copy()\n\n\n\n\nCode\nschema = schema_raw[selected_columns]\n\n\n\n\nCode\nsurvey_df\n\n\n\n\n\n\n\n\n\nCountry\nAge\nGender\nEdLevel\nUndergradMajor\nHobbyist\nAge1stCode\nYearsCode\nYearsCodePro\nLanguageWorkedWith\nLanguageDesireNextYear\nNEWLearn\nNEWStuck\nEmployment\nDevType\nWorkWeekHrs\nJobSat\nJobFactors\nNEWOvertime\nNEWEdImpt\n\n\n\n\n0\nGermany\nNaN\nMan\nMaster’s degree (M.A., M.S., M.Eng., MBA, etc.)\nComputer science, computer engineering, or sof...\nYes\n13\n36\n27\nC#;HTML/CSS;JavaScript\nC#;HTML/CSS;JavaScript\nOnce a year\nVisit Stack Overflow;Go for a walk or other ph...\nIndependent contractor, freelancer, or self-em...\nDeveloper, desktop or enterprise applications;...\n50.0\nSlightly satisfied\nLanguages, frameworks, and other technologies ...\nOften: 1-2 days per week or more\nFairly important\n\n\n1\nUnited Kingdom\nNaN\nNaN\nBachelor’s degree (B.A., B.S., B.Eng., etc.)\nComputer science, computer engineering, or sof...\nNo\n19\n7\n4\nJavaScript;Swift\nPython;Swift\nOnce a year\nVisit Stack Overflow;Go for a walk or other ph...\nEmployed full-time\nDeveloper, full-stack;Developer, mobile\nNaN\nVery dissatisfied\nNaN\nNaN\nFairly important\n\n\n2\nRussian Federation\nNaN\nNaN\nNaN\nNaN\nYes\n15\n4\nNaN\nObjective-C;Python;Swift\nObjective-C;Python;Swift\nOnce a decade\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\nAlbania\n25.0\nMan\nMaster’s degree (M.A., M.S., M.Eng., MBA, etc.)\nComputer science, computer engineering, or sof...\nYes\n18\n7\n4\nNaN\nNaN\nOnce a year\nNaN\nNaN\nNaN\n40.0\nSlightly dissatisfied\nFlex time or a flexible schedule;Office enviro...\nOccasionally: 1-2 days per quarter but less th...\nNot at all important/not necessary\n\n\n4\nUnited States\n31.0\nMan\nBachelor’s degree (B.A., B.S., B.Eng., etc.)\nComputer science, computer engineering, or sof...\nYes\n16\n15\n8\nHTML/CSS;Ruby;SQL\nJava;Ruby;Scala\nOnce a year\nCall a coworker or friend;Visit Stack Overflow...\nEmployed full-time\nNaN\nNaN\nNaN\nNaN\nNaN\nVery important\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n64456\nUnited States\nNaN\nNaN\nMaster’s degree (M.A., M.S., M.Eng., MBA, etc.)\nComputer science, computer engineering, or sof...\nYes\n16\n10\nLess than 1 year\nNaN\nNaN\nOnce a decade\nCall a coworker or friend\nEmployed full-time\nSenior executive/VP\nNaN\nNaN\nNaN\nNaN\nVery important\n\n\n64457\nMorocco\nNaN\nNaN\nNaN\nNaN\nYes\nNaN\nNaN\nNaN\nAssembly;Bash/Shell/PowerShell;C;C#;C++;Dart;G...\nAssembly;Bash/Shell/PowerShell;C;C#;C++;Dart;G...\nNaN\nNaN\nEmployed full-time\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n64458\nViet Nam\nNaN\nNaN\nPrimary/elementary school\nNaN\nYes\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n64459\nPoland\nNaN\nNaN\nNaN\nNaN\nYes\nNaN\nNaN\nNaN\nHTML/CSS\nHTML/CSS;Java;JavaScript\nOnce a year\nCall a coworker or friend;Visit Stack Overflow\nEmployed full-time\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n64460\nSpain\nNaN\nNaN\nOther doctoral degree (Ph.D., Ed.D., etc.)\nComputer science, computer engineering, or sof...\nYes\nNaN\nNaN\nNaN\nC#;HTML/CSS;Java;JavaScript;SQL\nC#;HTML/CSS;Java;JavaScript;SQL\nOnce a year\nMeditate;Visit Stack Overflow;Go for a walk or...\nEmployed full-time\nNaN\nNaN\nNaN\nNaN\nNaN\nCritically important\n\n\n\n\n64461 rows × 20 columns\n\n\n\n\n\nCode\nschema\n\n\nColumn\nCountry                                                  Where do you live?\nAge                       What is your age (in years)? If you prefer not...\nGender                    Which of the following describe you, if any? P...\nEdLevel                   Which of the following best describes the high...\nUndergradMajor                        What was your primary field of study?\nHobbyist                                            Do you code as a hobby?\nAge1stCode                At what age did you write your first line of c...\nYearsCode                 Including any education, how many years have y...\nYearsCodePro              NOT including education, how many years have y...\nLanguageWorkedWith        Which programming, scripting, and markup langu...\nLanguageDesireNextYear    Which programming, scripting, and markup langu...\nNEWLearn                  How frequently do you learn a new language or ...\nNEWStuck                  What do you do when you get stuck on a problem...\nEmployment                Which of the following best describes your cur...\nDevType                   Which of the following describe you? Please se...\nWorkWeekHrs               On average, how many hours per week do you wor...\nJobSat                    How satisfied are you with your current job? (...\nJobFactors                Imagine that you are deciding between two job ...\nNEWOvertime               How often do you work overtime or beyond the f...\nNEWEdImpt                 How important is a formal education, such as a...\nName: QuestionText, dtype: object\n\n\n\n\nCode\nschema.shape\n\n\n(20,)\n\n\nSehen wir uns einige grundlegende Informationen zum Data Frame an.\n\n\nCode\nsurvey_df.shape\n\n\n(64461, 20)\n\n\n\n\nCode\nsurvey_df.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 64461 entries, 0 to 64460\nData columns (total 20 columns):\n #   Column                  Non-Null Count  Dtype  \n---  ------                  --------------  -----  \n 0   Country                 64072 non-null  object \n 1   Age                     45446 non-null  float64\n 2   Gender                  50557 non-null  object \n 3   EdLevel                 57431 non-null  object \n 4   UndergradMajor          50995 non-null  object \n 5   Hobbyist                64416 non-null  object \n 6   Age1stCode              57900 non-null  object \n 7   YearsCode               57684 non-null  object \n 8   YearsCodePro            46349 non-null  object \n 9   LanguageWorkedWith      57378 non-null  object \n 10  LanguageDesireNextYear  54113 non-null  object \n 11  NEWLearn                56156 non-null  object \n 12  NEWStuck                54983 non-null  object \n 13  Employment              63854 non-null  object \n 14  DevType                 49370 non-null  object \n 15  WorkWeekHrs             41151 non-null  float64\n 16  JobSat                  45194 non-null  object \n 17  JobFactors              49349 non-null  object \n 18  NEWOvertime             43231 non-null  object \n 19  NEWEdImpt               48465 non-null  object \ndtypes: float64(2), object(18)\nmemory usage: 9.8+ MB\n\n\nDie meisten Spalten haben den Datentyp Objekt, entweder weil sie Werte unterschiedlichen Typs enthalten, oder weil sie leere Werte enthalten, die mit NaN dargestellt werden. Es scheint, dass jede Spalte einige leere Werte enthält, da die Nicht-Null-Anzahl für jede Spalte niedriger ist als die Gesamtzahl der Zeilen (64461). Wir müssen mit leeren Werten umgehen und den Datentyp für jede Spalte von Fall zu Fall manuell anpassen.\nNur zwei der Spalten wurden als numerische Spalten (Age und WorkWeekHrs) erkannt, obwohl es einige andere Spalten gibt, die überwiegend numerische Werte enthalten. Um unsere Analyse zu vereinfachen, konvertieren wir einige andere Spalten in numerische Datentypen und ignorieren dabei alle nicht numerischen Werte (sie werden in NaNs konvertiert).\n\n\nCode\nsurvey_df.Age1stCode\n\n\n0         13\n1         19\n2         15\n3         18\n4         16\n        ... \n64456     16\n64457    NaN\n64458    NaN\n64459    NaN\n64460    NaN\nName: Age1stCode, Length: 64461, dtype: object\n\n\n\n\nCode\nsurvey_df.Age1stCode.unique()\n\n\narray(['13', '19', '15', '18', '16', '14', '12', '20', '42', '8', '25',\n       '22', '30', '17', '21', '10', '46', '9', '7', '11', '6', nan, '31',\n       '29', '5', 'Younger than 5 years', '28', '38', '23', '27', '41',\n       '24', '53', '26', '35', '32', '40', '33', '36', '54', '48', '56',\n       '45', '44', '34', 'Older than 85', '39', '51', '68', '50', '37',\n       '47', '43', '52', '85', '64', '55', '58', '49', '76', '72', '73',\n       '83', '63'], dtype=object)\n\n\n\n\nCode\nsurvey_df['Age1stCode'] = pd.to_numeric(survey_df.Age1stCode, errors='coerce')\nsurvey_df['YearsCode'] = pd.to_numeric(survey_df.YearsCode, errors='coerce')\nsurvey_df['YearsCodePro'] = pd.to_numeric(survey_df.YearsCodePro, errors='coerce')\n\n\nSehen wir uns nun einige grundlegende Statistiken zu den numerischen Spalten an.\n\n\nCode\nsurvey_df.describe()\n\n\n\n\n\n\n\n\n\nAge\nAge1stCode\nYearsCode\nYearsCodePro\nWorkWeekHrs\n\n\n\n\ncount\n45446.000000\n57473.000000\n56784.000000\n44133.000000\n41151.000000\n\n\nmean\n30.834111\n15.476572\n12.782051\n8.869667\n40.782174\n\n\nstd\n9.585392\n5.114081\n9.490657\n7.759961\n17.816383\n\n\nmin\n1.000000\n5.000000\n1.000000\n1.000000\n1.000000\n\n\n25%\n24.000000\n12.000000\n6.000000\n3.000000\n40.000000\n\n\n50%\n29.000000\n15.000000\n10.000000\n6.000000\n40.000000\n\n\n75%\n35.000000\n18.000000\n17.000000\n12.000000\n44.000000\n\n\nmax\n279.000000\n85.000000\n50.000000\n50.000000\n475.000000\n\n\n\n\n\n\n\nEs scheint ein Problem mit der Altersspalte zu geben, da der Mindestwert 1 und der Höchstwert 279 beträgt. Dies ist ein häufiges Problem bei Umfragen: Antworten können aufgrund versehentlicher oder absichtlicher Fehler bei der Beantwortung ungültige Werte enthalten. Eine einfache Lösung besteht darin, die Zeilen, in denen der Wert in der Altersspalte höher als 100 Jahre oder niedriger als 10 Jahre ist, als ungültige Umfrageantworten zu ignorieren. Dies kann mit der .drop-Methode erfolgen, wie hier erklärt.\n\n\nCode\nsurvey_df.drop(survey_df[survey_df.Age &lt; 10].index, inplace=True)\nsurvey_df.drop(survey_df[survey_df.Age &gt; 100].index, inplace=True)\n\n\nDas Gleiche gilt für WorkWeekHrs. Ignorieren wir Einträge, bei denen der Wert für die Spalte höher als 140 Stunden ist. (~20 Stunden pro Tag).\n\n\nCode\nsurvey_df.drop(survey_df[survey_df.WorkWeekHrs &gt; 140].index, inplace=True)\n\n\nIn der Spalte Gender können auch mehrere Optionen ausgewählt werden. Um unsere Analyse zu vereinfachen, entfernen wir jedoch Werte, die mehr als eine Option enthalten.\n\n\nCode\nschema.Gender\n\n\n'Which of the following describe you, if any? Please check all that apply. If you prefer not to answer, you may leave this question blank.'\n\n\n\n\nCode\nsurvey_df['Gender'].value_counts()\n\n\nMan                                                            45895\nWoman                                                           3835\nNon-binary, genderqueer, or gender non-conforming                385\nMan;Non-binary, genderqueer, or gender non-conforming            121\nWoman;Non-binary, genderqueer, or gender non-conforming           92\nWoman;Man                                                         73\nWoman;Man;Non-binary, genderqueer, or gender non-conforming       25\nName: Gender, dtype: int64\n\n\n\n\nCode\nimport numpy as np\n\n\n\n\nCode\nsurvey_df.where(~(survey_df.Gender.str.contains(';', na=False)), np.nan, inplace=True)\n\n\nWir haben den Datensatz nun bereinigt und für die Analyse vorbereitet. Werfen wir einen Blick auf beispielhafte Zeilen aus dem Data Frame.\n\n\nCode\nsurvey_df.sample(10)\n\n\n\n\n\n\n\n\n\nCountry\nAge\nGender\nEdLevel\nUndergradMajor\nHobbyist\nAge1stCode\nYearsCode\nYearsCodePro\nLanguageWorkedWith\nLanguageDesireNextYear\nNEWLearn\nNEWStuck\nEmployment\nDevType\nWorkWeekHrs\nJobSat\nJobFactors\nNEWOvertime\nNEWEdImpt\n\n\n\n\n10740\nSouth Africa\nNaN\nWoman\nBachelor’s degree (B.A., B.S., B.Eng., etc.)\nComputer science, computer engineering, or sof...\nYes\n14.0\n30.0\n22.0\nC#;HTML/CSS;Java;JavaScript;SQL;VBA\nC#;HTML/CSS;Java;JavaScript;SQL\nEvery few months\nVisit Stack Overflow;Go for a walk or other ph...\nEmployed full-time\nData or business analyst;Data scientist or mac...\nNaN\nNaN\nNaN\nNaN\nVery important\n\n\n26701\nItaly\n33.0\nMan\nSome college/university study without earning ...\nComputer science, computer engineering, or sof...\nYes\n8.0\n20.0\n13.0\nC#;C++;HTML/CSS;Java;JavaScript;PHP;Python;SQL...\nC++;Java;Scala\nEvery few months\nCall a coworker or friend;Visit Stack Overflow...\nEmployed full-time\nDeveloper, back-end;Developer, desktop or ente...\n40.0\nVery satisfied\nLanguages, frameworks, and other technologies ...\nOften: 1-2 days per week or more\nSomewhat important\n\n\n20360\nAustralia\n25.0\nMan\nMaster’s degree (M.A., M.S., M.Eng., MBA, etc.)\nComputer science, computer engineering, or sof...\nYes\n13.0\n12.0\n3.0\nHTML/CSS;JavaScript;PHP;Python\nGo;R;TypeScript\nOnce a year\nPlay games;Call a coworker or friend;Visit Sta...\nEmployed full-time\nDeveloper, embedded applications or devices;De...\n40.0\nSlightly satisfied\nRemote work options;Office environment or comp...\nOccasionally: 1-2 days per quarter but less th...\nFairly important\n\n\n32114\nItaly\n25.0\nMan\nSome college/university study without earning ...\nComputer science, computer engineering, or sof...\nNo\n15.0\n5.0\n3.0\nAssembly;Bash/Shell/PowerShell;C;C#;C++;HTML/C...\nPHP;SQL\nOnce a decade\nCall a coworker or friend;Visit Stack Overflow\nEmployed full-time\nAcademic researcher;Database administrator;Dev...\n8.0\nSlightly satisfied\nFlex time or a flexible schedule;Languages, fr...\nSometimes: 1-2 days per month but less than we...\nCritically important\n\n\n45794\nIndia\n22.0\nWoman\nBachelor’s degree (B.A., B.S., B.Eng., etc.)\nWeb development or web design\nYes\n17.0\n5.0\n2.0\nHTML/CSS;JavaScript;PHP;SQL;VBA\nNaN\nEvery few months\nVisit Stack Overflow;Watch help / tutorial vid...\nEmployed full-time\nDesigner;Developer, back-end;Developer, front-...\n8.0\nVery satisfied\nLanguages, frameworks, and other technologies ...\nRarely: 1-2 days per year or less\nVery important\n\n\n50253\nTurkey\nNaN\nNaN\nBachelor’s degree (B.A., B.S., B.Eng., etc.)\nComputer science, computer engineering, or sof...\nYes\n18.0\n6.0\n3.0\nNaN\nNaN\nNaN\nNaN\nEmployed full-time\nDeveloper, back-end;Developer, full-stack;Deve...\n40.0\nNeither satisfied nor dissatisfied\nLanguages, frameworks, and other technologies ...\nSometimes: 1-2 days per month but less than we...\nVery important\n\n\n20655\nIndia\n24.0\nMan\nSome college/university study without earning ...\nComputer science, computer engineering, or sof...\nYes\n16.0\n9.0\n4.0\nC#;HTML/CSS;JavaScript;Python;TypeScript\nPython\nEvery few months\nVisit Stack Overflow;Go for a walk or other ph...\nEmployed full-time\nData or business analyst;Data scientist or mac...\n45.0\nSlightly dissatisfied\nDiversity of the company or organization;Langu...\nOften: 1-2 days per week or more\nNot at all important/not necessary\n\n\n10763\nUnited Kingdom\nNaN\nMan\nMaster’s degree (M.A., M.S., M.Eng., MBA, etc.)\nAnother engineering discipline (such as civil,...\nYes\n14.0\n10.0\n4.0\nBash/Shell/PowerShell;C++;Python\nBash/Shell/PowerShell;C++;Go;Python\nEvery few months\nVisit Stack Overflow;Go for a walk or other ph...\nEmployed full-time\nDevOps specialist\n40.0\nVery satisfied\nLanguages, frameworks, and other technologies ...\nOccasionally: 1-2 days per quarter but less th...\nFairly important\n\n\n46338\nNorway\n28.0\nMan\nMaster’s degree (M.A., M.S., M.Eng., MBA, etc.)\nComputer science, computer engineering, or sof...\nYes\n14.0\n7.0\n3.0\nC#;HTML/CSS;JavaScript;SQL\nC#;HTML/CSS;JavaScript;TypeScript\nOnce a year\nVisit Stack Overflow;Go for a walk or other ph...\nEmployed full-time\nData scientist or machine learning specialist;...\n38.0\nSlightly satisfied\nOffice environment or company culture;Opportun...\nOccasionally: 1-2 days per quarter but less th...\nSomewhat important\n\n\n30406\nSingapore\n33.0\nMan\nBachelor’s degree (B.A., B.S., B.Eng., etc.)\nInformation systems, information technology, o...\nNo\n23.0\n6.0\n4.0\nBash/Shell/PowerShell;C#;HTML/CSS;JavaScript;S...\nHTML/CSS;JavaScript;PHP;SQL\nNaN\nCall a coworker or friend;Visit Stack Overflow...\nEmployed full-time\nData or business analyst\n42.5\nNeither satisfied nor dissatisfied\nFlex time or a flexible schedule;Office enviro...\nRarely: 1-2 days per year or less\nSomewhat important",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Explorative Datenanalyse mit Python – Eine Fallstudie</span>"
    ]
  },
  {
    "objectID": "kapitel8.html#explorative-analyse-und-visualisierung",
    "href": "kapitel8.html#explorative-analyse-und-visualisierung",
    "title": "9  Explorative Datenanalyse mit Python – Eine Fallstudie",
    "section": "9.3 Explorative Analyse und Visualisierung",
    "text": "9.3 Explorative Analyse und Visualisierung\nBevor wir interessante Fragen zu den Umfrageantworten stellen können, wäre es hilfreich zu verstehen, wie die demografischen Merkmale, d. h. Land, Alter, Geschlecht, Bildungsniveau, Beschäftigungsniveau usw., der Befragten aussehen. Es ist wichtig, diese Variablen zu untersuchen, um zu verstehen, wie repräsentativ die Umfrage für die weltweite Programmiergemeinschaft ist, da eine Umfrage dieser Größenordnung im Allgemeinen zu einem gewissen selection bias führt.\nBeginnen wir mit dem Import von matplotlib.pyplot and seaborn.\n\n\nCode\nimport seaborn as sns\nimport matplotlib\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nsns.set_style('darkgrid')\nmatplotlib.rcParams['font.size'] = 14\nmatplotlib.rcParams['figure.figsize'] = (9, 5)\nmatplotlib.rcParams['figure.facecolor'] = '#00000000'\n\n\n\n9.3.1 Land\nSchauen wir uns die Anzahl der Länder an, aus denen in der Umfrage Antworten vorliegen, und zeichnen wir die 10 Länder mit der höchsten Anzahl an Antworten auf.\n\n\nCode\nschema.Country\n\n\n'Where do you live?'\n\n\n\n\nCode\nsurvey_df.Country.nunique()\n\n\n183\n\n\nMit der Methode value_counts können wir die Länder mit der höchsten Anzahl an Befragten identifizieren.\n\n\nCode\nsurvey_df.Country.value_counts()\n\n\nUnited States          12371\nIndia                   8364\nUnited Kingdom          3881\nGermany                 3864\nCanada                  2175\n                       ...  \nNauru                      1\nLesotho                    1\nSaint Lucia                1\nAntigua and Barbuda        1\nMarshall Islands           1\nName: Country, Length: 183, dtype: int64\n\n\n\n\nCode\ntop_countries = survey_df.Country.value_counts().head(15)\ntop_countries\n\n\nUnited States         12371\nIndia                  8364\nUnited Kingdom         3881\nGermany                3864\nCanada                 2175\nFrance                 1884\nBrazil                 1804\nNetherlands            1332\nPoland                 1259\nAustralia              1199\nSpain                  1157\nItaly                  1115\nRussian Federation     1085\nSweden                  879\nPakistan                802\nName: Country, dtype: int64\n\n\nWir können diese Informationen mithilfe eines Balkendiagramms visualisieren.\n\n\nCode\nplt.figure(figsize=(12,6))\nplt.xticks(rotation=75)\nplt.title(schema.Country)\nsns.barplot(x=top_countries.index, y=top_countries);\n\n\n\n\n\n\n\n\n\nEs scheint, dass überproportional viele Befragte aus den USA und Indien stammen – was zu erwarten ist, da diese Länder (abgesehen von China) die höchste Bevölkerungszahl haben und die Umfrage auf Englisch erfolgt, der von Fachleuten in China allgemein verwendeten Sprache USA, Indien und Großbritannien. Wir können bereits erkennen, dass die Umfrage möglicherweise nicht repräsentativ für die gesamte Programmiergemeinschaft ist – insbesondere für nicht englischsprachige Länder.\nÜbung: Versuchen Sie, den Prozentsatz der Antworten aus englischsprachigen im Vergleich zu nicht englischsprachigen Ländern zu ermitteln. Sie können diese Liste der in verschiedenen Ländern gesprochenen Sprachen verwenden.\n\n\n9.3.2 Alter\nDie Verteilung des Alters der Befragten ist ein weiterer wichtiger zu betrachtender Faktor, den wir mithilfe eines Histogramms visualisieren können.\n\n\nCode\nschema.Age\n\n\n'What is your age (in years)? If you prefer not to answer, you may leave this question blank.'\n\n\n\n\nCode\nplt.figure(figsize=(12, 6))\nplt.title(schema.Age)\nplt.xlabel('Age')\nplt.ylabel('Number of respondents')\n\nplt.hist(survey_df.Age, bins=np.arange(10,100,5), color='purple');\n\n\n\n\n\n\n\n\n\nEs scheint, dass ein großer Prozentsatz der Befragten im Alter zwischen 20 und 45 Jahren ist, was einigermaßen repräsentativ für die Programmiergemeinschaft im Allgemeinen ist, da viele junge Menschen in den letzten 20 Jahren Computer als Studienfach oder Beruf gewählt haben.\nÜbung: Möglicherweise möchten Sie die Antworten nach Alter (oder Altersgruppe) herausfiltern, wenn Sie die Ergebnisse der Umfrage für verschiedene Altersgruppen analysieren und vergleichen möchten. Erstellen Sie eine neue Spalte mit dem Namen AgeGroup, die Werte wie Less than 10 years, 10-18 years, 18-30 years, 30-45 years, 45-60 years, Older than 60 years und wiederholen Sie die Analyse im Rest dieses Notizbuchs für jede Altersgruppe.\n\n\n9.3.3 Geschlecht\nSchauen wir uns die Verteilung der Antworten für das Geschlecht an. Es ist eine bekannte Tatsache, dass Frauen und nicht-binäre Geschlechter in der Programmiergemeinschaft unterrepräsentiert sind, sodass wir hier mit einer ungleichen Verteilung rechnen können.\n\n\nCode\nschema.Gender\n\n\n'Which of the following describe you, if any? Please check all that apply. If you prefer not to answer, you may leave this question blank.'\n\n\n\n\nCode\ngender_counts = survey_df.Gender.value_counts()\ngender_counts\n\n\nMan                                                  45895\nWoman                                                 3835\nNon-binary, genderqueer, or gender non-conforming      385\nName: Gender, dtype: int64\n\n\n\n\nCode\nplt.figure(figsize=(12,6))\nplt.title(schema.Gender)\nplt.pie(gender_counts, labels=gender_counts.index, autopct='%1.1f%%', startangle=180);\n\n\n\n\n\n\n\n\n\n\n\nCode\ngender_counts = survey_df.Gender.value_counts(dropna=False)\ngender_counts\n\n\nMan                                                  45895\nNaN                                                  14191\nWoman                                                 3835\nNon-binary, genderqueer, or gender non-conforming      385\nName: Gender, dtype: int64\n\n\nEin Kreisdiagramm wäre eine gute Möglichkeit, die Verteilung zu visualisieren.\n\n\nCode\nplt.figure(figsize=(12,6))\nplt.title(schema.Gender)\nplt.pie(gender_counts, labels=gender_counts.index, autopct='%1.1f%%', startangle=180);\n\n\n\n\n\n\n\n\n\nNur etwa 8 % der Umfrageteilnehmer, die die Frage beantwortet haben, identifizieren sich als Frauen oder nicht-binär. Diese Zahl ist niedriger als der Gesamtanteil von Frauen und nicht-binären Geschlechtern in der Programmiergemeinschaft, der auf etwa 12 % geschätzt wird.\nÜbung: Es wäre interessant, die Antworten und Präferenzen der Umfrage nach Geschlechtern zu vergleichen. Wir empfehlen Ihnen, diese Analyse mit diesen Aufschlüsselungen zu wiederholen. Wie unterscheiden sich die relativen Bildungsniveaus zwischen den Geschlechtern? Wie unterscheiden sich die Gehälter? Sie finden diese Analyse möglicherweise auf der Website Gender Divide in Data Science nützlich.\n\n\n9.3.4 Bildungsniveau\nEine formale Ausbildung in Informatik wird oft als wichtige Voraussetzung für die Karriere als Programmierer angesehen. Mal sehen, ob dies tatsächlich der Fall ist, insbesondere da online viele kostenlose Ressourcen und Tutorials zum Erlernen des Programmierens verfügbar sind. Wir verwenden ein horizontales Balkendiagramm, um das Bildungsniveau der Befragten zu vergleichen.\n\n\nCode\nschema.EdLevel\n\n\n'Which of the following best describes the highest level of formal education that you’ve completed?'\n\n\n\n\nCode\nsns.countplot(y=survey_df.EdLevel)\nplt.xticks(rotation=75);\nplt.title(schema['EdLevel'])\nplt.ylabel(None);\n\n\n\n\n\n\n\n\n\nEs scheint, dass deutlich mehr als die Hälfte der Befragten einen Bachelor- oder Master-Abschluss haben, die meisten Programmierer scheinen also definitiv über eine Hochschulausbildung zu verfügen, obwohl aus dieser Grafik allein nicht klar hervorgeht, ob sie einen Abschluss in Informatik haben.\nÜbungen: Das Diagramm zeigt derzeit die Anzahl der Befragten für jede Option. Können Sie es ändern, um stattdessen den Prozentsatz anzuzeigen? Können Sie die Grafik außerdem aufschlüsseln, um die Prozentsätze für jeden Grad für Männer und Frauen zu vergleichen?\nLassen Sie uns auch die Bachelor-Studiengänge grafisch darstellen, aber dieses Mal werden wir die Zahlen in Prozentsätze umwandeln und nach Prozentwerten sortieren, um die Reihenfolge besser visualisieren zu können.\n\n\nCode\nschema.UndergradMajor\n\n\n'What was your primary field of study?'\n\n\n\n\nCode\nundergrad_pct = survey_df.UndergradMajor.value_counts() * 100 / survey_df.UndergradMajor.count()\n\nsns.barplot(x=undergrad_pct, y=undergrad_pct.index)\n\nplt.title(schema.UndergradMajor)\nplt.ylabel(None);\nplt.xlabel('Percentage');\n\n\n\n\n\n\n\n\n\nEs stellt sich heraus, dass 40 % der Programmierer mit Hochschulabschluss ein anderes Studienfach als Informatik haben – was sehr ermutigend ist. Dies scheint darauf hinzudeuten, dass eine Hochschulausbildung zwar im Allgemeinen hilfreich ist, Sie jedoch kein Hauptfach in Informatik absolvieren müssen, um ein erfolgreicher Programmierer zu werden.\nÜbungen: Analysieren Sie die Ergebnisse der Spalte NEWEdImpt für Befragte mit einem Hochschulabschluss im Vergleich zu denen ohne Hochschulabschluss. Bemerken Sie einen Meinungsunterschied?\n\n\nCode\nschema.NEWEdImpt\n\n\n'How important is a formal education, such as a university degree in computer science, to your career?'\n\n\n\n\n9.3.5 Arbeitsverhältnis\nProgrammierer entscheiden sich häufig für freiberufliche Arbeit oder Vertragsarbeit, daher wäre es interessant, die Aufteilung zwischen Vollzeit-, Teilzeit- und freiberuflicher Arbeit zu vergleichen. Lassen Sie uns die Daten aus der Spalte Employment visualisieren.\n\n\nCode\nschema.Employment\n\n\n'Which of the following best describes your current employment status?'\n\n\n\n\nCode\n(survey_df.Employment.value_counts(normalize=True, ascending=True)*100).plot(kind='barh', color='g')\nplt.title(schema.Employment)\nplt.xlabel('Percentage');\n\n\n\n\n\n\n\n\n\nEs scheint, dass knapp 10 % der Befragten in Teilzeit oder als Freiberufler beschäftigt sind.\nÜbung: Fügen Sie eine neue Spalte EmploymentType hinzu, die die Werte Enthusiast (Student oder nicht angestellt, aber auf der Suche nach Arbeit), Professional (vollzeitbeschäftigt, Teilzeit oder freiberuflich tätig) und enthält Other (nicht angestellt oder im Ruhestand). Zeigen Sie für jede der folgenden Grafiken einen Vergleich zwischen Enthusiast und Professional.\nDas Feld DevType enthält Informationen zu den Rollen, die die Befragten innehaben. Da die Frage mehrere Antworten zulässt, enthält die Spalte Wertelisten, die durch ; getrennt sind, was die direkte Analyse etwas schwieriger macht.\n\n\nCode\nschema.DevType\n\n\n'Which of the following describe you? Please select all that apply.'\n\n\n\n\nCode\nsurvey_df.DevType.value_counts()\n\n\nDeveloper, full-stack                                                                                                                                                           4396\nDeveloper, back-end                                                                                                                                                             3056\nDeveloper, back-end;Developer, front-end;Developer, full-stack                                                                                                                  2214\nDeveloper, back-end;Developer, full-stack                                                                                                                                       1465\nDeveloper, front-end                                                                                                                                                            1390\n                                                                                                                                                                                ... \nDatabase administrator;Developer, back-end;Developer, front-end;Developer, full-stack;Developer, QA or test;Senior executive/VP                                                    1\nDatabase administrator;Developer, back-end;Developer, front-end;Developer, full-stack;Product manager;Senior executive/VP                                                          1\nDeveloper, back-end;Developer, full-stack;Developer, mobile;DevOps specialist;Educator;System administrator                                                                        1\nData or business analyst;Database administrator;Developer, back-end;Developer, desktop or enterprise applications;Developer, front-end;Developer, mobile;Engineering manager       1\nData or business analyst;Developer, mobile;Senior executive/VP;System administrator                                                                                                1\nName: DevType, Length: 8213, dtype: int64\n\n\nDefinieren wir eine Hilfsfunktion, die eine Spalte mit Wertelisten (wie survey_df.DevType) in einem Data Frame mit einer Spalte für jede mögliche Option umwandelt.\n\n\nCode\ndef split_multicolumn(col_series):\n    result_df = col_series.to_frame()\n    options = []\n    # Iterate over the column\n    for idx, value  in col_series[col_series.notnull()].items():\n        # Break each value into list of options\n        for option in value.split(';'):\n            # Add the option as a column to result\n            if not option in result_df.columns:\n                options.append(option)\n                result_df[option] = False\n            # Mark the value in the option column as True\n            result_df.at[idx, option] = True\n    return result_df[options]\n\n\n\n\nCode\ndev_type_df = split_multicolumn(survey_df.DevType)\n\n\n\n\nCode\ndev_type_df\n\n\n\n\n\n\n\n\n\nDeveloper, desktop or enterprise applications\nDeveloper, full-stack\nDeveloper, mobile\nDesigner\nDeveloper, front-end\nDeveloper, back-end\nDeveloper, QA or test\nDevOps specialist\nDeveloper, game or graphics\nDatabase administrator\n...\nSystem administrator\nEngineering manager\nProduct manager\nData or business analyst\nAcademic researcher\nData scientist or machine learning specialist\nScientist\nSenior executive/VP\nEngineer, site reliability\nMarketing or sales professional\n\n\n\n\n0\nTrue\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n1\nFalse\nTrue\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n2\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n3\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n4\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n64456\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n\n\n64457\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n64458\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n64459\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n64460\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n\n\n64306 rows × 23 columns\n\n\n\ndev_type_df hat eine Spalte für jede Option, die als Antwort ausgewählt werden kann. Wenn ein Befragter die Option ausgewählt hat, ist der Wert in der Spalte True, andernfalls ist er False.\nWir können nun die spaltenweisen Summen verwenden, um die häufigsten Rollen zu identifizieren.\n\n\nCode\ndev_type_totals = dev_type_df.sum().sort_values(ascending=False)\ndev_type_totals\n\n\nDeveloper, back-end                              26996\nDeveloper, full-stack                            26915\nDeveloper, front-end                             18128\nDeveloper, desktop or enterprise applications    11687\nDeveloper, mobile                                 9406\nDevOps specialist                                 5915\nDatabase administrator                            5658\nDesigner                                          5262\nSystem administrator                              5185\nDeveloper, embedded applications or devices       4701\nData or business analyst                          3970\nData scientist or machine learning specialist     3939\nDeveloper, QA or test                             3893\nEngineer, data                                    3700\nAcademic researcher                               3502\nEducator                                          2895\nDeveloper, game or graphics                       2751\nEngineering manager                               2699\nProduct manager                                   2471\nScientist                                         2060\nEngineer, site reliability                        1921\nSenior executive/VP                               1292\nMarketing or sales professional                    625\ndtype: int64\n\n\nWie zu erwarten ist, enthalten die häufigsten Rollen „Developer“ im Namen.\nÜbungen:\n\nKönnen Sie herausfinden, wie viel Prozent der Befragten in Rollen mit Bezug zur Datenwissenschaft arbeiten?\nWelche Rolle hat den höchsten Frauenanteil?\n\nWir haben nur eine Handvoll der 20 ausgewählten Spalten untersucht. Erkunden und visualisieren Sie die verbleibenden Spalten mithilfe der leeren Zellen unten.\n\n\nCode\n# Tragen Sie Ihren Code hier ein!",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Explorative Datenanalyse mit Python – Eine Fallstudie</span>"
    ]
  },
  {
    "objectID": "kapitel8.html#fragen-stellen-und-beantworten",
    "href": "kapitel8.html#fragen-stellen-und-beantworten",
    "title": "9  Explorative Datenanalyse mit Python – Eine Fallstudie",
    "section": "9.4 Fragen stellen und beantworten",
    "text": "9.4 Fragen stellen und beantworten\nWir haben bereits mehrere Erkenntnisse über die Befragten und die Programmiergemeinschaft im Allgemeinen gewonnen, indem wir einfach einzelne Spalten des Datensatzes untersucht haben. Lassen Sie uns einige spezifische Fragen stellen und versuchen, sie mithilfe von Data Frame-Operationen und interessanten Visualisierungen zu beantworten.\n\n9.4.1 F: Welche waren die beliebtesten Programmiersprachen im Jahr 2020?\nUm dies zu beantworten, können wir die Spalte LanguageWorkedWith verwenden. Ähnlich wie bei DevType konnten die Befragten hier mehrere Optionen auswählen.\n\n\nCode\nschema.LanguageWorkedWith\n\n\n'Which programming, scripting, and markup languages have you done extensive development work in over the past year, and which do you want to work in over the next year? (If you both worked with the language and want to continue to do so, please check both boxes in that row.)'\n\n\n\n\nCode\nschema.LanguageDesireNextYear\n\n\n'Which programming, scripting, and markup languages have you done extensive development work in over the past year, and which do you want to work in over the next year? (If you both worked with the language and want to continue to do so, please check both boxes in that row.)'\n\n\n\n\nCode\nsurvey_df.LanguageWorkedWith\n\n\n0                                   C#;HTML/CSS;JavaScript\n1                                         JavaScript;Swift\n2                                 Objective-C;Python;Swift\n3                                                      NaN\n4                                        HTML/CSS;Ruby;SQL\n                               ...                        \n64456                                                  NaN\n64457    Assembly;Bash/Shell/PowerShell;C;C#;C++;Dart;G...\n64458                                                  NaN\n64459                                             HTML/CSS\n64460                      C#;HTML/CSS;Java;JavaScript;SQL\nName: LanguageWorkedWith, Length: 64306, dtype: object\n\n\nZuerst teilen wir diese Spalte in ein Data Frame auf, der eine Spalte für jede in den Optionen aufgeführte Sprache enthält.\n\n\nCode\nlanguages_worked_df = split_multicolumn(survey_df.LanguageWorkedWith)\n\n\n\n\nCode\nlanguages_worked_df\n\n\n\n\n\n\n\n\n\nC#\nHTML/CSS\nJavaScript\nSwift\nObjective-C\nPython\nRuby\nSQL\nJava\nPHP\n...\nVBA\nPerl\nScala\nC++\nGo\nHaskell\nRust\nDart\nJulia\nAssembly\n\n\n\n\n0\nTrue\nTrue\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n1\nFalse\nFalse\nTrue\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n2\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n3\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n4\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nTrue\nTrue\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n64456\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n64457\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n...\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n\n\n64458\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n64459\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n64460\nTrue\nTrue\nTrue\nFalse\nFalse\nFalse\nFalse\nTrue\nTrue\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n\n\n64306 rows × 25 columns\n\n\n\nEs scheint, dass insgesamt 25 Sprachen in den Optionen enthalten waren. Fassen wir diese zusammen, um den Prozentsatz der Befragten zu ermitteln, die die einzelnen Sprachen ausgewählt haben.\n\n\nCode\nlanguages_worked_percentages = languages_worked_df.mean().sort_values(ascending=False) * 100\nlanguages_worked_percentages\n\n\nJavaScript               59.893323\nHTML/CSS                 55.801947\nSQL                      48.444935\nPython                   39.001026\nJava                     35.618760\nBash/Shell/PowerShell    29.239884\nC#                       27.803004\nPHP                      23.130035\nTypeScript               22.461357\nC++                      21.114670\nC                        19.236152\nGo                        7.758219\nKotlin                    6.887382\nRuby                      6.229590\nAssembly                  5.447392\nVBA                       5.394520\nSwift                     5.226573\nR                         5.064846\nRust                      4.498803\nObjective-C               3.603085\nDart                      3.517557\nScala                     3.150561\nPerl                      2.757130\nHaskell                   1.861413\nJulia                     0.782198\ndtype: float64\n\n\nWir können diese Informationen mithilfe eines horizontalen Balkendiagramms darstellen.\n\n\nCode\nplt.figure(figsize=(12, 12))\nsns.barplot(x=languages_worked_percentages, y=languages_worked_percentages.index)\nplt.title(\"Languages used in the past year\");\nplt.xlabel('count');\n\n\n\n\n\n\n\n\n\nEs überrascht vielleicht nicht, dass Javascript und HTML/CSS an der Spitze stehen, da die Webentwicklung heutzutage eine der gefragtesten Fähigkeiten ist und zufälligerweise auch eine der am einfachsten zu erlernenden Fähigkeiten ist. SQL ist für die Arbeit mit relationalen Datenbanken notwendig, daher ist es keine Überraschung, dass die meisten Programmierer regelmäßig mit SQL arbeiten. Für andere Entwicklungsformen scheint Python die beliebteste Wahl zu sein und Java zu verdrängen, das über zwei Jahrzehnte lang der Industriestandard für die Server- und Anwendungsentwicklung war.\nÜbungen:\n\nWelche Sprachen werden von Studierenden am häufigsten verwendet? Wie schneidet die Liste im Vergleich zu den am häufigsten von professionellen Entwicklern verwendeten Sprachen ab?\nWelches sind die häufigsten Sprachen unter den Befragten, die sich selbst nicht als „Entwickler, Frontend“ bezeichnen?\nWelche Sprachen werden unter den Befragten, die in Bereichen mit Bezug zur Datenwissenschaft arbeiten, am häufigsten gesprochen?\nWelche Sprachen werden am häufigsten von Entwicklern verwendet, die älter als 35 Jahre sind?\nWelche Sprachen werden von Entwicklern in Ihrem Heimatland am häufigsten verwendet?\n\n\n\n9.4.2 F: Welche Sprachen möchten die Menschen im nächsten Jahr am meisten lernen?\nHierzu können wir die Spalte LanguageDesireNextYear mit ähnlicher Verarbeitung wie die vorherige verwenden.\n\n\nCode\nschema.LanguageDesireNextYear\n\n\n'Which programming, scripting, and markup languages have you done extensive development work in over the past year, and which do you want to work in over the next year? (If you both worked with the language and want to continue to do so, please check both boxes in that row.)'\n\n\n\n\nCode\nlanguages_interested_df = split_multicolumn(survey_df.LanguageDesireNextYear)\nlanguages_interested_percentages = languages_interested_df.mean().sort_values(ascending=False) * 100\nlanguages_interested_percentages\n\n\nPython                   41.143906\nJavaScript               40.425466\nHTML/CSS                 32.028116\nSQL                      30.799614\nTypeScript               26.451653\nC#                       21.058688\nJava                     20.464653\nGo                       19.432090\nBash/Shell/PowerShell    18.057413\nRust                     16.270643\nC++                      15.014151\nKotlin                   14.760676\nPHP                      10.947657\nC                         9.359935\nSwift                     8.692812\nDart                      7.308805\nR                         6.571704\nRuby                      6.425528\nScala                     5.326097\nHaskell                   4.593662\nAssembly                  3.766367\nJulia                     2.540976\nObjective-C               2.338818\nPerl                      1.761888\nVBA                       1.611047\ndtype: float64\n\n\n\n\nCode\nplt.figure(figsize=(12, 12))\nsns.barplot(x=languages_interested_percentages, y=languages_interested_percentages.index)\nplt.title(\"Languages people are intersted in learning over the next year\");\nplt.xlabel('count');\n\n\n\n\n\n\n\n\n\nAuch hier ist es nicht verwunderlich, dass Python die Sprache ist, die die meisten Menschen lernen möchten – da es sich um eine leicht zu erlernende Allzweck-Programmiersprache handelt, die sich gut für eine Vielzahl von Bereichen eignet: Anwendungsentwicklung, numerische Berechnungen, Datenanalyse, maschinelles Lernen , Big Data, Cloud-Automatisierung, Web Scraping, Scripting usw. usw. Wir verwenden Python für genau diese Analyse, also sind wir in guter Gesellschaft!\nÜbungen: Wiederholen Sie alle Übungen für die vorherige Frage und ersetzen Sie dabei „am häufigsten verwendete Sprachen“ durch „Sprachen, die Menschen gerne lernen/anwenden“.\n\n\n9.4.3 F: Welche sind die beliebtesten Sprachen, d. h. ein hoher Prozentsatz der Menschen, die die Sprache verwendet haben, möchten sie im nächsten Jahr weiter lernen und verwenden?\nAuch wenn diese Frage auf den ersten Blick schwierig erscheinen mag, ist sie mit Pandas-Array-Operationen wirklich einfach zu lösen. Folgendes können wir tun:\n\nErstellen Sie ein neues Data Frame languages_loved_df, der nur dann einen True-Wert für eine Sprache enthält, wenn die entsprechenden Werte in languages_worked_df und languages_interested_df beide True sind.\nNehmen Sie die spaltenweise Summe von languages_loved_df und dividieren Sie sie durch die spaltenweise Summe von languages_worked_df, um den Prozentsatz der Befragten zu erhalten, die die Sprache „lieben“.\nSortieren Sie die Ergebnisse in absteigender Reihenfolge und zeichnen Sie ein horizontales Balkendiagramm\n\n\n\nCode\nTrue & False\n\n\nFalse\n\n\n\n\nCode\nlanguages_loved_df = languages_worked_df & languages_interested_df\n\n\n\n\nCode\nlanguages_loved_df\n\n\n\n\n\n\n\n\n\nAssembly\nBash/Shell/PowerShell\nC\nC#\nC++\nDart\nGo\nHTML/CSS\nHaskell\nJava\n...\nPerl\nPython\nR\nRuby\nRust\nSQL\nScala\nSwift\nTypeScript\nVBA\n\n\n\n\n0\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n1\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n\n\n2\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n\n\n3\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n4\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n64456\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n64457\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n...\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n\n\n64458\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n64459\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\n64460\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\n...\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\n\n\n\n\n64306 rows × 25 columns\n\n\n\n\n\nCode\nlanguages_loved_percentages = (languages_loved_df.sum() * 100/ languages_worked_df.sum()).sort_values(ascending=False)\n\n\n\n\nCode\nlanguages_loved_percentages\n\n\nRust                     86.069824\nTypeScript               67.114373\nPython                   66.598884\nKotlin                   62.813276\nGo                       62.176789\nDart                     62.068966\nJulia                    61.431412\nC#                       59.623021\nSwift                    59.476346\nJavaScript               58.353888\nSQL                      56.607710\nBash/Shell/PowerShell    53.688241\nHTML/CSS                 53.494594\nScala                    53.257651\nHaskell                  51.378446\nR                        44.427387\nJava                     44.108273\nC++                      43.415820\nRuby                     42.735896\nPHP                      37.232755\nC                        32.983023\nAssembly                 29.089352\nPerl                     28.369994\nObjective-C              23.133362\nVBA                      19.458057\ndtype: float64\n\n\n\n\nCode\nplt.figure(figsize=(12, 12))\nsns.barplot(x=languages_loved_percentages, y=languages_loved_percentages.index)\nplt.title(\"Most loved languages\");\nplt.xlabel('count');\n\n\n\n\n\n\n\n\n\nRust ist seit 4 Jahren in Folge die beliebteste Sprache auf StackOverflow, gefolgt von TypeScript, das in den letzten Jahren als gute Alternative zu JavaScript für die Webentwicklung an Popularität gewonnen hat.\nPython rangiert auf Platz 3, obwohl es bereits eine der am weitesten verbreiteten Sprachen der Welt ist. Dies zeigt auf, dass die Sprache eine solide Grundlage hat, wirklich einfach zu erlernen und zu verwenden ist, ein starkes Ökosystem von Bibliotheken für verschiedene Anwendungsfälle besitzt und eine riesige weltweite Gemeinschaft von Entwicklern hat, die Freude am Umgang mit ihr haben.\nÜbungen: Was sind die meistgefürchteten Sprachen, also Sprachen, die die Leute im vergangenen Jahr verwendet haben, aber im nächsten Jahr nicht erlernen oder verwenden wollen. Hinweis: ~languages_interested_df\n\n\n9.4.4 F: In welchen Ländern arbeiten Entwickler am meisten Stunden pro Woche? Berücksichtigen Sie nur Länder mit mehr als 250 Antworten.\nUm diese Frage zu beantworten, müssen wir die Data Frame-Methode groupby verwenden, um die Zeilen für jedes Land zu aggregieren. Außerdem müssen wir die Ergebnisse filtern, um nur die Länder einzuschließen, die mehr als 250 Befragte haben.\n\n\nCode\nsurvey_df.groupby('Country')[['WorkWeekHrs', 'Age']].mean()\n\n\n\n\n\n\n\n\n\nWorkWeekHrs\nAge\n\n\nCountry\n\n\n\n\n\n\nAfghanistan\n46.500000\n23.571429\n\n\nAlbania\n43.962963\n26.766667\n\n\nAlgeria\n36.862069\n28.019608\n\n\nAndorra\n42.000000\n39.000000\n\n\nAngola\n24.500000\n25.500000\n\n\n...\n...\n...\n\n\nVenezuela, Bolivarian Republic of...\n40.125000\n29.090909\n\n\nViet Nam\n41.391667\n25.786585\n\n\nYemen\n40.000000\n31.000000\n\n\nZambia\n38.000000\n29.000000\n\n\nZimbabwe\n39.928571\n25.578947\n\n\n\n\n183 rows × 2 columns\n\n\n\n\n\nCode\ncountries_df = survey_df.groupby('Country')[['WorkWeekHrs']].mean().sort_values('WorkWeekHrs', ascending=False)\n\n\n\n\nCode\nhigh_response_countries_df = countries_df.loc[survey_df.Country.value_counts() &gt; 250].head(15)\n\n\n\n\nCode\nhigh_response_countries_df\n\n\n\n\n\n\n\n\n\nWorkWeekHrs\n\n\nCountry\n\n\n\n\n\nIran\n44.337748\n\n\nIsrael\n43.915094\n\n\nChina\n42.150000\n\n\nUnited States\n41.802982\n\n\nGreece\n41.402724\n\n\nViet Nam\n41.391667\n\n\nSouth Africa\n41.023460\n\n\nTurkey\n40.982143\n\n\nSri Lanka\n40.612245\n\n\nNew Zealand\n40.457551\n\n\nBelgium\n40.444444\n\n\nCanada\n40.208837\n\n\nHungary\n40.194340\n\n\nBangladesh\n40.097458\n\n\nIndia\n40.090603\n\n\n\n\n\n\n\nDie asiatischen Länder wie Iran, China und Israel haben die höchsten Arbeitszeiten, gefolgt von den Vereinigten Staaten. Allerdings gibt es insgesamt keine allzu großen Unterschiede und die durchschnittliche Arbeitszeit scheint bei etwa 40 Stunden pro Woche zu liegen.\nÜbungen:\n\nWie sind die durchschnittlichen Arbeitsstunden auf verschiedenen Kontinenten zu vergleichen? Möglicherweise finden Sie diese Liste von Ländern auf jedem Kontinent hilfreich.\nWelche Rolle hat die höchste durchschnittliche Anzahl an Arbeitsstunden pro Woche? Welche Rolle hat die niedrigste?\nWie sind die geleisteten Arbeitsstunden im Vergleich zwischen Freiberuflern und Entwicklern, die Vollzeit arbeiten?\n\n\n\n9.4.5 F: Wie wichtig ist es, jung anzufangen, um eine Karriere im Programmieren aufzubauen?\nLassen Sie uns ein Streudiagramm von Age vs. YearsCodePro (d. h. Jahre Programmiererfahrung) erstellen, um diese Frage zu beantworten.\n\n\nCode\nschema.YearsCodePro\n\n\n'NOT including education, how many years have you coded professionally (as a part of your work)?'\n\n\n\n\nCode\nsns.scatterplot(x='Age', y='YearsCodePro', hue='Hobbyist', data=survey_df)\nplt.xlabel(\"Age\")\nplt.ylabel(\"Years of professional coding experience\");\n\n\n\n\n\n\n\n\n\nSie können überall in der Grafik Punkte sehen, was darauf hindeutet, dass Sie in jedem Alter professionell mit dem Programmieren beginnen können. Außerdem scheinen viele Menschen, die seit mehreren Jahrzehnten beruflich mit dem Programmieren beschäftigt sind, auch als Hobby Spaß daran haben.\nWir können auch die Verteilung der Spalte Age1stCode anzeigen, um zu sehen, wann die Befragten zum ersten Mal versucht haben, zu programmieren.\n\n\nCode\nplt.title(schema.Age1stCode)\nsns.histplot(survey_df.Age1stCode);\n\n\n\n\n\n\n\n\n\nWie zu erwarten ist, scheinen die meisten Menschen bereits vor ihrem 40. Lebensjahr mit dem Programmieren in Berührung gekommen zu sein, aber es gibt Menschen jeden Alters und jeder Gesellschaftsschicht, die das Programmieren lernen.\nÜbungen: * Wie verändert Erfahrung Meinungen und Vorlieben? Wiederholen Sie die gesamte Analyse und vergleichen Sie dabei die Antworten von Personen mit mehr als 10 Jahren professioneller Programmiererfahrung mit denen von Personen, die weniger als 10 Jahre professionelle Programmiererfahrung verfügen. Sehen Sie interessante Trends? * Vergleichen Sie die Jahre professioneller Programmiererfahrung verschiedener Geschlechter.\nBenutzen Sie die leeren Zellen unten, um weitere Fragen zu stellen und zu beantworten.\n\n\nCode\n# Tragen Sie Ihren Code hier ein!",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Explorative Datenanalyse mit Python – Eine Fallstudie</span>"
    ]
  },
  {
    "objectID": "kapitel8.html#schlussfolgerungen-und-ergebnisse",
    "href": "kapitel8.html#schlussfolgerungen-und-ergebnisse",
    "title": "9  Explorative Datenanalyse mit Python – Eine Fallstudie",
    "section": "9.5 Schlussfolgerungen und Ergebnisse",
    "text": "9.5 Schlussfolgerungen und Ergebnisse\nWir haben viele interessante Schlussfolgerungen aus der Umfrage gezogen, hier ist eine Zusammenfassung von einigen davon:\n\nBasierend auf den demografischen Daten der Umfrageteilnehmer können wir schließen, dass die Umfrage in gewisser Weise repräsentativ für die gesamte Programmiergemeinschaft ist, obwohl sie definitiv weniger Antworten von Programmierern aus nicht-englischsprachigen Ländern und von Frauen & nicht-binären Geschlechtern hat.\nDie Programmiergemeinschaft ist nicht so vielfältig, wie sie sein könnte, und obwohl sich die Dinge verbessern, sollten wir mehr Anstrengungen unternehmen, um Mitglieder von unterrepräsentierten Gemeinschaften zu unterstützen und zu ermutigen - sei es hinsichtlich des Alters, des Landes, der Rasse, des Geschlechts oder sonstiger Aspekte.\nDie meisten Programmierer haben einen Hochschulabschluss, obwohl ein ziemlich großer Prozentsatz im College nicht Informatik als Hauptfach hatte. Daher ist ein Informatikabschluss nicht zwingend notwendig, um das Programmieren zu erlernen oder eine Karriere in der Programmierung aufzubauen.\nEin bedeutender Prozentsatz der Programmierer arbeitet entweder Teilzeit oder als Freiberufler, und das kann ein großartiger Weg sein, um in das Feld einzusteigen, besonders wenn man gerade erst anfängt.\nJavascript & HTML/CSS sind die am häufigsten verwendeten Programmiersprachen im Jahr 2020, dicht gefolgt von SQL & Python.\nPython ist die Sprache, die die meisten Leute lernen möchten - da es eine leicht zu erlernende allgemeine Programmiersprache ist, die gut für eine Vielzahl von Bereichen geeignet ist.\nRust und TypeScript sind die “beliebtesten” Sprachen im Jahr 2020, beide haben kleine, aber schnell wachsende Gemeinschaften. Python ist ein enger Dritter, obwohl es bereits eine weit verbreitete Sprache ist.\nProgrammierer auf der ganzen Welt scheinen durchschnittlich etwa 40 Stunden pro Woche zu arbeiten, mit leichten Variationen je nach Land.\nMan kann in jedem Alter programmieren lernen und professionell einsteigen, und man hat wahrscheinlich eine lange und erfüllende Karriere, wenn man auch das Programmieren als Hobby genießt.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Explorative Datenanalyse mit Python – Eine Fallstudie</span>"
    ]
  },
  {
    "objectID": "kapitel8.html#referenzen-und-zukünftige-arbeit",
    "href": "kapitel8.html#referenzen-und-zukünftige-arbeit",
    "title": "9  Explorative Datenanalyse mit Python – Eine Fallstudie",
    "section": "9.6 Referenzen und zukünftige Arbeit",
    "text": "9.6 Referenzen und zukünftige Arbeit\nMit der Umfrage lässt sich eine Fülle von Informationen entdecken, und wir haben gerade erst an der Oberfläche gekratzt. Hier sind einige Ideen für eine weitere Erkundung:\n\nWiederholen Sie die Analyse für verschiedene Altersgruppen und Geschlechter und vergleichen Sie die Ergebnisse.\nWählen Sie eine andere Gruppe von Spalten (wir haben 20 von 65 gewählt) aus, um andere Aspekte der Daten zu analysieren.\nBereiten Sie eine Analyse mit Schwerpunkt auf Vielfalt vor und identifizieren Sie Bereiche, in denen unterrepräsentierte Gemeinschaften mit der Mehrheit gleichauf sind (z.B. Bildung) und wo sie es nicht sind (z.B. Gehälter).\nVergleichen Sie die Ergebnisse dieser Umfrage mit denen der Vorjahre und identifizieren Sie interessante Trends.\n\nReferenzen:\n\nStack Overflow Entwicklerumfrage\nPandas Benutzerhandbuch\nMatplotlib Benutzerhandbuch\nSeaborn Benutzerhandbuch & Tutorial\nopendatasets Python-Bibliothek",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Explorative Datenanalyse mit Python – Eine Fallstudie</span>"
    ]
  }
]